   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  11               	_crc8_ccitt_update:
  12               	.LFB4:
  13               		.file 1 "/usr/lib/avr/include/util/crc16.h"
   1:/usr/lib/avr/include/util/crc16.h **** /* Copyright (c) 2002, 2003, 2004  Marek Michalkiewicz
   2:/usr/lib/avr/include/util/crc16.h ****    Copyright (c) 2005, 2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/crc16.h ****    Copyright (c) 2013 Dave Hylands
   4:/usr/lib/avr/include/util/crc16.h ****    Copyright (c) 2013 Frederic Nadeau
   5:/usr/lib/avr/include/util/crc16.h ****    All rights reserved.
   6:/usr/lib/avr/include/util/crc16.h **** 
   7:/usr/lib/avr/include/util/crc16.h ****    Redistribution and use in source and binary forms, with or without
   8:/usr/lib/avr/include/util/crc16.h ****    modification, are permitted provided that the following conditions are met:
   9:/usr/lib/avr/include/util/crc16.h **** 
  10:/usr/lib/avr/include/util/crc16.h ****    * Redistributions of source code must retain the above copyright
  11:/usr/lib/avr/include/util/crc16.h ****      notice, this list of conditions and the following disclaimer.
  12:/usr/lib/avr/include/util/crc16.h **** 
  13:/usr/lib/avr/include/util/crc16.h ****    * Redistributions in binary form must reproduce the above copyright
  14:/usr/lib/avr/include/util/crc16.h ****      notice, this list of conditions and the following disclaimer in
  15:/usr/lib/avr/include/util/crc16.h ****      the documentation and/or other materials provided with the
  16:/usr/lib/avr/include/util/crc16.h ****      distribution.
  17:/usr/lib/avr/include/util/crc16.h **** 
  18:/usr/lib/avr/include/util/crc16.h ****    * Neither the name of the copyright holders nor the names of
  19:/usr/lib/avr/include/util/crc16.h ****      contributors may be used to endorse or promote products derived
  20:/usr/lib/avr/include/util/crc16.h ****      from this software without specific prior written permission.
  21:/usr/lib/avr/include/util/crc16.h **** 
  22:/usr/lib/avr/include/util/crc16.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  23:/usr/lib/avr/include/util/crc16.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  24:/usr/lib/avr/include/util/crc16.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  25:/usr/lib/avr/include/util/crc16.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  26:/usr/lib/avr/include/util/crc16.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  27:/usr/lib/avr/include/util/crc16.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  28:/usr/lib/avr/include/util/crc16.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  29:/usr/lib/avr/include/util/crc16.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  30:/usr/lib/avr/include/util/crc16.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  31:/usr/lib/avr/include/util/crc16.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  32:/usr/lib/avr/include/util/crc16.h ****   POSSIBILITY OF SUCH DAMAGE. */
  33:/usr/lib/avr/include/util/crc16.h **** 
  34:/usr/lib/avr/include/util/crc16.h **** /* $Id$ */
  35:/usr/lib/avr/include/util/crc16.h **** 
  36:/usr/lib/avr/include/util/crc16.h **** #ifndef _UTIL_CRC16_H_
  37:/usr/lib/avr/include/util/crc16.h **** #define _UTIL_CRC16_H_
  38:/usr/lib/avr/include/util/crc16.h **** 
  39:/usr/lib/avr/include/util/crc16.h **** #include <stdint.h>
  40:/usr/lib/avr/include/util/crc16.h **** 
  41:/usr/lib/avr/include/util/crc16.h **** /** \file */
  42:/usr/lib/avr/include/util/crc16.h **** /** \defgroup util_crc <util/crc16.h>: CRC Computations
  43:/usr/lib/avr/include/util/crc16.h ****     \code#include <util/crc16.h>\endcode
  44:/usr/lib/avr/include/util/crc16.h **** 
  45:/usr/lib/avr/include/util/crc16.h ****     This header file provides a optimized inline functions for calculating
  46:/usr/lib/avr/include/util/crc16.h ****     cyclic redundancy checks (CRC) using common polynomials.
  47:/usr/lib/avr/include/util/crc16.h **** 
  48:/usr/lib/avr/include/util/crc16.h ****     \par References:
  49:/usr/lib/avr/include/util/crc16.h **** 
  50:/usr/lib/avr/include/util/crc16.h ****     \par
  51:/usr/lib/avr/include/util/crc16.h **** 
  52:/usr/lib/avr/include/util/crc16.h ****     See the Dallas Semiconductor app note 27 for 8051 assembler example and
  53:/usr/lib/avr/include/util/crc16.h ****     general CRC optimization suggestions. The table on the last page of the
  54:/usr/lib/avr/include/util/crc16.h ****     app note is the key to understanding these implementations.
  55:/usr/lib/avr/include/util/crc16.h **** 
  56:/usr/lib/avr/include/util/crc16.h ****     \par
  57:/usr/lib/avr/include/util/crc16.h **** 
  58:/usr/lib/avr/include/util/crc16.h ****     Jack Crenshaw's "Implementing CRCs" article in the January 1992 isue of \e
  59:/usr/lib/avr/include/util/crc16.h ****     Embedded \e Systems \e Programming. This may be difficult to find, but it
  60:/usr/lib/avr/include/util/crc16.h ****     explains CRC's in very clear and concise terms. Well worth the effort to
  61:/usr/lib/avr/include/util/crc16.h ****     obtain a copy.
  62:/usr/lib/avr/include/util/crc16.h **** 
  63:/usr/lib/avr/include/util/crc16.h ****     A typical application would look like:
  64:/usr/lib/avr/include/util/crc16.h **** 
  65:/usr/lib/avr/include/util/crc16.h ****     \code
  66:/usr/lib/avr/include/util/crc16.h ****     // Dallas iButton test vector.
  67:/usr/lib/avr/include/util/crc16.h ****     uint8_t serno[] = { 0x02, 0x1c, 0xb8, 0x01, 0, 0, 0, 0xa2 };
  68:/usr/lib/avr/include/util/crc16.h **** 
  69:/usr/lib/avr/include/util/crc16.h ****     int
  70:/usr/lib/avr/include/util/crc16.h ****     checkcrc(void)
  71:/usr/lib/avr/include/util/crc16.h ****     {
  72:/usr/lib/avr/include/util/crc16.h **** 	uint8_t crc = 0, i;
  73:/usr/lib/avr/include/util/crc16.h **** 
  74:/usr/lib/avr/include/util/crc16.h **** 	for (i = 0; i < sizeof serno / sizeof serno[0]; i++)
  75:/usr/lib/avr/include/util/crc16.h **** 	    crc = _crc_ibutton_update(crc, serno[i]);
  76:/usr/lib/avr/include/util/crc16.h **** 
  77:/usr/lib/avr/include/util/crc16.h **** 	return crc; // must be 0
  78:/usr/lib/avr/include/util/crc16.h ****     }
  79:/usr/lib/avr/include/util/crc16.h ****     \endcode
  80:/usr/lib/avr/include/util/crc16.h **** */
  81:/usr/lib/avr/include/util/crc16.h **** 
  82:/usr/lib/avr/include/util/crc16.h **** /** \ingroup util_crc
  83:/usr/lib/avr/include/util/crc16.h ****     Optimized CRC-16 calculation.
  84:/usr/lib/avr/include/util/crc16.h **** 
  85:/usr/lib/avr/include/util/crc16.h ****     Polynomial: x^16 + x^15 + x^2 + 1 (0xa001)<br>
  86:/usr/lib/avr/include/util/crc16.h ****     Initial value: 0xffff
  87:/usr/lib/avr/include/util/crc16.h **** 
  88:/usr/lib/avr/include/util/crc16.h ****     This CRC is normally used in disk-drive controllers.
  89:/usr/lib/avr/include/util/crc16.h **** 
  90:/usr/lib/avr/include/util/crc16.h ****     The following is the equivalent functionality written in C.
  91:/usr/lib/avr/include/util/crc16.h **** 
  92:/usr/lib/avr/include/util/crc16.h ****     \code
  93:/usr/lib/avr/include/util/crc16.h ****     uint16_t
  94:/usr/lib/avr/include/util/crc16.h ****     crc16_update(uint16_t crc, uint8_t a)
  95:/usr/lib/avr/include/util/crc16.h ****     {
  96:/usr/lib/avr/include/util/crc16.h **** 	int i;
  97:/usr/lib/avr/include/util/crc16.h **** 
  98:/usr/lib/avr/include/util/crc16.h **** 	crc ^= a;
  99:/usr/lib/avr/include/util/crc16.h **** 	for (i = 0; i < 8; ++i)
 100:/usr/lib/avr/include/util/crc16.h **** 	{
 101:/usr/lib/avr/include/util/crc16.h **** 	    if (crc & 1)
 102:/usr/lib/avr/include/util/crc16.h **** 		crc = (crc >> 1) ^ 0xA001;
 103:/usr/lib/avr/include/util/crc16.h **** 	    else
 104:/usr/lib/avr/include/util/crc16.h **** 		crc = (crc >> 1);
 105:/usr/lib/avr/include/util/crc16.h **** 	}
 106:/usr/lib/avr/include/util/crc16.h **** 
 107:/usr/lib/avr/include/util/crc16.h **** 	return crc;
 108:/usr/lib/avr/include/util/crc16.h ****     }
 109:/usr/lib/avr/include/util/crc16.h **** 
 110:/usr/lib/avr/include/util/crc16.h ****     \endcode */
 111:/usr/lib/avr/include/util/crc16.h **** 
 112:/usr/lib/avr/include/util/crc16.h **** static __inline__ uint16_t
 113:/usr/lib/avr/include/util/crc16.h **** _crc16_update(uint16_t __crc, uint8_t __data)
 114:/usr/lib/avr/include/util/crc16.h **** {
 115:/usr/lib/avr/include/util/crc16.h **** 	uint8_t __tmp;
 116:/usr/lib/avr/include/util/crc16.h **** 	uint16_t __ret;
 117:/usr/lib/avr/include/util/crc16.h **** 
 118:/usr/lib/avr/include/util/crc16.h **** 	__asm__ __volatile__ (
 119:/usr/lib/avr/include/util/crc16.h **** 		"eor %A0,%2" "\n\t"
 120:/usr/lib/avr/include/util/crc16.h **** 		"mov %1,%A0" "\n\t"
 121:/usr/lib/avr/include/util/crc16.h **** 		"swap %1" "\n\t"
 122:/usr/lib/avr/include/util/crc16.h **** 		"eor %1,%A0" "\n\t"
 123:/usr/lib/avr/include/util/crc16.h **** 		"mov __tmp_reg__,%1" "\n\t"
 124:/usr/lib/avr/include/util/crc16.h **** 		"lsr %1" "\n\t"
 125:/usr/lib/avr/include/util/crc16.h **** 		"lsr %1" "\n\t"
 126:/usr/lib/avr/include/util/crc16.h **** 		"eor %1,__tmp_reg__" "\n\t"
 127:/usr/lib/avr/include/util/crc16.h **** 		"mov __tmp_reg__,%1" "\n\t"
 128:/usr/lib/avr/include/util/crc16.h **** 		"lsr %1" "\n\t"
 129:/usr/lib/avr/include/util/crc16.h **** 		"eor %1,__tmp_reg__" "\n\t"
 130:/usr/lib/avr/include/util/crc16.h **** 		"andi %1,0x07" "\n\t"
 131:/usr/lib/avr/include/util/crc16.h **** 		"mov __tmp_reg__,%A0" "\n\t"
 132:/usr/lib/avr/include/util/crc16.h **** 		"mov %A0,%B0" "\n\t"
 133:/usr/lib/avr/include/util/crc16.h **** 		"lsr %1" "\n\t"
 134:/usr/lib/avr/include/util/crc16.h **** 		"ror __tmp_reg__" "\n\t"
 135:/usr/lib/avr/include/util/crc16.h **** 		"ror %1" "\n\t"
 136:/usr/lib/avr/include/util/crc16.h **** 		"mov %B0,__tmp_reg__" "\n\t"
 137:/usr/lib/avr/include/util/crc16.h **** 		"eor %A0,%1" "\n\t"
 138:/usr/lib/avr/include/util/crc16.h **** 		"lsr __tmp_reg__" "\n\t"
 139:/usr/lib/avr/include/util/crc16.h **** 		"ror %1" "\n\t"
 140:/usr/lib/avr/include/util/crc16.h **** 		"eor %B0,__tmp_reg__" "\n\t"
 141:/usr/lib/avr/include/util/crc16.h **** 		"eor %A0,%1"
 142:/usr/lib/avr/include/util/crc16.h **** 		: "=r" (__ret), "=d" (__tmp)
 143:/usr/lib/avr/include/util/crc16.h **** 		: "r" (__data), "0" (__crc)
 144:/usr/lib/avr/include/util/crc16.h **** 		: "r0"
 145:/usr/lib/avr/include/util/crc16.h **** 	);
 146:/usr/lib/avr/include/util/crc16.h **** 	return __ret;
 147:/usr/lib/avr/include/util/crc16.h **** }
 148:/usr/lib/avr/include/util/crc16.h **** 
 149:/usr/lib/avr/include/util/crc16.h **** /** \ingroup util_crc
 150:/usr/lib/avr/include/util/crc16.h ****     Optimized CRC-XMODEM calculation.
 151:/usr/lib/avr/include/util/crc16.h **** 
 152:/usr/lib/avr/include/util/crc16.h ****     Polynomial: x^16 + x^12 + x^5 + 1 (0x1021)<br>
 153:/usr/lib/avr/include/util/crc16.h ****     Initial value: 0x0
 154:/usr/lib/avr/include/util/crc16.h **** 
 155:/usr/lib/avr/include/util/crc16.h ****     This is the CRC used by the Xmodem-CRC protocol.
 156:/usr/lib/avr/include/util/crc16.h **** 
 157:/usr/lib/avr/include/util/crc16.h ****     The following is the equivalent functionality written in C.
 158:/usr/lib/avr/include/util/crc16.h **** 
 159:/usr/lib/avr/include/util/crc16.h ****     \code
 160:/usr/lib/avr/include/util/crc16.h ****     uint16_t
 161:/usr/lib/avr/include/util/crc16.h ****     crc_xmodem_update (uint16_t crc, uint8_t data)
 162:/usr/lib/avr/include/util/crc16.h ****     {
 163:/usr/lib/avr/include/util/crc16.h ****         int i;
 164:/usr/lib/avr/include/util/crc16.h **** 
 165:/usr/lib/avr/include/util/crc16.h ****         crc = crc ^ ((uint16_t)data << 8);
 166:/usr/lib/avr/include/util/crc16.h ****         for (i=0; i<8; i++)
 167:/usr/lib/avr/include/util/crc16.h ****         {
 168:/usr/lib/avr/include/util/crc16.h ****             if (crc & 0x8000)
 169:/usr/lib/avr/include/util/crc16.h ****                 crc = (crc << 1) ^ 0x1021;
 170:/usr/lib/avr/include/util/crc16.h ****             else
 171:/usr/lib/avr/include/util/crc16.h ****                 crc <<= 1;
 172:/usr/lib/avr/include/util/crc16.h ****         }
 173:/usr/lib/avr/include/util/crc16.h **** 
 174:/usr/lib/avr/include/util/crc16.h ****         return crc;
 175:/usr/lib/avr/include/util/crc16.h ****     }
 176:/usr/lib/avr/include/util/crc16.h ****     \endcode */
 177:/usr/lib/avr/include/util/crc16.h **** 
 178:/usr/lib/avr/include/util/crc16.h **** static __inline__ uint16_t
 179:/usr/lib/avr/include/util/crc16.h **** _crc_xmodem_update(uint16_t __crc, uint8_t __data)
 180:/usr/lib/avr/include/util/crc16.h **** {
 181:/usr/lib/avr/include/util/crc16.h ****     uint16_t __ret;             /* %B0:%A0 (alias for __crc) */
 182:/usr/lib/avr/include/util/crc16.h ****     uint8_t __tmp1;             /* %1 */
 183:/usr/lib/avr/include/util/crc16.h ****     uint8_t __tmp2;             /* %2 */
 184:/usr/lib/avr/include/util/crc16.h ****                                 /* %3  __data */
 185:/usr/lib/avr/include/util/crc16.h **** 
 186:/usr/lib/avr/include/util/crc16.h ****     __asm__ __volatile__ (
 187:/usr/lib/avr/include/util/crc16.h ****         "eor    %B0,%3"          "\n\t" /* crc.hi ^ data */
 188:/usr/lib/avr/include/util/crc16.h ****         "mov    __tmp_reg__,%B0" "\n\t"
 189:/usr/lib/avr/include/util/crc16.h ****         "swap   __tmp_reg__"     "\n\t" /* swap(crc.hi ^ data) */
 190:/usr/lib/avr/include/util/crc16.h **** 
 191:/usr/lib/avr/include/util/crc16.h ****         /* Calculate the ret.lo of the CRC. */
 192:/usr/lib/avr/include/util/crc16.h ****         "mov    %1,__tmp_reg__"  "\n\t"
 193:/usr/lib/avr/include/util/crc16.h ****         "andi   %1,0x0f"         "\n\t"
 194:/usr/lib/avr/include/util/crc16.h ****         "eor    %1,%B0"          "\n\t"
 195:/usr/lib/avr/include/util/crc16.h ****         "mov    %2,%B0"          "\n\t"
 196:/usr/lib/avr/include/util/crc16.h ****         "eor    %2,__tmp_reg__"  "\n\t"
 197:/usr/lib/avr/include/util/crc16.h ****         "lsl    %2"              "\n\t"
 198:/usr/lib/avr/include/util/crc16.h ****         "andi   %2,0xe0"         "\n\t"
 199:/usr/lib/avr/include/util/crc16.h ****         "eor    %1,%2"           "\n\t" /* __tmp1 is now ret.lo. */
 200:/usr/lib/avr/include/util/crc16.h **** 
 201:/usr/lib/avr/include/util/crc16.h ****         /* Calculate the ret.hi of the CRC. */
 202:/usr/lib/avr/include/util/crc16.h ****         "mov    %2,__tmp_reg__"  "\n\t"
 203:/usr/lib/avr/include/util/crc16.h ****         "eor    %2,%B0"          "\n\t"
 204:/usr/lib/avr/include/util/crc16.h ****         "andi   %2,0xf0"         "\n\t"
 205:/usr/lib/avr/include/util/crc16.h ****         "lsr    %2"              "\n\t"
 206:/usr/lib/avr/include/util/crc16.h ****         "mov    __tmp_reg__,%B0" "\n\t"
 207:/usr/lib/avr/include/util/crc16.h ****         "lsl    __tmp_reg__"     "\n\t"
 208:/usr/lib/avr/include/util/crc16.h ****         "rol    %2"              "\n\t"
 209:/usr/lib/avr/include/util/crc16.h ****         "lsr    %B0"             "\n\t"
 210:/usr/lib/avr/include/util/crc16.h ****         "lsr    %B0"             "\n\t"
 211:/usr/lib/avr/include/util/crc16.h ****         "lsr    %B0"             "\n\t"
 212:/usr/lib/avr/include/util/crc16.h ****         "andi   %B0,0x1f"        "\n\t"
 213:/usr/lib/avr/include/util/crc16.h ****         "eor    %B0,%2"          "\n\t"
 214:/usr/lib/avr/include/util/crc16.h ****         "eor    %B0,%A0"         "\n\t" /* ret.hi is now ready. */
 215:/usr/lib/avr/include/util/crc16.h ****         "mov    %A0,%1"          "\n\t" /* ret.lo is now ready. */
 216:/usr/lib/avr/include/util/crc16.h ****         : "=d" (__ret), "=d" (__tmp1), "=d" (__tmp2)
 217:/usr/lib/avr/include/util/crc16.h ****         : "r" (__data), "0" (__crc)
 218:/usr/lib/avr/include/util/crc16.h ****         : "r0"
 219:/usr/lib/avr/include/util/crc16.h ****     );
 220:/usr/lib/avr/include/util/crc16.h ****     return __ret;
 221:/usr/lib/avr/include/util/crc16.h **** }
 222:/usr/lib/avr/include/util/crc16.h **** 
 223:/usr/lib/avr/include/util/crc16.h **** /** \ingroup util_crc
 224:/usr/lib/avr/include/util/crc16.h ****     Optimized CRC-CCITT calculation.
 225:/usr/lib/avr/include/util/crc16.h **** 
 226:/usr/lib/avr/include/util/crc16.h ****     Polynomial: x^16 + x^12 + x^5 + 1 (0x8408)<br>
 227:/usr/lib/avr/include/util/crc16.h ****     Initial value: 0xffff
 228:/usr/lib/avr/include/util/crc16.h **** 
 229:/usr/lib/avr/include/util/crc16.h ****     This is the CRC used by PPP and IrDA.
 230:/usr/lib/avr/include/util/crc16.h **** 
 231:/usr/lib/avr/include/util/crc16.h ****     See RFC1171 (PPP protocol) and IrDA IrLAP 1.1
 232:/usr/lib/avr/include/util/crc16.h **** 
 233:/usr/lib/avr/include/util/crc16.h ****     \note Although the CCITT polynomial is the same as that used by the Xmodem
 234:/usr/lib/avr/include/util/crc16.h ****     protocol, they are quite different. The difference is in how the bits are
 235:/usr/lib/avr/include/util/crc16.h ****     shifted through the alorgithm. Xmodem shifts the MSB of the CRC and the
 236:/usr/lib/avr/include/util/crc16.h ****     input first, while CCITT shifts the LSB of the CRC and the input first.
 237:/usr/lib/avr/include/util/crc16.h **** 
 238:/usr/lib/avr/include/util/crc16.h ****     The following is the equivalent functionality written in C.
 239:/usr/lib/avr/include/util/crc16.h **** 
 240:/usr/lib/avr/include/util/crc16.h ****     \code
 241:/usr/lib/avr/include/util/crc16.h ****     uint16_t
 242:/usr/lib/avr/include/util/crc16.h ****     crc_ccitt_update (uint16_t crc, uint8_t data)
 243:/usr/lib/avr/include/util/crc16.h ****     {
 244:/usr/lib/avr/include/util/crc16.h ****         data ^= lo8 (crc);
 245:/usr/lib/avr/include/util/crc16.h ****         data ^= data << 4;
 246:/usr/lib/avr/include/util/crc16.h **** 
 247:/usr/lib/avr/include/util/crc16.h ****         return ((((uint16_t)data << 8) | hi8 (crc)) ^ (uint8_t)(data >> 4) 
 248:/usr/lib/avr/include/util/crc16.h ****                 ^ ((uint16_t)data << 3));
 249:/usr/lib/avr/include/util/crc16.h ****     }
 250:/usr/lib/avr/include/util/crc16.h ****     \endcode */
 251:/usr/lib/avr/include/util/crc16.h **** 
 252:/usr/lib/avr/include/util/crc16.h **** static __inline__ uint16_t
 253:/usr/lib/avr/include/util/crc16.h **** _crc_ccitt_update (uint16_t __crc, uint8_t __data)
 254:/usr/lib/avr/include/util/crc16.h **** {
 255:/usr/lib/avr/include/util/crc16.h ****     uint16_t __ret;
 256:/usr/lib/avr/include/util/crc16.h **** 
 257:/usr/lib/avr/include/util/crc16.h ****     __asm__ __volatile__ (
 258:/usr/lib/avr/include/util/crc16.h ****         "eor    %A0,%1"          "\n\t"
 259:/usr/lib/avr/include/util/crc16.h **** 
 260:/usr/lib/avr/include/util/crc16.h ****         "mov    __tmp_reg__,%A0" "\n\t"
 261:/usr/lib/avr/include/util/crc16.h ****         "swap   %A0"             "\n\t"
 262:/usr/lib/avr/include/util/crc16.h ****         "andi   %A0,0xf0"        "\n\t"
 263:/usr/lib/avr/include/util/crc16.h ****         "eor    %A0,__tmp_reg__" "\n\t"
 264:/usr/lib/avr/include/util/crc16.h **** 
 265:/usr/lib/avr/include/util/crc16.h ****         "mov    __tmp_reg__,%B0" "\n\t"
 266:/usr/lib/avr/include/util/crc16.h **** 
 267:/usr/lib/avr/include/util/crc16.h ****         "mov    %B0,%A0"         "\n\t"
 268:/usr/lib/avr/include/util/crc16.h **** 
 269:/usr/lib/avr/include/util/crc16.h ****         "swap   %A0"             "\n\t"
 270:/usr/lib/avr/include/util/crc16.h ****         "andi   %A0,0x0f"        "\n\t"
 271:/usr/lib/avr/include/util/crc16.h ****         "eor    __tmp_reg__,%A0" "\n\t"
 272:/usr/lib/avr/include/util/crc16.h **** 
 273:/usr/lib/avr/include/util/crc16.h ****         "lsr    %A0"             "\n\t"
 274:/usr/lib/avr/include/util/crc16.h ****         "eor    %B0,%A0"         "\n\t"
 275:/usr/lib/avr/include/util/crc16.h **** 
 276:/usr/lib/avr/include/util/crc16.h ****         "eor    %A0,%B0"         "\n\t"
 277:/usr/lib/avr/include/util/crc16.h ****         "lsl    %A0"             "\n\t"
 278:/usr/lib/avr/include/util/crc16.h ****         "lsl    %A0"             "\n\t"
 279:/usr/lib/avr/include/util/crc16.h ****         "lsl    %A0"             "\n\t"
 280:/usr/lib/avr/include/util/crc16.h ****         "eor    %A0,__tmp_reg__"
 281:/usr/lib/avr/include/util/crc16.h **** 
 282:/usr/lib/avr/include/util/crc16.h ****         : "=d" (__ret)
 283:/usr/lib/avr/include/util/crc16.h ****         : "r" (__data), "0" (__crc)
 284:/usr/lib/avr/include/util/crc16.h ****         : "r0"
 285:/usr/lib/avr/include/util/crc16.h ****     );
 286:/usr/lib/avr/include/util/crc16.h ****     return __ret;
 287:/usr/lib/avr/include/util/crc16.h **** }
 288:/usr/lib/avr/include/util/crc16.h **** 
 289:/usr/lib/avr/include/util/crc16.h **** /** \ingroup util_crc
 290:/usr/lib/avr/include/util/crc16.h ****     Optimized Dallas (now Maxim) iButton 8-bit CRC calculation.
 291:/usr/lib/avr/include/util/crc16.h **** 
 292:/usr/lib/avr/include/util/crc16.h ****     Polynomial: x^8 + x^5 + x^4 + 1 (0x8C)<br>
 293:/usr/lib/avr/include/util/crc16.h ****     Initial value: 0x0
 294:/usr/lib/avr/include/util/crc16.h **** 
 295:/usr/lib/avr/include/util/crc16.h ****     See http://www.maxim-ic.com/appnotes.cfm/appnote_number/27
 296:/usr/lib/avr/include/util/crc16.h **** 
 297:/usr/lib/avr/include/util/crc16.h ****     The following is the equivalent functionality written in C.
 298:/usr/lib/avr/include/util/crc16.h **** 
 299:/usr/lib/avr/include/util/crc16.h ****     \code
 300:/usr/lib/avr/include/util/crc16.h ****     uint8_t
 301:/usr/lib/avr/include/util/crc16.h ****     _crc_ibutton_update(uint8_t crc, uint8_t data)
 302:/usr/lib/avr/include/util/crc16.h ****     {
 303:/usr/lib/avr/include/util/crc16.h **** 	uint8_t i;
 304:/usr/lib/avr/include/util/crc16.h **** 
 305:/usr/lib/avr/include/util/crc16.h **** 	crc = crc ^ data;
 306:/usr/lib/avr/include/util/crc16.h **** 	for (i = 0; i < 8; i++)
 307:/usr/lib/avr/include/util/crc16.h **** 	{
 308:/usr/lib/avr/include/util/crc16.h **** 	    if (crc & 0x01)
 309:/usr/lib/avr/include/util/crc16.h **** 	        crc = (crc >> 1) ^ 0x8C;
 310:/usr/lib/avr/include/util/crc16.h **** 	    else
 311:/usr/lib/avr/include/util/crc16.h **** 	        crc >>= 1;
 312:/usr/lib/avr/include/util/crc16.h **** 	}
 313:/usr/lib/avr/include/util/crc16.h **** 
 314:/usr/lib/avr/include/util/crc16.h **** 	return crc;
 315:/usr/lib/avr/include/util/crc16.h ****     }
 316:/usr/lib/avr/include/util/crc16.h ****     \endcode
 317:/usr/lib/avr/include/util/crc16.h **** */
 318:/usr/lib/avr/include/util/crc16.h **** 
 319:/usr/lib/avr/include/util/crc16.h **** static __inline__ uint8_t
 320:/usr/lib/avr/include/util/crc16.h **** _crc_ibutton_update(uint8_t __crc, uint8_t __data)
 321:/usr/lib/avr/include/util/crc16.h **** {
 322:/usr/lib/avr/include/util/crc16.h **** 	uint8_t __i, __pattern;
 323:/usr/lib/avr/include/util/crc16.h **** 	__asm__ __volatile__ (
 324:/usr/lib/avr/include/util/crc16.h **** 		"	eor	%0, %4" "\n\t"
 325:/usr/lib/avr/include/util/crc16.h **** 		"	ldi	%1, 8" "\n\t"
 326:/usr/lib/avr/include/util/crc16.h **** 		"	ldi	%2, 0x8C" "\n\t"
 327:/usr/lib/avr/include/util/crc16.h **** 		"1:	lsr	%0" "\n\t"
 328:/usr/lib/avr/include/util/crc16.h **** 		"	brcc	2f" "\n\t"
 329:/usr/lib/avr/include/util/crc16.h **** 		"	eor	%0, %2" "\n\t"
 330:/usr/lib/avr/include/util/crc16.h **** 		"2:	dec	%1" "\n\t"
 331:/usr/lib/avr/include/util/crc16.h **** 		"	brne	1b" "\n\t"
 332:/usr/lib/avr/include/util/crc16.h **** 		: "=r" (__crc), "=d" (__i), "=d" (__pattern)
 333:/usr/lib/avr/include/util/crc16.h **** 		: "0" (__crc), "r" (__data));
 334:/usr/lib/avr/include/util/crc16.h **** 	return __crc;
 335:/usr/lib/avr/include/util/crc16.h **** }
 336:/usr/lib/avr/include/util/crc16.h **** 
 337:/usr/lib/avr/include/util/crc16.h **** /** \ingroup util_crc
 338:/usr/lib/avr/include/util/crc16.h ****     Optimized CRC-8-CCITT calculation.
 339:/usr/lib/avr/include/util/crc16.h **** 
 340:/usr/lib/avr/include/util/crc16.h ****     Polynomial: x^8 + x^2 + x + 1 (0xE0)<br>
 341:/usr/lib/avr/include/util/crc16.h ****     
 342:/usr/lib/avr/include/util/crc16.h ****     For use with simple CRC-8<br>
 343:/usr/lib/avr/include/util/crc16.h ****     Initial value: 0x0
 344:/usr/lib/avr/include/util/crc16.h ****     
 345:/usr/lib/avr/include/util/crc16.h ****     For use with CRC-8-ROHC<br>
 346:/usr/lib/avr/include/util/crc16.h ****     Initial value: 0xff<br>
 347:/usr/lib/avr/include/util/crc16.h ****     Reference: http://tools.ietf.org/html/rfc3095#section-5.9.1
 348:/usr/lib/avr/include/util/crc16.h ****     
 349:/usr/lib/avr/include/util/crc16.h ****     For use with CRC-8-ATM/ITU<br>
 350:/usr/lib/avr/include/util/crc16.h ****     Initial value: 0xff<br>
 351:/usr/lib/avr/include/util/crc16.h ****     Final XOR value: 0x55<br>
 352:/usr/lib/avr/include/util/crc16.h ****     Reference: http://www.itu.int/rec/T-REC-I.432.1-199902-I/en
 353:/usr/lib/avr/include/util/crc16.h ****     
 354:/usr/lib/avr/include/util/crc16.h ****     The C equivalent has been originally written by Dave Hylands.
 355:/usr/lib/avr/include/util/crc16.h ****     Assembly code is based on _crc_ibutton_update optimization.
 356:/usr/lib/avr/include/util/crc16.h **** 
 357:/usr/lib/avr/include/util/crc16.h ****     The following is the equivalent functionality written in C.
 358:/usr/lib/avr/include/util/crc16.h **** 
 359:/usr/lib/avr/include/util/crc16.h ****     \code
 360:/usr/lib/avr/include/util/crc16.h ****     uint8_t
 361:/usr/lib/avr/include/util/crc16.h ****     _crc8_ccitt_update (uint8_t inCrc, uint8_t inData)
 362:/usr/lib/avr/include/util/crc16.h ****     {
 363:/usr/lib/avr/include/util/crc16.h ****         uint8_t   i;
 364:/usr/lib/avr/include/util/crc16.h ****         uint8_t   data;
 365:/usr/lib/avr/include/util/crc16.h **** 
 366:/usr/lib/avr/include/util/crc16.h ****         data = inCrc ^ inData;
 367:/usr/lib/avr/include/util/crc16.h **** 
 368:/usr/lib/avr/include/util/crc16.h ****         for ( i = 0; i < 8; i++ )
 369:/usr/lib/avr/include/util/crc16.h ****         {
 370:/usr/lib/avr/include/util/crc16.h ****             if (( data & 0x80 ) != 0 )
 371:/usr/lib/avr/include/util/crc16.h ****             {
 372:/usr/lib/avr/include/util/crc16.h ****                 data <<= 1;
 373:/usr/lib/avr/include/util/crc16.h ****                 data ^= 0x07;
 374:/usr/lib/avr/include/util/crc16.h ****             }
 375:/usr/lib/avr/include/util/crc16.h ****             else
 376:/usr/lib/avr/include/util/crc16.h ****             {
 377:/usr/lib/avr/include/util/crc16.h ****                 data <<= 1;
 378:/usr/lib/avr/include/util/crc16.h ****             }
 379:/usr/lib/avr/include/util/crc16.h ****         }
 380:/usr/lib/avr/include/util/crc16.h ****         return data;
 381:/usr/lib/avr/include/util/crc16.h ****     }
 382:/usr/lib/avr/include/util/crc16.h ****     \endcode
 383:/usr/lib/avr/include/util/crc16.h **** */
 384:/usr/lib/avr/include/util/crc16.h **** 
 385:/usr/lib/avr/include/util/crc16.h **** static __inline__ uint8_t
 386:/usr/lib/avr/include/util/crc16.h **** _crc8_ccitt_update(uint8_t __crc, uint8_t __data)
 387:/usr/lib/avr/include/util/crc16.h **** {
  14               		.loc 1 387 0
  15               		.cfi_startproc
  16               	.LVL0:
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
 388:/usr/lib/avr/include/util/crc16.h ****     uint8_t __i, __pattern;
 389:/usr/lib/avr/include/util/crc16.h ****     __asm__ __volatile__ (
  21               		.loc 1 389 0
  22               	/* #APP */
  23               	 ;  389 "/usr/lib/avr/include/util/crc16.h" 1
  24 0000 8627      		    eor    r24, r22
  25 0002 98E0      		    ldi    r25, 8
  26 0004 67E0      		    ldi    r22, 0x07
  27 0006 880F      		1:  lsl    r24
  28 0008 00F4      		    brcc   2f
  29 000a 8627      		    eor    r24, r22
  30 000c 9A95      		2:  dec    r25
  31 000e 01F4      		    brne   1b
  32               		
  33               	 ;  0 "" 2
  34               	.LVL1:
 390:/usr/lib/avr/include/util/crc16.h ****         "    eor    %0, %4" "\n\t"
 391:/usr/lib/avr/include/util/crc16.h ****         "    ldi    %1, 8" "\n\t"
 392:/usr/lib/avr/include/util/crc16.h ****         "    ldi    %2, 0x07" "\n\t"
 393:/usr/lib/avr/include/util/crc16.h ****         "1:  lsl    %0" "\n\t"
 394:/usr/lib/avr/include/util/crc16.h ****         "    brcc   2f" "\n\t"
 395:/usr/lib/avr/include/util/crc16.h ****         "    eor    %0, %2" "\n\t"
 396:/usr/lib/avr/include/util/crc16.h ****         "2:  dec    %1" "\n\t"
 397:/usr/lib/avr/include/util/crc16.h ****         "    brne   1b" "\n\t"
 398:/usr/lib/avr/include/util/crc16.h ****         : "=r" (__crc), "=d" (__i), "=d" (__pattern)
 399:/usr/lib/avr/include/util/crc16.h ****         : "0" (__crc), "r" (__data));
 400:/usr/lib/avr/include/util/crc16.h ****     return __crc;
 401:/usr/lib/avr/include/util/crc16.h **** }
  35               		.loc 1 401 0
  36               	/* #NOAPP */
  37 0010 0895      		ret
  38               		.cfi_endproc
  39               	.LFE4:
  41               	.global	ws2812_sendarray_mask
  43               	ws2812_sendarray_mask:
  44               	.LFB23:
  45               		.file 2 "light_ws2812.c"
   1:light_ws2812.c **** /*
   2:light_ws2812.c **** * light weight WS2812 lib V2.0b
   3:light_ws2812.c **** *
   4:light_ws2812.c **** * Controls WS2811/WS2812/WS2812B RGB-LEDs
   5:light_ws2812.c **** * Author: Tim (cpldcpu@gmail.com)
   6:light_ws2812.c **** *
   7:light_ws2812.c **** * Jan 18th, 2014  v2.0b Initial Version
   8:light_ws2812.c **** *
   9:light_ws2812.c **** *
  10:light_ws2812.c **** * Jun 2019, modified for SHPI by Lutz Harder
  11:light_ws2812.c **** * License: GNU GPL v2+ (see License.txt)
  12:light_ws2812.c **** */
  13:light_ws2812.c **** 
  14:light_ws2812.c **** #include "light_ws2812.h"
  15:light_ws2812.c **** #include <avr/interrupt.h>
  16:light_ws2812.c **** #include <avr/io.h>
  17:light_ws2812.c **** #include <util/delay.h>
  18:light_ws2812.c ****  
  19:light_ws2812.c **** // Setleds for standard RGB 
  20:light_ws2812.c **** void inline ws2812_setleds(struct cRGB *ledarray, uint16_t leds)
  21:light_ws2812.c **** {
  22:light_ws2812.c ****    ws2812_setleds_pin(ledarray,leds, _BV(ws2812_pin));
  23:light_ws2812.c **** }
  24:light_ws2812.c **** 
  25:light_ws2812.c **** void inline ws2812_setleds_pin(struct cRGB *ledarray, uint16_t leds, uint8_t pinmask)
  26:light_ws2812.c **** {
  27:light_ws2812.c ****   ws2812_sendarray_mask((uint8_t*)ledarray,leds+leds+leds,pinmask);
  28:light_ws2812.c ****   _delay_us(ws2812_resettime);
  29:light_ws2812.c **** }
  30:light_ws2812.c **** 
  31:light_ws2812.c **** 
  32:light_ws2812.c **** 
  33:light_ws2812.c **** void ws2812_sendarray(uint8_t *data,uint16_t datlen)
  34:light_ws2812.c **** {
  35:light_ws2812.c ****   ws2812_sendarray_mask(data,datlen,_BV(ws2812_pin));
  36:light_ws2812.c **** }
  37:light_ws2812.c **** 
  38:light_ws2812.c **** /*
  39:light_ws2812.c ****   This routine writes an array of bytes with RGB values to the Dataout pin
  40:light_ws2812.c ****   using the fast 800kHz clockless WS2811/2812 protocol.
  41:light_ws2812.c **** */
  42:light_ws2812.c **** 
  43:light_ws2812.c **** // Timing in ns
  44:light_ws2812.c **** #define w_zeropulse   350
  45:light_ws2812.c **** #define w_onepulse    900
  46:light_ws2812.c **** #define w_totalperiod 120
  47:light_ws2812.c **** 
  48:light_ws2812.c **** // Fixed cycles used by the inner loop
  49:light_ws2812.c **** #define w_fixedlow    2
  50:light_ws2812.c **** #define w_fixedhigh   4
  51:light_ws2812.c **** #define w_fixedtotal  8   
  52:light_ws2812.c **** 
  53:light_ws2812.c **** // Insert NOPs to match the timing, if possible
  54:light_ws2812.c **** #define w_zerocycles    (((F_CPU/1000)*w_zeropulse          )/1000000)
  55:light_ws2812.c **** #define w_onecycles     (((F_CPU/1000)*w_onepulse    +500000)/1000000)
  56:light_ws2812.c **** #define w_totalcycles   (((F_CPU/1000)*w_totalperiod +500000)/1000000)
  57:light_ws2812.c **** 
  58:light_ws2812.c **** // w1 - nops between rising edge and falling edge - low
  59:light_ws2812.c **** #define w1 (w_zerocycles-w_fixedlow)
  60:light_ws2812.c **** // w2   nops between fe low and fe high
  61:light_ws2812.c **** #define w2 (w_onecycles-w_fixedhigh-w1)
  62:light_ws2812.c **** // w3   nops to complete loop
  63:light_ws2812.c **** #define w3 (w_totalcycles-w_fixedtotal-w1-w2)
  64:light_ws2812.c **** 
  65:light_ws2812.c **** #if w1>0
  66:light_ws2812.c ****   #define w1_nops w1
  67:light_ws2812.c **** #else
  68:light_ws2812.c ****   #define w1_nops  0
  69:light_ws2812.c **** #endif
  70:light_ws2812.c **** 
  71:light_ws2812.c **** // The only critical timing parameter is the minimum pulse length of the "0"
  72:light_ws2812.c **** // Warn or throw error if this timing can not be met with current F_CPU settings.
  73:light_ws2812.c **** #define w_lowtime ((w1_nops+w_fixedlow)*1000000)/(F_CPU/1000)
  74:light_ws2812.c **** #if w_lowtime>550
  75:light_ws2812.c ****    #error "Light_ws2812: Sorry, the clock speed is too low. Did you set F_CPU correctly?"
  76:light_ws2812.c **** #elif w_lowtime>450
  77:light_ws2812.c ****    #warning "Light_ws2812: The timing is critical and may only work on WS2812B, not on WS2812(S)."
  78:light_ws2812.c ****    #warning "Please consider a higher clockspeed, if possible"
  79:light_ws2812.c **** #endif   
  80:light_ws2812.c **** 
  81:light_ws2812.c **** #if w2>0
  82:light_ws2812.c **** #define w2_nops w2
  83:light_ws2812.c **** #else
  84:light_ws2812.c **** #define w2_nops  0
  85:light_ws2812.c **** #endif
  86:light_ws2812.c **** 
  87:light_ws2812.c **** #if w3>0
  88:light_ws2812.c **** #define w3_nops w3
  89:light_ws2812.c **** #else
  90:light_ws2812.c **** #define w3_nops  0
  91:light_ws2812.c **** #endif
  92:light_ws2812.c **** 
  93:light_ws2812.c **** #define w_nop1  "nop      \n\t"
  94:light_ws2812.c **** #define w_nop2  "rjmp .+0 \n\t"
  95:light_ws2812.c **** #define w_nop4  w_nop2 w_nop2
  96:light_ws2812.c **** #define w_nop8  w_nop4 w_nop4
  97:light_ws2812.c **** #define w_nop16 w_nop8 w_nop8
  98:light_ws2812.c **** 
  99:light_ws2812.c **** void inline ws2812_sendarray_mask(uint8_t *data,uint16_t datlen,uint8_t maskhi)
 100:light_ws2812.c **** {
  46               		.loc 2 100 0
  47               		.cfi_startproc
  48               	.LVL2:
  49               	/* prologue: function */
  50               	/* frame size = 0 */
  51               	/* stack size = 0 */
  52               	.L__stack_usage = 0
 101:light_ws2812.c ****   uint8_t curbyte,ctr,masklo;
 102:light_ws2812.c ****   uint8_t sreg_prev;
 103:light_ws2812.c ****   
 104:light_ws2812.c ****   ws2812_DDRREG |= maskhi; // Enable output
  53               		.loc 2 104 0
  54 0012 2AB1      		in r18,0xa
  55 0014 242B      		or r18,r20
  56 0016 2AB9      		out 0xa,r18
 105:light_ws2812.c ****   
 106:light_ws2812.c ****   masklo	=~maskhi&ws2812_PORTREG;
  57               		.loc 2 106 0
  58 0018 2BB1      		in r18,0xb
  59 001a 342F      		mov r19,r20
  60 001c 3095      		com r19
  61 001e 2323      		and r18,r19
  62               	.LVL3:
 107:light_ws2812.c ****   maskhi |=        ws2812_PORTREG;
  63               		.loc 2 107 0
  64 0020 3BB1      		in r19,0xb
  65 0022 432B      		or r20,r19
  66               	.LVL4:
 108:light_ws2812.c ****   
 109:light_ws2812.c ****   sreg_prev=SREG;
  67               		.loc 2 109 0
  68 0024 3FB7      		in r19,__SREG__
  69               	.LVL5:
 110:light_ws2812.c ****   cli();  
  70               		.loc 2 110 0
  71               	/* #APP */
  72               	 ;  110 "light_ws2812.c" 1
  73 0026 F894      		cli
  74               	 ;  0 "" 2
  75               	/* #NOAPP */
  76 0028 FC01      		movw r30,r24
  77 002a 680F      		add r22,r24
  78 002c 791F      		adc r23,r25
  79               	.LVL6:
  80               	.L3:
 111:light_ws2812.c **** 
 112:light_ws2812.c ****   while (datlen--) {
  81               		.loc 2 112 0
  82 002e E617      		cp r30,r22
  83 0030 F707      		cpc r31,r23
  84 0032 01F0      		breq .L6
  85               	.LVL7:
 113:light_ws2812.c ****     curbyte=*data++;
  86               		.loc 2 113 0
  87 0034 8191      		ld r24,Z+
  88               	.LVL8:
 114:light_ws2812.c ****     
 115:light_ws2812.c ****     asm volatile(
  89               		.loc 2 115 0
  90               	/* #APP */
  91               	 ;  115 "light_ws2812.c" 1
  92 0036 98E0      		       ldi   r25,8  
  93               		loop59:            
  94 0038 4BB9      		       out   11,r20 
  95 003a 0000      		nop      
  96 003c 00C0      		rjmp .+0 
  97 003e 87FF      		       sbrs  r24,7  
  98 0040 2BB9      		       out   11,r18 
  99 0042 880F      		       lsl   r24    
 100 0044 0000      		nop      
 101 0046 00C0      		rjmp .+0 
 102 0048 00C0      		rjmp .+0 
 103 004a 00C0      		rjmp .+0 
 104 004c 2BB9      		       out   11,r18 
 105 004e 00C0      		rjmp .+0 
 106 0050 00C0      		rjmp .+0 
 107 0052 00C0      		rjmp .+0 
 108 0054 00C0      		rjmp .+0 
 109 0056 00C0      		rjmp .+0 
 110 0058 00C0      		rjmp .+0 
 111 005a 00C0      		rjmp .+0 
 112 005c 00C0      		rjmp .+0 
 113 005e 9A95      		       dec   r25    
 114 0060 01F4      		       brne  loop59
 115               		
 116               	 ;  0 "" 2
 117               	.LVL9:
 118               	/* #NOAPP */
 119 0062 00C0      		rjmp .L3
 120               	.LVL10:
 121               	.L6:
 116:light_ws2812.c ****     "       ldi   %0,8  \n\t"
 117:light_ws2812.c ****     "loop%=:            \n\t"
 118:light_ws2812.c ****     "       out   %2,%3 \n\t"    
 119:light_ws2812.c **** #if (w1_nops&1)
 120:light_ws2812.c **** w_nop1
 121:light_ws2812.c **** #endif
 122:light_ws2812.c **** #if (w1_nops&2)
 123:light_ws2812.c **** w_nop2
 124:light_ws2812.c **** #endif
 125:light_ws2812.c **** #if (w1_nops&4)
 126:light_ws2812.c **** w_nop4
 127:light_ws2812.c **** #endif
 128:light_ws2812.c **** #if (w1_nops&8)
 129:light_ws2812.c **** w_nop8
 130:light_ws2812.c **** #endif
 131:light_ws2812.c **** #if (w1_nops&16)
 132:light_ws2812.c **** w_nop16
 133:light_ws2812.c **** #endif
 134:light_ws2812.c ****     "       sbrs  %1,7  \n\t"   
 135:light_ws2812.c ****     "       out   %2,%4 \n\t"  
 136:light_ws2812.c ****     "       lsl   %1    \n\t"   
 137:light_ws2812.c **** #if (w2_nops&1)
 138:light_ws2812.c ****   w_nop1
 139:light_ws2812.c **** #endif
 140:light_ws2812.c **** #if (w2_nops&2)
 141:light_ws2812.c ****   w_nop2
 142:light_ws2812.c **** #endif
 143:light_ws2812.c **** #if (w2_nops&4)
 144:light_ws2812.c ****   w_nop4
 145:light_ws2812.c **** #endif
 146:light_ws2812.c **** #if (w2_nops&8)
 147:light_ws2812.c ****   w_nop8
 148:light_ws2812.c **** #endif
 149:light_ws2812.c **** #if (w2_nops&16)
 150:light_ws2812.c ****   w_nop16 
 151:light_ws2812.c **** #endif
 152:light_ws2812.c ****     "       out   %2,%4 \n\t"   
 153:light_ws2812.c **** #if (w3_nops&1)
 154:light_ws2812.c **** w_nop1
 155:light_ws2812.c **** #endif
 156:light_ws2812.c **** #if (w3_nops&2)
 157:light_ws2812.c **** w_nop2
 158:light_ws2812.c **** #endif
 159:light_ws2812.c **** #if (w3_nops&4)
 160:light_ws2812.c **** w_nop4
 161:light_ws2812.c **** #endif
 162:light_ws2812.c **** #if (w3_nops&8)
 163:light_ws2812.c **** w_nop8
 164:light_ws2812.c **** #endif
 165:light_ws2812.c **** #if (w3_nops&16)
 166:light_ws2812.c **** w_nop16
 167:light_ws2812.c **** #endif
 168:light_ws2812.c **** 
 169:light_ws2812.c ****     "       dec   %0    \n\t"   
 170:light_ws2812.c ****     "       brne  loop%=\n\t"   
 171:light_ws2812.c ****     :	"=&d" (ctr)
 172:light_ws2812.c ****     :	"r" (curbyte), "I" (_SFR_IO_ADDR(ws2812_PORTREG)), "r" (maskhi), "r" (masklo)
 173:light_ws2812.c ****     );
 174:light_ws2812.c ****   }
 175:light_ws2812.c ****   
 176:light_ws2812.c ****   SREG=sreg_prev;
 122               		.loc 2 176 0
 123 0064 3FBF      		out __SREG__,r19
 124 0066 0895      		ret
 125               		.cfi_endproc
 126               	.LFE23:
 128               	.global	ws2812_setleds_pin
 130               	ws2812_setleds_pin:
 131               	.LFB21:
  26:light_ws2812.c ****   ws2812_sendarray_mask((uint8_t*)ledarray,leds+leds+leds,pinmask);
 132               		.loc 2 26 0
 133               		.cfi_startproc
 134               	.LVL11:
 135               	/* prologue: function */
 136               	/* frame size = 0 */
 137               	/* stack size = 0 */
 138               	.L__stack_usage = 0
  27:light_ws2812.c ****   _delay_us(ws2812_resettime);
 139               		.loc 2 27 0
 140 0068 9B01      		movw r18,r22
 141 006a 220F      		lsl r18
 142 006c 331F      		rol r19
 143 006e 620F      		add r22,r18
 144 0070 731F      		adc r23,r19
 145               	.LVL12:
 146 0072 0E94 0000 		call ws2812_sendarray_mask
 147               	.LVL13:
 148               	.LBB57:
 149               	.LBB58:
 150               		.file 3 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id$ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/lib/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/lib/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/lib/avr/include/util/delay.h **** #  endif
  42:/usr/lib/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/lib/avr/include/util/delay.h **** 
  44:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  47:/usr/lib/avr/include/util/delay.h **** 
  48:/usr/lib/avr/include/util/delay.h **** /** \file */
  49:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/lib/avr/include/util/delay.h ****     \code
  51:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/lib/avr/include/util/delay.h ****     \endcode
  55:/usr/lib/avr/include/util/delay.h **** 
  56:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/lib/avr/include/util/delay.h ****     used.
  60:/usr/lib/avr/include/util/delay.h **** 
  61:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/lib/avr/include/util/delay.h **** 
  70:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/lib/avr/include/util/delay.h **** 
  79:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** */
  84:/usr/lib/avr/include/util/delay.h **** 
  85:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/lib/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/lib/avr/include/util/delay.h **** #endif
  89:/usr/lib/avr/include/util/delay.h **** 
  90:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/lib/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/lib/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/lib/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/lib/avr/include/util/delay.h **** 
  97:/usr/lib/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/lib/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/lib/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/lib/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/lib/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/lib/avr/include/util/delay.h **** 
 103:/usr/lib/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/lib/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/lib/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/lib/avr/include/util/delay.h ****     integer value.
 107:/usr/lib/avr/include/util/delay.h ****  */
 108:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/lib/avr/include/util/delay.h **** #endif
 110:/usr/lib/avr/include/util/delay.h **** 
 111:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/lib/avr/include/util/delay.h **** #endif
 114:/usr/lib/avr/include/util/delay.h **** 
 115:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/lib/avr/include/util/delay.h **** #endif
 120:/usr/lib/avr/include/util/delay.h **** 
 121:/usr/lib/avr/include/util/delay.h **** /**
 122:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/lib/avr/include/util/delay.h **** 
 124:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/lib/avr/include/util/delay.h **** 
 126:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/lib/avr/include/util/delay.h **** 
 131:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/lib/avr/include/util/delay.h **** 
 137:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/lib/avr/include/util/delay.h **** 
 142:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/lib/avr/include/util/delay.h **** 
 147:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/lib/avr/include/util/delay.h ****    respectively.
 151:/usr/lib/avr/include/util/delay.h **** 
 152:/usr/lib/avr/include/util/delay.h ****    \note
 153:/usr/lib/avr/include/util/delay.h **** 
 154:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h ****  */
 165:/usr/lib/avr/include/util/delay.h **** void
 166:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/lib/avr/include/util/delay.h **** {
 168:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/lib/avr/include/util/delay.h **** 
 176:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/lib/avr/include/util/delay.h **** 
 179:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/lib/avr/include/util/delay.h **** 
 182:/usr/lib/avr/include/util/delay.h **** 	#else
 183:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 184:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/lib/avr/include/util/delay.h **** 	#endif
 186:/usr/lib/avr/include/util/delay.h **** 
 187:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:/usr/lib/avr/include/util/delay.h **** 
 189:/usr/lib/avr/include/util/delay.h **** #else
 190:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 191:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:/usr/lib/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 193:/usr/lib/avr/include/util/delay.h **** 		__ticks = 1;
 194:/usr/lib/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 195:/usr/lib/avr/include/util/delay.h **** 	{
 196:/usr/lib/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:/usr/lib/avr/include/util/delay.h **** 		while(__ticks)
 199:/usr/lib/avr/include/util/delay.h **** 		{
 200:/usr/lib/avr/include/util/delay.h **** 			// wait 1/10 ms
 201:/usr/lib/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:/usr/lib/avr/include/util/delay.h **** 			__ticks --;
 203:/usr/lib/avr/include/util/delay.h **** 		}
 204:/usr/lib/avr/include/util/delay.h **** 		return;
 205:/usr/lib/avr/include/util/delay.h **** 	}
 206:/usr/lib/avr/include/util/delay.h **** 	else
 207:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 208:/usr/lib/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 209:/usr/lib/avr/include/util/delay.h **** #endif
 210:/usr/lib/avr/include/util/delay.h **** }
 211:/usr/lib/avr/include/util/delay.h **** 
 212:/usr/lib/avr/include/util/delay.h **** /**
 213:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 214:/usr/lib/avr/include/util/delay.h **** 
 215:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:/usr/lib/avr/include/util/delay.h **** 
 217:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 218:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:/usr/lib/avr/include/util/delay.h **** 
 220:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:/usr/lib/avr/include/util/delay.h **** 
 222:/usr/lib/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:/usr/lib/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:/usr/lib/avr/include/util/delay.h ****    will not be informed about this case.
 225:/usr/lib/avr/include/util/delay.h **** 
 226:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 229:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0us.
 230:/usr/lib/avr/include/util/delay.h **** 
 231:/usr/lib/avr/include/util/delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:/usr/lib/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:/usr/lib/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __us
 234:/usr/lib/avr/include/util/delay.h ****    microseconds of delay.
 235:/usr/lib/avr/include/util/delay.h **** 
 236:/usr/lib/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:/usr/lib/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:/usr/lib/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:/usr/lib/avr/include/util/delay.h ****    respectively.
 240:/usr/lib/avr/include/util/delay.h **** 
 241:/usr/lib/avr/include/util/delay.h ****    \note
 242:/usr/lib/avr/include/util/delay.h **** 
 243:/usr/lib/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 244:/usr/lib/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:/usr/lib/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 246:/usr/lib/avr/include/util/delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:/usr/lib/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 248:/usr/lib/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 249:/usr/lib/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:/usr/lib/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:/usr/lib/avr/include/util/delay.h ****    not available to the compiler then.
 252:/usr/lib/avr/include/util/delay.h **** 
 253:/usr/lib/avr/include/util/delay.h ****  */
 254:/usr/lib/avr/include/util/delay.h **** void
 255:/usr/lib/avr/include/util/delay.h **** _delay_us(double __us)
 256:/usr/lib/avr/include/util/delay.h **** {
 257:/usr/lib/avr/include/util/delay.h **** 	double __tmp ;
 258:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 261:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 262:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:/usr/lib/avr/include/util/delay.h **** 
 265:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:/usr/lib/avr/include/util/delay.h **** 
 268:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:/usr/lib/avr/include/util/delay.h **** 
 271:/usr/lib/avr/include/util/delay.h **** 	#else
 272:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 273:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:/usr/lib/avr/include/util/delay.h **** 	#endif
 275:/usr/lib/avr/include/util/delay.h **** 
 276:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 151               		.loc 3 276 0
 152 0076 8FEA      		ldi r24,lo8(1199)
 153 0078 94E0      		ldi r25,hi8(1199)
 154 007a 0197      	1:	sbiw r24,1
 155 007c 01F4      		brne 1b
 156 007e 00C0      		rjmp .
 157 0080 0000      		nop
 158               	.LVL14:
 159 0082 0895      		ret
 160               	.LBE58:
 161               	.LBE57:
 162               		.cfi_endproc
 163               	.LFE21:
 165               	.global	ws2812_setleds
 167               	ws2812_setleds:
 168               	.LFB20:
  21:light_ws2812.c ****    ws2812_setleds_pin(ledarray,leds, _BV(ws2812_pin));
 169               		.loc 2 21 0
 170               		.cfi_startproc
 171               	.LVL15:
 172               	/* prologue: function */
 173               	/* frame size = 0 */
 174               	/* stack size = 0 */
 175               	.L__stack_usage = 0
  22:light_ws2812.c **** }
 176               		.loc 2 22 0
 177 0084 40E2      		ldi r20,lo8(32)
 178 0086 0C94 0000 		jmp ws2812_setleds_pin
 179               	.LVL16:
 180               		.cfi_endproc
 181               	.LFE20:
 183               	.global	ws2812_sendarray
 185               	ws2812_sendarray:
 186               	.LFB22:
  34:light_ws2812.c ****   ws2812_sendarray_mask(data,datlen,_BV(ws2812_pin));
 187               		.loc 2 34 0
 188               		.cfi_startproc
 189               	.LVL17:
 190               	/* prologue: function */
 191               	/* frame size = 0 */
 192               	/* stack size = 0 */
 193               	.L__stack_usage = 0
  35:light_ws2812.c **** }
 194               		.loc 2 35 0
 195 008a 40E2      		ldi r20,lo8(32)
 196 008c 0C94 0000 		jmp ws2812_sendarray_mask
 197               	.LVL18:
 198               		.cfi_endproc
 199               	.LFE22:
 201               	.global	write_backlight
 203               	write_backlight:
 204               	.LFB24:
 205               		.file 4 "main.c"
   1:main.c        **** /*
   2:main.c        ****  *  SHPI.zero Basic Firmware v2 BETA
   3:main.c        ****  *
   4:main.c        ****  *
   5:main.c        ****  *
   6:main.c        ****  * Basic Firmware for ATmega32u4 slave,  no radio module support included
   7:main.c        ****  *
   8:main.c        ****  * Jul    15th, 2019  v 1.1b initial Version
   9:main.c        ****  * October 4th, 2019  v1.2  Beta
  10:main.c        ****  *    NEW: implemented CRC Check via CRC8  CCITT
  11:main.c        **** 
  12:main.c        ****  * Aug 28th, 2020 v2.0
  13:main.c        ****  *
  14:main.c        ****  *
  15:main.c        ****  *
  16:main.c        ****  *
  17:main.c        ****  * Author: Lutz Harder
  18:main.c        ****  * License: GNU GPL
  19:main.c        ****  */
  20:main.c        **** 
  21:main.c        **** #define FW_VERSION  0x01
  22:main.c        **** #define I2C_ADDR 0x2A
  23:main.c        **** #define LCD_WRITE_DELAY 0.5
  24:main.c        **** #define LCD_WAIT 100
  25:main.c        **** #define ws2812_resettime  300
  26:main.c        **** #define ws2812_port D
  27:main.c        **** #define ws2812_pin  5
  28:main.c        **** 
  29:main.c        **** #define SDA_LINE  (PIND & (1<<PD1))
  30:main.c        **** #define SCL_LINE  (PIND & (1<<PD0))
  31:main.c        **** 
  32:main.c        **** #include <util/crc16.h>
  33:main.c        **** #include <avr/wdt.h>
  34:main.c        **** #include <avr/power.h>
  35:main.c        **** #include <avr/io.h>
  36:main.c        **** #include <stdlib.h>
  37:main.c        **** #include <util/delay.h>
  38:main.c        **** #include <avr/interrupt.h>
  39:main.c        **** #include <stdint.h>
  40:main.c        **** #include <util/twi.h>
  41:main.c        **** #include "light_ws2812.c"
  42:main.c        **** #include "light_ws2812.h"
  43:main.c        **** 
  44:main.c        **** struct cRGB led[1];
  45:main.c        **** uint8_t displaychange = 0, jumptobootloader = 0, watchdog = 0x00, display = 0xFF, led_position = 0,
  46:main.c        **** uint16_t freeram,a0,a1,a2,a3,a4,a5,a7,a7avg,a7max,a7min,vcc,temp,rpm,fanspin,isrtimer,i2cbuffer = 0
  47:main.c        **** 
  48:main.c        **** uint16_t commands[] =			 // only for  A035VW01
  49:main.c        **** {
  50:main.c        **** 	0x0080, 0x01F8,  0x0246, 0x0305, 0x0440,  0x0540, 0x0640,0x0740, 0x0840,  0x0940, 0x0A03
  51:main.c        **** };
  52:main.c        **** uint16_t commands2[]=			 // initcode for LCD A035VL01
  53:main.c        **** {
  54:main.c        **** 	0x0011,0x0000,0x0001,0x0000,0x00C1,0x01A8,0x01B1,0x0145,0x0104,0x0C5,0x0180,0x016C,0x0C6,
  55:main.c        **** 	0x01BD,0x0184,0x00C7,0x01BD,0x0184,0x00BD,0x0102,0x0011,0x0000,0x00F2,0x0100,0x0100,0x0182,
  56:main.c        **** 	0x0026,0x0108,0x00E0,0x0100,0x0104,0x0108,0x010B,0x010C,0x0111,0x010D,0x010E,0x0100,0x0104,
  57:main.c        **** 	0x0108,0x0113,0x0114,0x012F,0x0129,0x0124,0x00E1,0x0100,0x0104,0x0108,0x010B,0x010C,0x0111,
  58:main.c        **** 	0x010D,0x010E,0x0100,0x0104,0x0108,0x0113,0x0114,0x012F,0x0129,0x0124,0x0026,0x0108,0x00FD,
  59:main.c        **** 	0x0100,0x0108,0x0029
  60:main.c        **** };
  61:main.c        **** 
  62:main.c        **** 								 // set single wire brightness  AL3050
  63:main.c        **** void write_backlight(uint8_t data)
  64:main.c        **** {
 206               		.loc 4 64 0
 207               		.cfi_startproc
 208               	.LVL19:
 209               	/* prologue: function */
 210               	/* frame size = 0 */
 211               	/* stack size = 0 */
 212               	.L__stack_usage = 0
 213               		.loc 4 64 0
 214 0090 27E0      		ldi r18,lo8(7)
 215 0092 30E0      		ldi r19,0
  65:main.c        **** 	uint8_t count = 8;
  66:main.c        **** 	do
  67:main.c        **** 	{
  68:main.c        **** 		PORTD &= ~_BV(PD4);
  69:main.c        **** 		_delay_us(50);
  70:main.c        **** 		if (!(data & (1 << (count - 1))))
 216               		.loc 4 70 0
 217 0094 90E0      		ldi r25,0
 218               	.LVL20:
 219               	.L13:
  68:main.c        **** 		_delay_us(50);
 220               		.loc 4 68 0
 221 0096 5C98      		cbi 0xb,4
 222               	.LVL21:
 223               	.LBB59:
 224               	.LBB60:
 225               		.loc 3 276 0
 226 0098 E7EC      		ldi r30,lo8(199)
 227 009a F0E0      		ldi r31,hi8(199)
 228 009c 3197      	1:	sbiw r30,1
 229 009e 01F4      		brne 1b
 230 00a0 00C0      		rjmp .
 231 00a2 0000      		nop
 232               	.LVL22:
 233               	.LBE60:
 234               	.LBE59:
 235               		.loc 4 70 0
 236 00a4 AC01      		movw r20,r24
 237 00a6 022E      		mov r0,r18
 238 00a8 00C0      		rjmp 2f
 239               		1:
 240 00aa 5595      		asr r21
 241 00ac 4795      		ror r20
 242               		2:
 243 00ae 0A94      		dec r0
 244 00b0 02F4      		brpl 1b
 245 00b2 BA01      		movw r22,r20
 246 00b4 6170      		andi r22,1
 247 00b6 7727      		clr r23
 248 00b8 40FD      		sbrc r20,0
 249 00ba 00C0      		rjmp .L11
 250               	.LVL23:
 251               	.LBB61:
 252               	.LBB62:
 253               		.loc 3 276 0
 254 00bc E7EC      		ldi r30,lo8(199)
 255 00be F0E0      		ldi r31,hi8(199)
 256 00c0 3197      	1:	sbiw r30,1
 257 00c2 01F4      		brne 1b
 258 00c4 00C0      		rjmp .
 259 00c6 0000      		nop
 260               	.LVL24:
 261               	.L11:
 262               	.LBE62:
 263               	.LBE61:
  71:main.c        **** 		{
  72:main.c        **** 			_delay_us(50);
  73:main.c        **** 		}
  74:main.c        **** 		PORTD |= _BV(PD4);
 264               		.loc 4 74 0
 265 00c8 5C9A      		sbi 0xb,4
 266               	.LVL25:
 267               	.LBB63:
 268               	.LBB64:
 269               		.loc 3 276 0
 270 00ca E7EC      		ldi r30,lo8(199)
 271 00cc F0E0      		ldi r31,hi8(199)
 272 00ce 3197      	1:	sbiw r30,1
 273 00d0 01F4      		brne 1b
 274 00d2 00C0      		rjmp .
 275 00d4 0000      		nop
 276               	.LVL26:
 277               	.LBE64:
 278               	.LBE63:
  75:main.c        **** 		_delay_us(50);
  76:main.c        **** 		if ((data & (1 << (count - 1))) != 0)
 279               		.loc 4 76 0
 280 00d6 672B      		or r22,r23
 281 00d8 01F0      		breq .L12
 282               	.LVL27:
 283               	.LBB65:
 284               	.LBB66:
 285               		.loc 3 276 0
 286 00da E7EC      		ldi r30,lo8(199)
 287 00dc F0E0      		ldi r31,hi8(199)
 288 00de 3197      	1:	sbiw r30,1
 289 00e0 01F4      		brne 1b
 290 00e2 00C0      		rjmp .
 291 00e4 0000      		nop
 292               	.LVL28:
 293               	.L12:
 294               	.LVL29:
 295               	.LBE66:
 296               	.LBE65:
 297 00e6 2150      		subi r18,1
 298 00e8 3109      		sbc r19,__zero_reg__
 299 00ea 00F4      		brcc .L13
  77:main.c        **** 		{
  78:main.c        **** 			_delay_us(50);
  79:main.c        **** 		}
  80:main.c        **** 		count--;
  81:main.c        **** 	} while (count);
  82:main.c        **** 
  83:main.c        **** 	PORTD &= ~_BV(PD4);
 300               		.loc 4 83 0
 301 00ec 5C98      		cbi 0xb,4
 302               	.LVL30:
 303               	.LBB67:
 304               	.LBB68:
 305               		.loc 3 276 0
 306 00ee 87EC      		ldi r24,lo8(199)
 307 00f0 90E0      		ldi r25,hi8(199)
 308 00f2 0197      	1:	sbiw r24,1
 309 00f4 01F4      		brne 1b
 310               	.LVL31:
 311 00f6 00C0      		rjmp .
 312 00f8 0000      		nop
 313               	.LVL32:
 314               	.LBE68:
 315               	.LBE67:
  84:main.c        **** 	_delay_us(50);
  85:main.c        **** 	PORTD |= _BV(PD4);
 316               		.loc 4 85 0
 317 00fa 5C9A      		sbi 0xb,4
 318               	.LVL33:
 319               	.LBB69:
 320               	.LBB70:
 321               		.loc 3 276 0
 322 00fc E7EC      		ldi r30,lo8(199)
 323 00fe F0E0      		ldi r31,hi8(199)
 324 0100 3197      	1:	sbiw r30,1
 325 0102 01F4      		brne 1b
 326 0104 00C0      		rjmp .
 327 0106 0000      		nop
 328               	.LVL34:
 329 0108 0895      		ret
 330               	.LBE70:
 331               	.LBE69:
 332               		.cfi_endproc
 333               	.LFE24:
 335               	.global	init_backlight
 337               	init_backlight:
 338               	.LFB25:
  86:main.c        **** 	_delay_us(50);
  87:main.c        **** }
  88:main.c        **** 
  89:main.c        **** 
  90:main.c        **** void init_backlight(void)		 // init AL3050 single wire dimming
  91:main.c        **** {
 339               		.loc 4 91 0
 340               		.cfi_startproc
 341               	/* prologue: function */
 342               	/* frame size = 0 */
 343               	/* stack size = 0 */
 344               	.L__stack_usage = 0
  92:main.c        **** 	PORTD &= ~_BV(PD4);
 345               		.loc 4 92 0
 346 010a 5C98      		cbi 0xb,4
 347               	.LVL35:
 348               	.LBB71:
 349               	.LBB72:
 350               		.loc 3 276 0
 351 010c 8FED      		ldi r24,lo8(11999)
 352 010e 9EE2      		ldi r25,hi8(11999)
 353 0110 0197      	1:	sbiw r24,1
 354 0112 01F4      		brne 1b
 355 0114 00C0      		rjmp .
 356 0116 0000      		nop
 357               	.LVL36:
 358               	.LBE72:
 359               	.LBE71:
  93:main.c        **** 	_delay_us(3000);
  94:main.c        **** 	PORTD |= _BV(PD4);
 360               		.loc 4 94 0
 361 0118 5C9A      		sbi 0xb,4
 362               	.LVL37:
 363               	.LBB73:
 364               	.LBB74:
 365               		.loc 3 276 0
 366 011a 8FED      		ldi r24,lo8(479)
 367 011c 91E0      		ldi r25,hi8(479)
 368 011e 0197      	1:	sbiw r24,1
 369 0120 01F4      		brne 1b
 370 0122 00C0      		rjmp .
 371 0124 0000      		nop
 372               	.LVL38:
 373               	.LBE74:
 374               	.LBE73:
  95:main.c        **** 	_delay_us(120);
  96:main.c        **** 	PORTD &= ~_BV(PD4);
 375               		.loc 4 96 0
 376 0126 5C98      		cbi 0xb,4
 377               	.LVL39:
 378               	.LBB75:
 379               	.LBB76:
 380               		.loc 3 276 0
 381 0128 8FEC      		ldi r24,lo8(1999)
 382 012a 97E0      		ldi r25,hi8(1999)
 383 012c 0197      	1:	sbiw r24,1
 384 012e 01F4      		brne 1b
 385 0130 00C0      		rjmp .
 386 0132 0000      		nop
 387               	.LVL40:
 388               	.LBE76:
 389               	.LBE75:
  97:main.c        **** 	_delay_us(500);
  98:main.c        **** 	PORTD |= _BV(PD4);
 390               		.loc 4 98 0
 391 0134 5C9A      		sbi 0xb,4
 392               	.LVL41:
 393               	.LBB77:
 394               	.LBB78:
 395               		.loc 3 276 0
 396 0136 9AE1      		ldi r25,lo8(26)
 397 0138 9A95      	1:	dec r25
 398 013a 01F4      		brne 1b
 399 013c 00C0      		rjmp .
 400               	.LVL42:
 401               	.LBE78:
 402               	.LBE77:
  99:main.c        **** 	_delay_us(5);
 100:main.c        **** 	bllevel = 31;
 403               		.loc 4 100 0
 404 013e 8FE1      		ldi r24,lo8(31)
 405 0140 8093 0000 		sts bllevel,r24
 101:main.c        **** 	newbllevel = 31;
 406               		.loc 4 101 0
 407 0144 8093 0000 		sts newbllevel,r24
 408 0148 0895      		ret
 409               		.cfi_endproc
 410               	.LFE25:
 412               	.global	write_lcd
 414               	write_lcd:
 415               	.LFB26:
 102:main.c        **** }
 103:main.c        **** 
 104:main.c        **** 
 105:main.c        **** //  write routine for LCD setup
 106:main.c        **** void write_lcd(uint16_t data, uint8_t count)
 107:main.c        **** {
 416               		.loc 4 107 0
 417               		.cfi_startproc
 418               	.LVL43:
 419               	/* prologue: function */
 420               	/* frame size = 0 */
 421               	/* stack size = 0 */
 422               	.L__stack_usage = 0
 423 014a AC01      		movw r20,r24
 108:main.c        **** 	PORTD &= ~_BV(PD4);
 424               		.loc 4 108 0
 425 014c 5C98      		cbi 0xb,4
 109:main.c        **** 
 110:main.c        **** 	do
 111:main.c        **** 	{
 112:main.c        **** 		PORTB &= ~_BV(PB2);		 // BITWISE AND -> PB2
 113:main.c        **** 		PORTB |= (((data & (1 << (count - 1))) != 0) << 2);
 426               		.loc 4 113 0
 427 014e E1E0      		ldi r30,lo8(1)
 428 0150 F0E0      		ldi r31,0
 429               	.LVL44:
 430               	.L21:
 112:main.c        **** 		PORTB |= (((data & (1 << (count - 1))) != 0) << 2);
 431               		.loc 4 112 0
 432 0152 2A98      		cbi 0x5,2
 433               		.loc 4 113 0
 434 0154 95B1      		in r25,0x5
 435 0156 8FEF      		ldi r24,lo8(-1)
 436 0158 860F      		add r24,r22
 437 015a 9F01      		movw r18,r30
 438 015c 00C0      		rjmp 2f
 439               		1:
 440 015e 220F      		lsl r18
 441 0160 331F      		rol r19
 442               		2:
 443 0162 8A95      		dec r24
 444 0164 02F4      		brpl 1b
 445 0166 2423      		and r18,r20
 446 0168 3523      		and r19,r21
 447 016a 232B      		or r18,r19
 448 016c 01F4      		brne .L22
 449 016e 20E0      		ldi r18,0
 450 0170 00C0      		rjmp .L20
 451               	.L22:
 452 0172 24E0      		ldi r18,lo8(4)
 453               	.L20:
 454               		.loc 4 113 0 is_stmt 0 discriminator 4
 455 0174 922B      		or r25,r18
 456 0176 95B9      		out 0x5,r25
 114:main.c        **** 		PORTB &= ~_BV(PB1);
 457               		.loc 4 114 0 is_stmt 1 discriminator 4
 458 0178 2998      		cbi 0x5,1
 459               	.LVL45:
 460               	.LBB79:
 461               	.LBB80:
 462               		.loc 3 276 0 discriminator 4
 463 017a 82E0      		ldi r24,lo8(2)
 464 017c 8A95      	1:	dec r24
 465 017e 01F4      		brne 1b
 466 0180 00C0      		rjmp .
 467               	.LVL46:
 468               	.LBE80:
 469               	.LBE79:
 115:main.c        **** 		_delay_us(LCD_WRITE_DELAY);
 116:main.c        **** 		PORTB |= _BV(PB1);
 470               		.loc 4 116 0 discriminator 4
 471 0182 299A      		sbi 0x5,1
 472               	.LVL47:
 473               	.LBB81:
 474               	.LBB82:
 475               		.loc 3 276 0 discriminator 4
 476 0184 82E0      		ldi r24,lo8(2)
 477 0186 8A95      	1:	dec r24
 478 0188 01F4      		brne 1b
 479 018a 00C0      		rjmp .
 480               	.LVL48:
 481               	.LBE82:
 482               	.LBE81:
 117:main.c        **** 		_delay_us(LCD_WRITE_DELAY);
 118:main.c        **** 		count--;
 483               		.loc 4 118 0 discriminator 4
 484 018c 6150      		subi r22,lo8(-(-1))
 485               	.LVL49:
 119:main.c        **** 	} while (count);
 486               		.loc 4 119 0 discriminator 4
 487 018e 01F4      		brne .L21
 120:main.c        **** 	PORTB &= ~_BV(PB2);
 488               		.loc 4 120 0
 489 0190 2A98      		cbi 0x5,2
 121:main.c        **** 	PORTD |= _BV(PD4);
 490               		.loc 4 121 0
 491 0192 5C9A      		sbi 0xb,4
 492               	.LVL50:
 493               	.LBB83:
 494               	.LBB84:
 495               		.loc 3 276 0
 496 0194 82E0      		ldi r24,lo8(2)
 497 0196 8A95      	1:	dec r24
 498 0198 01F4      		brne 1b
 499 019a 00C0      		rjmp .
 500               	.LVL51:
 501 019c 0895      		ret
 502               	.LBE84:
 503               	.LBE83:
 504               		.cfi_endproc
 505               	.LFE26:
 507               	.global	setup_lcd
 509               	setup_lcd:
 510               	.LFB27:
 122:main.c        **** 	_delay_us(LCD_WRITE_DELAY);
 123:main.c        **** 
 124:main.c        **** }
 125:main.c        **** 
 126:main.c        **** 
 127:main.c        **** void setup_lcd(void)
 128:main.c        **** {
 511               		.loc 4 128 0
 512               		.cfi_startproc
 513 019e CF93      		push r28
 514               	.LCFI0:
 515               		.cfi_def_cfa_offset 3
 516               		.cfi_offset 28, -2
 517 01a0 DF93      		push r29
 518               	.LCFI1:
 519               		.cfi_def_cfa_offset 4
 520               		.cfi_offset 29, -3
 521               	/* prologue: function */
 522               	/* frame size = 0 */
 523               	/* stack size = 2 */
 524               	.L__stack_usage = 2
 129:main.c        **** 
 130:main.c        **** 	PORTD |= _BV(PD4);
 525               		.loc 4 130 0
 526 01a2 5C9A      		sbi 0xb,4
 527               	.LVL52:
 528               	.LBB85:
 529               	.LBB86:
 530               		.loc 3 276 0
 531 01a4 2AE1      		ldi r18,lo8(26)
 532 01a6 2A95      	1:	dec r18
 533 01a8 01F4      		brne 1b
 534 01aa 00C0      		rjmp .
 535               	.LVL53:
 536 01ac C0E0      		ldi r28,lo8(commands)
 537 01ae D0E0      		ldi r29,hi8(commands)
 538               	.LVL54:
 539               	.L25:
 540               	.LBE86:
 541               	.LBE85:
 542               	.LBB87:
 131:main.c        **** 	_delay_us(5);
 132:main.c        **** 
 133:main.c        **** 	for (int x = 0; x < 11; x++)
 134:main.c        **** 	{
 135:main.c        **** 		write_lcd(commands[x], 16);
 543               		.loc 4 135 0 discriminator 3
 544 01b0 60E1      		ldi r22,lo8(16)
 545 01b2 8991      		ld r24,Y+
 546 01b4 9991      		ld r25,Y+
 547 01b6 0E94 0000 		call write_lcd
 548               	.LVL55:
 133:main.c        **** 	{
 549               		.loc 4 133 0 discriminator 3
 550 01ba 80E0      		ldi r24,hi8(commands+22)
 551 01bc C030      		cpi r28,lo8(commands+22)
 552 01be D807      		cpc r29,r24
 553 01c0 01F4      		brne .L25
 554 01c2 C0E0      		ldi r28,lo8(commands2)
 555 01c4 D0E0      		ldi r29,hi8(commands2)
 556               	.L26:
 557               	.LBE87:
 558               	.LBB88:
 136:main.c        **** 	}							 //only for A035VW01
 137:main.c        **** 	for (int x = 0; x < (sizeof(commands2) / sizeof(uint16_t)); x++)
 559               		.loc 4 137 0 discriminator 1
 560 01c6 90E0      		ldi r25,hi8(commands2+136)
 561 01c8 C030      		cpi r28,lo8(commands2+136)
 562 01ca D907      		cpc r29,r25
 563 01cc 01F0      		breq .L31
 138:main.c        **** 	{
 139:main.c        **** 		if (commands2[x] == 0x0000)
 564               		.loc 4 139 0
 565 01ce 8991      		ld r24,Y+
 566 01d0 9991      		ld r25,Y+
 567 01d2 0097      		sbiw r24,0
 568 01d4 01F4      		brne .L27
 569               	.LVL56:
 570               	.LBB89:
 571               	.LBB90:
 187:/usr/lib/avr/include/util/delay.h **** 
 572               		.loc 3 187 0
 573 01d6 9FEF      		ldi r25,lo8(319999)
 574 01d8 21EE      		ldi r18,hi8(319999)
 575 01da 84E0      		ldi r24,hlo8(319999)
 576 01dc 9150      	1:	subi r25,1
 577 01de 2040      		sbci r18,0
 578 01e0 8040      		sbci r24,0
 579 01e2 01F4      		brne 1b
 580 01e4 00C0      		rjmp .
 581 01e6 0000      		nop
 582               	.LVL57:
 583               	.LBE90:
 584               	.LBE89:
 140:main.c        **** 		{
 141:main.c        **** 			_delay_ms(LCD_WAIT);
 142:main.c        **** 			continue;
 585               		.loc 4 142 0
 586 01e8 00C0      		rjmp .L26
 587               	.L27:
 143:main.c        **** 		}
 144:main.c        **** 		write_lcd(commands2[x], 9);
 588               		.loc 4 144 0
 589 01ea 69E0      		ldi r22,lo8(9)
 590 01ec 0E94 0000 		call write_lcd
 591               	.LVL58:
 592 01f0 00C0      		rjmp .L26
 593               	.L31:
 594               	/* epilogue start */
 595               	.LBE88:
 145:main.c        **** 	}							 //only for A035VL01
 146:main.c        **** 
 147:main.c        **** }
 596               		.loc 4 147 0
 597 01f2 DF91      		pop r29
 598 01f4 CF91      		pop r28
 599 01f6 0895      		ret
 600               		.cfi_endproc
 601               	.LFE27:
 603               	.global	read_analog
 605               	read_analog:
 606               	.LFB28:
 148:main.c        **** 
 149:main.c        **** 
 150:main.c        **** uint16_t read_analog(uint8_t channel)
 151:main.c        **** {
 607               		.loc 4 151 0
 608               		.cfi_startproc
 609               	.LVL59:
 610               	/* prologue: function */
 611               	/* frame size = 0 */
 612               	/* stack size = 0 */
 613               	.L__stack_usage = 0
 152:main.c        **** 	uint8_t low, high;
 153:main.c        **** 	ADCSRA |= _BV(ADPS2) | _BV(ADPS1) | _BV(ADPS0);
 614               		.loc 4 153 0
 615 01f8 9091 7A00 		lds r25,122
 616 01fc 9760      		ori r25,lo8(7)
 617 01fe 9093 7A00 		sts 122,r25
 154:main.c        **** 	ADCSRB = 0x40;
 618               		.loc 4 154 0
 619 0202 90E4      		ldi r25,lo8(64)
 620 0204 9093 7B00 		sts 123,r25
 155:main.c        **** 	ADMUX = ((0 << REFS1) | (1 << REFS0) | (0 << ADLAR));
 621               		.loc 4 155 0
 622 0208 9093 7C00 		sts 124,r25
 156:main.c        **** 
 157:main.c        **** 	if (channel >= 8)			 //
 623               		.loc 4 157 0
 624 020c 8830      		cpi r24,lo8(8)
 625 020e 00F0      		brlo .L33
 158:main.c        **** 	{
 159:main.c        **** 		channel -= 0x08;		 //ch - 8
 626               		.loc 4 159 0
 627 0210 8850      		subi r24,lo8(-(-8))
 628               	.LVL60:
 160:main.c        **** 		ADCSRB |= (1 << MUX5);	 // set MUX5 on ADCSRB to read upper bit ADC8-ADC13
 629               		.loc 4 160 0
 630 0212 9091 7B00 		lds r25,123
 631 0216 9062      		ori r25,lo8(32)
 632 0218 00C0      		rjmp .L37
 633               	.L33:
 161:main.c        **** 	}
 162:main.c        **** 	else
 163:main.c        **** 	{
 164:main.c        **** 		ADCSRB &= ~(1 << MUX5);	 // clear MUX 5
 634               		.loc 4 164 0
 635 021a 9091 7B00 		lds r25,123
 636 021e 9F7D      		andi r25,lo8(-33)
 637               	.L37:
 638 0220 9093 7B00 		sts 123,r25
 639               	.LVL61:
 165:main.c        **** 	}
 166:main.c        **** 	channel &= 0x07;
 167:main.c        **** 	ADMUX |= channel;			 // selecting channel
 640               		.loc 4 167 0
 641 0224 9091 7C00 		lds r25,124
 642 0228 8770      		andi r24,lo8(7)
 643               	.LVL62:
 644 022a 892B      		or r24,r25
 645               	.LVL63:
 646 022c 8093 7C00 		sts 124,r24
 168:main.c        **** 
 169:main.c        **** 	ADCSRA |= _BV(ADEN);
 647               		.loc 4 169 0
 648 0230 8091 7A00 		lds r24,122
 649 0234 8068      		ori r24,lo8(-128)
 650 0236 8093 7A00 		sts 122,r24
 651               	.LVL64:
 652               	.LBB91:
 653               	.LBB92:
 187:/usr/lib/avr/include/util/delay.h **** 
 654               		.loc 3 187 0
 655 023a 8FE3      		ldi r24,lo8(7999)
 656 023c 9FE1      		ldi r25,hi8(7999)
 657 023e 0197      	1:	sbiw r24,1
 658 0240 01F4      		brne 1b
 659 0242 00C0      		rjmp .
 660 0244 0000      		nop
 661               	.LVL65:
 662               	.LBE92:
 663               	.LBE91:
 170:main.c        **** 	_delay_ms(2);
 171:main.c        **** 	ADCSRA |= (1 << ADSC);
 664               		.loc 4 171 0
 665 0246 8091 7A00 		lds r24,122
 666 024a 8064      		ori r24,lo8(64)
 667 024c 8093 7A00 		sts 122,r24
 668               	.L35:
 172:main.c        **** 
 173:main.c        **** 	while ((ADCSRA & _BV(ADSC)));// measuring
 669               		.loc 4 173 0 discriminator 1
 670 0250 8091 7A00 		lds r24,122
 671 0254 86FD      		sbrc r24,6
 672 0256 00C0      		rjmp .L35
 174:main.c        **** 	low = ADCL;
 673               		.loc 4 174 0
 674 0258 8091 7800 		lds r24,120
 675               	.LVL66:
 175:main.c        **** 	high = ADCH;
 676               		.loc 4 175 0
 677 025c 2091 7900 		lds r18,121
 678               	.LVL67:
 176:main.c        **** 	return (high << 8) | low;
 679               		.loc 4 176 0
 680 0260 90E0      		ldi r25,0
 177:main.c        **** 
 178:main.c        **** }
 681               		.loc 4 178 0
 682 0262 922B      		or r25,r18
 683 0264 0895      		ret
 684               		.cfi_endproc
 685               	.LFE28:
 687               	.global	readVcc
 689               	readVcc:
 690               	.LFB29:
 179:main.c        **** 
 180:main.c        **** 
 181:main.c        **** uint16_t readVcc(void)
 182:main.c        **** {
 691               		.loc 4 182 0
 692               		.cfi_startproc
 693               	/* prologue: function */
 694               	/* frame size = 0 */
 695               	/* stack size = 0 */
 696               	.L__stack_usage = 0
 183:main.c        **** 	ADMUX = _BV(REFS0) | _BV(MUX4) | _BV(MUX3) | _BV(MUX2) | _BV(MUX1);
 697               		.loc 4 183 0
 698 0266 8EE5      		ldi r24,lo8(94)
 699 0268 8093 7C00 		sts 124,r24
 184:main.c        **** 	ADCSRA |= _BV(ADEN);
 700               		.loc 4 184 0
 701 026c 8091 7A00 		lds r24,122
 702 0270 8068      		ori r24,lo8(-128)
 703 0272 8093 7A00 		sts 122,r24
 185:main.c        **** 	ADCSRB &= ~_BV(MUX5);
 704               		.loc 4 185 0
 705 0276 8091 7B00 		lds r24,123
 706 027a 8F7D      		andi r24,lo8(-33)
 707 027c 8093 7B00 		sts 123,r24
 708               	.LVL68:
 709               	.LBB93:
 710               	.LBB94:
 187:/usr/lib/avr/include/util/delay.h **** 
 711               		.loc 3 187 0
 712 0280 8FE3      		ldi r24,lo8(7999)
 713 0282 9FE1      		ldi r25,hi8(7999)
 714 0284 0197      	1:	sbiw r24,1
 715 0286 01F4      		brne 1b
 716 0288 00C0      		rjmp .
 717 028a 0000      		nop
 718               	.LVL69:
 719               	.LBE94:
 720               	.LBE93:
 186:main.c        **** 	_delay_ms(2);
 187:main.c        **** 	ADCSRA |= 1 << ADSC;
 721               		.loc 4 187 0
 722 028c 8091 7A00 		lds r24,122
 723 0290 8064      		ori r24,lo8(64)
 724 0292 8093 7A00 		sts 122,r24
 725               	.L39:
 188:main.c        **** 	while ((ADCSRA & _BV(ADSC)));// measuring
 726               		.loc 4 188 0 discriminator 1
 727 0296 8091 7A00 		lds r24,122
 728 029a 86FD      		sbrc r24,6
 729 029c 00C0      		rjmp .L39
 189:main.c        **** 	ADCSRA |= 1 << ADSC;
 730               		.loc 4 189 0
 731 029e 8091 7A00 		lds r24,122
 732 02a2 8064      		ori r24,lo8(64)
 733 02a4 8093 7A00 		sts 122,r24
 734               	.L40:
 190:main.c        **** 	while ((ADCSRA & _BV(ADSC)));
 735               		.loc 4 190 0 discriminator 1
 736 02a8 8091 7A00 		lds r24,122
 737 02ac 86FD      		sbrc r24,6
 738 02ae 00C0      		rjmp .L40
 191:main.c        **** 	return 1125300L / (ADCL | (ADCH<<8));
 739               		.loc 4 191 0
 740 02b0 2091 7800 		lds r18,120
 741 02b4 8091 7900 		lds r24,121
 742 02b8 30E0      		ldi r19,0
 743 02ba 382B      		or r19,r24
 744 02bc 032E      		mov __tmp_reg__,r19
 745 02be 000C      		lsl r0
 746 02c0 440B      		sbc r20,r20
 747 02c2 550B      		sbc r21,r21
 748 02c4 64EB      		ldi r22,lo8(-76)
 749 02c6 7BE2      		ldi r23,lo8(43)
 750 02c8 81E1      		ldi r24,lo8(17)
 751 02ca 90E0      		ldi r25,0
 752 02cc 0E94 0000 		call __divmodsi4
 192:main.c        **** }
 753               		.loc 4 192 0
 754 02d0 C901      		movw r24,r18
 755 02d2 0895      		ret
 756               		.cfi_endproc
 757               	.LFE29:
 759               	.global	GetTemp
 761               	GetTemp:
 762               	.LFB30:
 193:main.c        **** 
 194:main.c        **** 
 195:main.c        **** uint16_t GetTemp(void)
 196:main.c        **** {
 763               		.loc 4 196 0
 764               		.cfi_startproc
 765               	/* prologue: function */
 766               	/* frame size = 0 */
 767               	/* stack size = 0 */
 768               	.L__stack_usage = 0
 197:main.c        **** 
 198:main.c        **** 								 // Set internal V reference, temperature reading
 199:main.c        **** 	ADMUX = _BV(REFS1) | _BV(REFS0) | 7;
 769               		.loc 4 199 0
 770 02d4 87EC      		ldi r24,lo8(-57)
 771 02d6 8093 7C00 		sts 124,r24
 200:main.c        **** 	ADCSRB = 0x20;				 // ref  24.6
 772               		.loc 4 200 0
 773 02da 80E2      		ldi r24,lo8(32)
 774 02dc 8093 7B00 		sts 123,r24
 201:main.c        **** 								 // Clear auto trigger and interrupt enable
 202:main.c        **** 	ADCSRA &= ~(_BV(ADATE) | _BV(ADIE));
 775               		.loc 4 202 0
 776 02e0 8091 7A00 		lds r24,122
 777 02e4 877D      		andi r24,lo8(-41)
 778 02e6 8093 7A00 		sts 122,r24
 203:main.c        **** 	ADCSRA |= _BV(ADEN);		 // enable the ADC
 779               		.loc 4 203 0
 780 02ea 8091 7A00 		lds r24,122
 781 02ee 8068      		ori r24,lo8(-128)
 782 02f0 8093 7A00 		sts 122,r24
 783               	.LVL70:
 784               	.LBB95:
 785               	.LBB96:
 187:/usr/lib/avr/include/util/delay.h **** 
 786               		.loc 3 187 0
 787 02f4 8FE3      		ldi r24,lo8(7999)
 788 02f6 9FE1      		ldi r25,hi8(7999)
 789 02f8 0197      	1:	sbiw r24,1
 790 02fa 01F4      		brne 1b
 791 02fc 00C0      		rjmp .
 792 02fe 0000      		nop
 793               	.LVL71:
 794               	.LBE96:
 795               	.LBE95:
 204:main.c        **** 	_delay_ms(2);				 // delay for voltages to become stable.
 205:main.c        **** 
 206:main.c        **** 	ADCSRA |= _BV(ADSC);		 // measuring
 796               		.loc 4 206 0
 797 0300 8091 7A00 		lds r24,122
 798 0304 8064      		ori r24,lo8(64)
 799 0306 8093 7A00 		sts 122,r24
 800               	.L44:
 207:main.c        **** 	while ((ADCSRA & _BV(ADSC)));
 801               		.loc 4 207 0 discriminator 1
 802 030a 8091 7A00 		lds r24,122
 803 030e 86FD      		sbrc r24,6
 804 0310 00C0      		rjmp .L44
 208:main.c        **** 
 209:main.c        **** 	ADCSRA |= _BV(ADSC);
 805               		.loc 4 209 0
 806 0312 8091 7A00 		lds r24,122
 807 0316 8064      		ori r24,lo8(64)
 808 0318 8093 7A00 		sts 122,r24
 809               	.L45:
 210:main.c        **** 	while ((ADCSRA & _BV(ADSC)));
 810               		.loc 4 210 0 discriminator 1
 811 031c 8091 7A00 		lds r24,122
 812 0320 86FD      		sbrc r24,6
 813 0322 00C0      		rjmp .L45
 211:main.c        **** 
 212:main.c        **** 	return (ADCL | (ADCH << 8));
 814               		.loc 4 212 0
 815 0324 8091 7800 		lds r24,120
 816 0328 2091 7900 		lds r18,121
 817 032c 90E0      		ldi r25,0
 213:main.c        **** }
 818               		.loc 4 213 0
 819 032e 922B      		or r25,r18
 820 0330 0895      		ret
 821               		.cfi_endproc
 822               	.LFE30:
 824               	.global	freeRam
 826               	freeRam:
 827               	.LFB31:
 214:main.c        **** 
 215:main.c        **** 
 216:main.c        **** uint16_t freeRam(void)
 217:main.c        **** {
 828               		.loc 4 217 0
 829               		.cfi_startproc
 830 0332 CF93      		push r28
 831               	.LCFI2:
 832               		.cfi_def_cfa_offset 3
 833               		.cfi_offset 28, -2
 834 0334 DF93      		push r29
 835               	.LCFI3:
 836               		.cfi_def_cfa_offset 4
 837               		.cfi_offset 29, -3
 838 0336 00D0      		rcall .
 839               	.LCFI4:
 840               		.cfi_def_cfa_offset 6
 841 0338 CDB7      		in r28,__SP_L__
 842 033a DEB7      		in r29,__SP_H__
 843               	.LCFI5:
 844               		.cfi_def_cfa_register 28
 845               	/* prologue: function */
 846               	/* frame size = 2 */
 847               	/* stack size = 4 */
 848               	.L__stack_usage = 4
 218:main.c        **** 	extern char __heap_start, * __brkval;
 219:main.c        **** 	int v;
 220:main.c        **** 	return (uint16_t) & v - (__brkval == 0 ? (int) & __heap_start : (int) __brkval);
 849               		.loc 4 220 0
 850 033c 2091 0000 		lds r18,__brkval
 851 0340 3091 0000 		lds r19,__brkval+1
 852 0344 2115      		cp r18,__zero_reg__
 853 0346 3105      		cpc r19,__zero_reg__
 854 0348 01F4      		brne .L49
 855 034a 20E0      		ldi r18,lo8(__heap_start)
 856 034c 30E0      		ldi r19,hi8(__heap_start)
 857               	.L49:
 221:main.c        **** }
 858               		.loc 4 221 0 discriminator 4
 859 034e CE01      		movw r24,r28
 860 0350 0196      		adiw r24,1
 861 0352 821B      		sub r24,r18
 862 0354 930B      		sbc r25,r19
 863               	/* epilogue start */
 864 0356 0F90      		pop __tmp_reg__
 865 0358 0F90      		pop __tmp_reg__
 866 035a DF91      		pop r29
 867 035c CF91      		pop r28
 868 035e 0895      		ret
 869               		.cfi_endproc
 870               	.LFE31:
 872               	.global	I2C_init
 874               	I2C_init:
 875               	.LFB32:
 222:main.c        **** 
 223:main.c        **** 
 224:main.c        **** void I2C_init(uint8_t address)	 // setup ATmega as I2C slave
 225:main.c        **** {
 876               		.loc 4 225 0
 877               		.cfi_startproc
 878               	.LVL72:
 879               	/* prologue: function */
 880               	/* frame size = 0 */
 881               	/* stack size = 0 */
 882               	.L__stack_usage = 0
 226:main.c        **** 	cli();
 883               		.loc 4 226 0
 884               	/* #APP */
 885               	 ;  226 "main.c" 1
 886 0360 F894      		cli
 887               	 ;  0 "" 2
 227:main.c        **** 
 228:main.c        **** 	TWAR = (address << 1);
 888               		.loc 4 228 0
 889               	/* #NOAPP */
 890 0362 880F      		lsl r24
 891               	.LVL73:
 892 0364 8093 BA00 		sts 186,r24
 229:main.c        **** 	TWCR = (1 << TWEN) |		 // TWI Interface enabled.
 893               		.loc 4 229 0
 894 0368 85EC      		ldi r24,lo8(-59)
 895 036a 8093 BC00 		sts 188,r24
 230:main.c        **** 		(1 << TWIE) | (1 << TWINT) |// Enable TWI Interupt and clear the flag.
 231:main.c        **** 								 // Prepare to ACK next time the Slave is addressed.
 232:main.c        **** 		(1 << TWEA) | (0 << TWSTA) | (0 << TWSTO) |
 233:main.c        **** 		(0 << TWWC);
 234:main.c        **** 
 235:main.c        **** 	buffer_address = 0xFF;
 896               		.loc 4 235 0
 897 036e 8FEF      		ldi r24,lo8(-1)
 898 0370 8093 0000 		sts buffer_address,r24
 899 0374 0895      		ret
 900               		.cfi_endproc
 901               	.LFE32:
 903               	.global	__vector_9
 905               	__vector_9:
 906               	.LFB33:
 236:main.c        **** 
 237:main.c        **** }
 238:main.c        **** 
 239:main.c        **** 
 240:main.c        **** ISR(PCINT0_vect)
 241:main.c        **** {
 907               		.loc 4 241 0
 908               		.cfi_startproc
 909 0376 1F92      		push r1
 910               	.LCFI6:
 911               		.cfi_def_cfa_offset 3
 912               		.cfi_offset 1, -2
 913 0378 0F92      		push r0
 914               	.LCFI7:
 915               		.cfi_def_cfa_offset 4
 916               		.cfi_offset 0, -3
 917 037a 0FB6      		in r0,__SREG__
 918 037c 0F92      		push r0
 919 037e 1124      		clr __zero_reg__
 920 0380 8F93      		push r24
 921               	.LCFI8:
 922               		.cfi_def_cfa_offset 5
 923               		.cfi_offset 24, -4
 924 0382 9F93      		push r25
 925               	.LCFI9:
 926               		.cfi_def_cfa_offset 6
 927               		.cfi_offset 25, -5
 928               	/* prologue: Signal */
 929               	/* frame size = 0 */
 930               	/* stack size = 5 */
 931               	.L__stack_usage = 5
 242:main.c        **** 	if (bit_is_clear(PINB, PB0)) fanspin++;
 932               		.loc 4 242 0
 933 0384 1899      		sbic 0x3,0
 934 0386 00C0      		rjmp .L52
 935               		.loc 4 242 0 is_stmt 0 discriminator 1
 936 0388 8091 0000 		lds r24,fanspin
 937 038c 9091 0000 		lds r25,fanspin+1
 938 0390 0196      		adiw r24,1
 939 0392 9093 0000 		sts fanspin+1,r25
 940 0396 8093 0000 		sts fanspin,r24
 941               	.L52:
 942               	/* epilogue start */
 243:main.c        **** }								 // counting VENT_RPM
 943               		.loc 4 243 0 is_stmt 1
 944 039a 9F91      		pop r25
 945 039c 8F91      		pop r24
 946 039e 0F90      		pop r0
 947 03a0 0FBE      		out __SREG__,r0
 948 03a2 0F90      		pop r0
 949 03a4 1F90      		pop r1
 950 03a6 1895      		reti
 951               		.cfi_endproc
 952               	.LFE33:
 954               	.global	__vector_23
 956               	__vector_23:
 957               	.LFB34:
 244:main.c        **** 
 245:main.c        **** 
 246:main.c        **** ISR(TIMER0_OVF_vect)
 247:main.c        **** {
 958               		.loc 4 247 0
 959               		.cfi_startproc
 960 03a8 1F92      		push r1
 961               	.LCFI10:
 962               		.cfi_def_cfa_offset 3
 963               		.cfi_offset 1, -2
 964 03aa 0F92      		push r0
 965               	.LCFI11:
 966               		.cfi_def_cfa_offset 4
 967               		.cfi_offset 0, -3
 968 03ac 0FB6      		in r0,__SREG__
 969 03ae 0F92      		push r0
 970 03b0 1124      		clr __zero_reg__
 971 03b2 8F93      		push r24
 972               	.LCFI12:
 973               		.cfi_def_cfa_offset 5
 974               		.cfi_offset 24, -4
 975 03b4 9F93      		push r25
 976               	.LCFI13:
 977               		.cfi_def_cfa_offset 6
 978               		.cfi_offset 25, -5
 979               	/* prologue: Signal */
 980               	/* frame size = 0 */
 981               	/* stack size = 5 */
 982               	.L__stack_usage = 5
 248:main.c        **** 	isrtimer++;
 983               		.loc 4 248 0
 984 03b6 8091 0000 		lds r24,isrtimer
 985 03ba 9091 0000 		lds r25,isrtimer+1
 986 03be 0196      		adiw r24,1
 987 03c0 9093 0000 		sts isrtimer+1,r25
 988 03c4 8093 0000 		sts isrtimer,r24
 989               	/* epilogue start */
 249:main.c        **** }								 // reuse timer0 for counting VENT_RPM
 990               		.loc 4 249 0
 991 03c8 9F91      		pop r25
 992 03ca 8F91      		pop r24
 993 03cc 0F90      		pop r0
 994 03ce 0FBE      		out __SREG__,r0
 995 03d0 0F90      		pop r0
 996 03d2 1F90      		pop r1
 997 03d4 1895      		reti
 998               		.cfi_endproc
 999               	.LFE34:
 1001               	.global	__vector_36
 1003               	__vector_36:
 1004               	.LFB35:
 250:main.c        **** 
 251:main.c        **** 
 252:main.c        **** ISR(TWI_vect)
 253:main.c        **** {
 1005               		.loc 4 253 0
 1006               		.cfi_startproc
 1007 03d6 1F92      		push r1
 1008               	.LCFI14:
 1009               		.cfi_def_cfa_offset 3
 1010               		.cfi_offset 1, -2
 1011 03d8 0F92      		push r0
 1012               	.LCFI15:
 1013               		.cfi_def_cfa_offset 4
 1014               		.cfi_offset 0, -3
 1015 03da 0FB6      		in r0,__SREG__
 1016 03dc 0F92      		push r0
 1017 03de 1124      		clr __zero_reg__
 1018 03e0 2F93      		push r18
 1019               	.LCFI16:
 1020               		.cfi_def_cfa_offset 5
 1021               		.cfi_offset 18, -4
 1022 03e2 3F93      		push r19
 1023               	.LCFI17:
 1024               		.cfi_def_cfa_offset 6
 1025               		.cfi_offset 19, -5
 1026 03e4 4F93      		push r20
 1027               	.LCFI18:
 1028               		.cfi_def_cfa_offset 7
 1029               		.cfi_offset 20, -6
 1030 03e6 5F93      		push r21
 1031               	.LCFI19:
 1032               		.cfi_def_cfa_offset 8
 1033               		.cfi_offset 21, -7
 1034 03e8 6F93      		push r22
 1035               	.LCFI20:
 1036               		.cfi_def_cfa_offset 9
 1037               		.cfi_offset 22, -8
 1038 03ea 7F93      		push r23
 1039               	.LCFI21:
 1040               		.cfi_def_cfa_offset 10
 1041               		.cfi_offset 23, -9
 1042 03ec 8F93      		push r24
 1043               	.LCFI22:
 1044               		.cfi_def_cfa_offset 11
 1045               		.cfi_offset 24, -10
 1046 03ee 9F93      		push r25
 1047               	.LCFI23:
 1048               		.cfi_def_cfa_offset 12
 1049               		.cfi_offset 25, -11
 1050 03f0 AF93      		push r26
 1051               	.LCFI24:
 1052               		.cfi_def_cfa_offset 13
 1053               		.cfi_offset 26, -12
 1054 03f2 BF93      		push r27
 1055               	.LCFI25:
 1056               		.cfi_def_cfa_offset 14
 1057               		.cfi_offset 27, -13
 1058 03f4 CF93      		push r28
 1059               	.LCFI26:
 1060               		.cfi_def_cfa_offset 15
 1061               		.cfi_offset 28, -14
 1062 03f6 EF93      		push r30
 1063               	.LCFI27:
 1064               		.cfi_def_cfa_offset 16
 1065               		.cfi_offset 30, -15
 1066 03f8 FF93      		push r31
 1067               	.LCFI28:
 1068               		.cfi_def_cfa_offset 17
 1069               		.cfi_offset 31, -16
 1070               	/* prologue: Signal */
 1071               	/* frame size = 0 */
 1072               	/* stack size = 16 */
 1073               	.L__stack_usage = 16
 254:main.c        **** 
 255:main.c        **** 	switch (TW_STATUS)
 1074               		.loc 4 255 0
 1075 03fa 8091 B900 		lds r24,185
 1076 03fe 887F      		andi r24,lo8(-8)
 1077 0400 8038      		cpi r24,lo8(-128)
 1078 0402 01F0      		breq .L57
 1079 0404 00F4      		brsh .L58
 1080 0406 8823      		tst r24
 1081 0408 01F4      		brne .+2
 1082 040a 00C0      		rjmp .L59
 1083 040c 8036      		cpi r24,lo8(96)
 1084 040e 01F0      		breq .+2
 1085 0410 00C0      		rjmp .L56
 256:main.c        **** 	{
 257:main.c        **** 
 258:main.c        **** 		case TW_SR_SLA_ACK:
 259:main.c        **** 			//_delay_us(3);
 260:main.c        ****                         TWCR = (1 << TWIE) | (1 << TWINT) | (1 << TWEA) | (1 << TWEN);
 1086               		.loc 4 260 0
 1087 0412 85EC      		ldi r24,lo8(-59)
 1088 0414 8093 BC00 		sts 188,r24
 261:main.c        **** 								 // set buffer pos undefined
 262:main.c        **** 			buffer_address = 0xFF;
 1089               		.loc 4 262 0
 1090 0418 8FEF      		ldi r24,lo8(-1)
 1091 041a 8093 0000 		sts buffer_address,r24
 263:main.c        **** 			break;
 1092               		.loc 4 263 0
 1093 041e 00C0      		rjmp .L55
 1094               	.L58:
 255:main.c        **** 	{
 1095               		.loc 4 255 0
 1096 0420 883A      		cpi r24,lo8(-88)
 1097 0422 01F4      		brne .+2
 1098 0424 00C0      		rjmp .L61
 1099 0426 883B      		cpi r24,lo8(-72)
 1100 0428 01F4      		brne .+2
 1101 042a 00C0      		rjmp .L61
 1102 042c 00C0      		rjmp .L56
 1103               	.L57:
 264:main.c        **** 
 265:main.c        **** 		case TW_SR_DATA_ACK:	 // received data from master
 266:main.c        ****                         //_delay_us(3);
 267:main.c        **** 			if (buffer_address == 0xFF)
 1104               		.loc 4 267 0
 1105 042e 8091 0000 		lds r24,buffer_address
 1106 0432 8F3F      		cpi r24,lo8(-1)
 1107 0434 01F0      		breq .+2
 1108 0436 00C0      		rjmp .L63
 268:main.c        **** 			{
 269:main.c        **** 
 270:main.c        **** 				commandbyte = TWDR;
 1109               		.loc 4 270 0
 1110 0438 6091 BB00 		lds r22,187
 1111 043c 6093 0000 		sts commandbyte,r22
 271:main.c        **** 				crc = _crc8_ccitt_update(0, commandbyte);
 1112               		.loc 4 271 0
 1113 0440 80E0      		ldi r24,0
 1114 0442 0E94 0000 		call _crc8_ccitt_update
 1115               	.LVL74:
 1116 0446 8093 0000 		sts crc,r24
 272:main.c        **** 				buffer_address = 0;
 1117               		.loc 4 272 0
 1118 044a 1092 0000 		sts buffer_address,__zero_reg__
 273:main.c        **** 				i2cerror = 0;
 1119               		.loc 4 273 0
 1120 044e 1092 0000 		sts i2cerror,__zero_reg__
 274:main.c        **** 
 275:main.c        **** 				switch (commandbyte)
 1121               		.loc 4 275 0
 1122 0452 E091 0000 		lds r30,commandbyte
 1123 0456 8E2F      		mov r24,r30
 1124 0458 90E0      		ldi r25,0
 1125 045a 8831      		cpi r24,24
 1126 045c 9105      		cpc r25,__zero_reg__
 1127 045e 00F0      		brlo .+2
 1128 0460 00C0      		rjmp .L64
 1129 0462 FC01      		movw r30,r24
 1130 0464 E050      		subi r30,lo8(-(gs(.L66)))
 1131 0466 F040      		sbci r31,hi8(-(gs(.L66)))
 1132 0468 0C94 0000 		jmp __tablejump2__
 1133               		.section	.progmem.gcc_sw_table,"a",@progbits
 1134               		.p2align	1
 1135               	.L66:
 1136 0000 0000      		.word gs(.L65)
 1137 0002 0000      		.word gs(.L67)
 1138 0004 0000      		.word gs(.L68)
 1139 0006 0000      		.word gs(.L69)
 1140 0008 0000      		.word gs(.L70)
 1141 000a 0000      		.word gs(.L71)
 1142 000c 0000      		.word gs(.L72)
 1143 000e 0000      		.word gs(.L64)
 1144 0010 0000      		.word gs(.L73)
 1145 0012 0000      		.word gs(.L74)
 1146 0014 0000      		.word gs(.L75)
 1147 0016 0000      		.word gs(.L76)
 1148 0018 0000      		.word gs(.L64)
 1149 001a 0000      		.word gs(.L64)
 1150 001c 0000      		.word gs(.L64)
 1151 001e 0000      		.word gs(.L64)
 1152 0020 0000      		.word gs(.L64)
 1153 0022 0000      		.word gs(.L64)
 1154 0024 0000      		.word gs(.L64)
 1155 0026 0000      		.word gs(.L64)
 1156 0028 0000      		.word gs(.L64)
 1157 002a 0000      		.word gs(.L64)
 1158 002c 0000      		.word gs(.L64)
 1159 002e 0000      		.word gs(.L77)
 1160               		.text
 1161               	.L65:
 276:main.c        **** 				{
 277:main.c        **** 
 278:main.c        **** 					case 0x00: i2cbuffer = a0; break;
 1162               		.loc 4 278 0
 1163 046c 8091 0000 		lds r24,a0
 1164 0470 9091 0000 		lds r25,a0+1
 1165 0474 00C0      		rjmp .L221
 1166               	.L67:
 279:main.c        **** 					case 0x01: i2cbuffer = a1; break;
 1167               		.loc 4 279 0
 1168 0476 8091 0000 		lds r24,a1
 1169 047a 9091 0000 		lds r25,a1+1
 1170 047e 00C0      		rjmp .L221
 1171               	.L68:
 280:main.c        **** 					case 0x02: i2cbuffer = a2; break;
 1172               		.loc 4 280 0
 1173 0480 8091 0000 		lds r24,a2
 1174 0484 9091 0000 		lds r25,a2+1
 1175 0488 00C0      		rjmp .L221
 1176               	.L69:
 281:main.c        **** 					case 0x03: i2cbuffer = a3; break;
 1177               		.loc 4 281 0
 1178 048a 8091 0000 		lds r24,a3
 1179 048e 9091 0000 		lds r25,a3+1
 1180 0492 00C0      		rjmp .L221
 1181               	.L70:
 282:main.c        **** 					case 0x04: i2cbuffer = a4; break;
 1182               		.loc 4 282 0
 1183 0494 8091 0000 		lds r24,a4
 1184 0498 9091 0000 		lds r25,a4+1
 1185 049c 00C0      		rjmp .L221
 1186               	.L71:
 283:main.c        **** 					case 0x05: i2cbuffer = a5; break;
 1187               		.loc 4 283 0
 1188 049e 8091 0000 		lds r24,a5
 1189 04a2 9091 0000 		lds r25,a5+1
 1190 04a6 00C0      		rjmp .L221
 1191               	.L72:
 284:main.c        **** 					case 0x06: i2cbuffer = a7; break;
 1192               		.loc 4 284 0
 1193 04a8 8091 0000 		lds r24,a7
 1194 04ac 9091 0000 		lds r25,a7+1
 1195 04b0 00C0      		rjmp .L221
 1196               	.L73:
 285:main.c        **** 					case 0x08: i2cbuffer = rpm;break;
 1197               		.loc 4 285 0
 1198 04b2 8091 0000 		lds r24,rpm
 1199 04b6 9091 0000 		lds r25,rpm+1
 1200 04ba 00C0      		rjmp .L221
 1201               	.L74:
 286:main.c        **** 					case 0x09: i2cbuffer = vcc; break;
 1202               		.loc 4 286 0
 1203 04bc 8091 0000 		lds r24,vcc
 1204 04c0 9091 0000 		lds r25,vcc+1
 1205 04c4 00C0      		rjmp .L221
 1206               	.L75:
 287:main.c        **** 					case 0x0A: i2cbuffer = temp;break;
 1207               		.loc 4 287 0
 1208 04c6 8091 0000 		lds r24,temp
 1209 04ca 9091 0000 		lds r25,temp+1
 1210 04ce 00C0      		rjmp .L221
 1211               	.L76:
 288:main.c        **** 					case 0x0B: i2cbuffer = freeram; break;
 1212               		.loc 4 288 0
 1213 04d0 8091 0000 		lds r24,freeram
 1214 04d4 9091 0000 		lds r25,freeram+1
 1215 04d8 00C0      		rjmp .L221
 1216               	.L77:
 289:main.c        **** 					case 0x17: i2cbuffer = a7avg; break;
 1217               		.loc 4 289 0
 1218 04da 8091 0000 		lds r24,a7avg
 1219 04de 9091 0000 		lds r25,a7avg+1
 1220               	.L221:
 1221 04e2 9093 0000 		sts i2cbuffer+1,r25
 1222 04e6 8093 0000 		sts i2cbuffer,r24
 1223 04ea 00C0      		rjmp .L64
 1224               	.L63:
 290:main.c        **** 
 291:main.c        **** 				}
 292:main.c        **** 			}
 293:main.c        **** 			else
 294:main.c        **** 			{
 295:main.c        **** 
 296:main.c        **** 				if (buffer_address == 0)
 1225               		.loc 4 296 0
 1226 04ec 8111      		cpse r24,__zero_reg__
 1227 04ee 00C0      		rjmp .L78
 297:main.c        **** 				{
 298:main.c        **** 					twdrbuffer = TWDR;
 1228               		.loc 4 298 0
 1229 04f0 8091 BB00 		lds r24,187
 1230 04f4 8093 0000 		sts twdrbuffer,r24
 299:main.c        **** 					if (commandbyte == 0xFE) crc_active = twdrbuffer;
 1231               		.loc 4 299 0
 1232 04f8 9091 0000 		lds r25,commandbyte
 1233 04fc 9E3F      		cpi r25,lo8(-2)
 1234 04fe 01F4      		brne .L79
 1235               		.loc 4 299 0 is_stmt 0 discriminator 1
 1236 0500 8093 0000 		sts crc_active,r24
 1237               	.L79:
 300:main.c        **** 					crc = _crc8_ccitt_update(crc,TWDR);
 1238               		.loc 4 300 0 is_stmt 1
 1239 0504 6091 BB00 		lds r22,187
 1240 0508 8091 0000 		lds r24,crc
 1241 050c 0E94 0000 		call _crc8_ccitt_update
 1242               	.LVL75:
 1243 0510 8093 0000 		sts crc,r24
 1244               	.L78:
 301:main.c        **** 
 302:main.c        **** 				}
 303:main.c        **** 
 304:main.c        **** 				if ((crc_active && (buffer_address == 1) && (TWDR == crc)) ||   (!crc_active && buffer_address 
 1245               		.loc 4 304 0
 1246 0514 9091 0000 		lds r25,crc_active
 1247 0518 8091 0000 		lds r24,buffer_address
 1248 051c 9923      		tst r25
 1249 051e 01F0      		breq .L80
 1250               		.loc 4 304 0 is_stmt 0 discriminator 1
 1251 0520 8130      		cpi r24,lo8(1)
 1252 0522 01F0      		breq .+2
 1253 0524 00C0      		rjmp .L81
 1254               		.loc 4 304 0 discriminator 3
 1255 0526 9091 BB00 		lds r25,187
 1256 052a 8091 0000 		lds r24,crc
 1257 052e 9813      		cpse r25,r24
 1258 0530 00C0      		rjmp .L81
 1259 0532 00C0      		rjmp .L82
 1260               	.L80:
 1261               		.loc 4 304 0 discriminator 6
 1262 0534 8111      		cpse r24,__zero_reg__
 1263 0536 00C0      		rjmp .L81
 1264               	.L82:
 305:main.c        **** 				{
 306:main.c        ****                                         switch(commandbyte) {
 1265               		.loc 4 306 0 is_stmt 1
 1266 0538 8091 0000 		lds r24,commandbyte
 1267 053c 8339      		cpi r24,lo8(-109)
 1268 053e 01F4      		brne .+2
 1269 0540 00C0      		rjmp .L84
 1270 0542 00F4      		brsh .L85
 1271 0544 8F38      		cpi r24,lo8(-113)
 1272 0546 01F4      		brne .+2
 1273 0548 00C0      		rjmp .L86
 1274 054a 00F4      		brsh .L87
 1275 054c 8D38      		cpi r24,lo8(-115)
 1276 054e 01F4      		brne .+2
 1277 0550 00C0      		rjmp .L88
 1278 0552 00F0      		brlo .+2
 1279 0554 00C0      		rjmp .L89
 1280 0556 8738      		cpi r24,lo8(-121)
 1281 0558 01F0      		breq .+2
 1282 055a 00C0      		rjmp .L81
 307:main.c        **** 
 308:main.c        **** 					case 0x87: newbllevel = twdrbuffer; break;
 1283               		.loc 4 308 0
 1284 055c 8091 0000 		lds r24,twdrbuffer
 1285 0560 8093 0000 		sts newbllevel,r24
 1286 0564 00C0      		rjmp .L104
 1287               	.L87:
 1288 0566 9091 0000 		lds r25,twdrbuffer
 306:main.c        **** 
 1289               		.loc 4 306 0
 1290 056a 8139      		cpi r24,lo8(-111)
 1291 056c 01F4      		brne .+2
 1292 056e 00C0      		rjmp .L91
 1293 0570 00F4      		brsh .+2
 1294 0572 00C0      		rjmp .L216
 1295 0574 00C0      		rjmp .L246
 1296               	.L85:
 1297 0576 8839      		cpi r24,lo8(-104)
 1298 0578 01F0      		breq .L94
 1299 057a 00F4      		brsh .L95
 1300 057c 8539      		cpi r24,lo8(-107)
 1301 057e 01F4      		brne .+2
 1302 0580 00C0      		rjmp .L96
 1303 0582 00F4      		brsh .+2
 1304 0584 00C0      		rjmp .L97
 1305 0586 8639      		cpi r24,lo8(-106)
 1306 0588 01F0      		breq .+2
 1307 058a 00C0      		rjmp .L81
 309:main.c        **** 								 // switch display controller on off
 310:main.c        **** 					case 0x98:
 311:main.c        **** 					
 312:main.c        **** 						displaychange = 1; if (twdrbuffer == 0xFF)
 313:main.c        **** 						{
 314:main.c        **** 							write_lcd(0x0A03,16); /* A035VL01: write_lcd(0x029,9); */ display = 0xFF;
 315:main.c        **** 						}
 316:main.c        **** 						else
 317:main.c        **** 						{
 318:main.c        **** 							write_lcd(0x0A02,16); /* A035VL01: write_lcd(0x028,9); */ display = 0x00;
 319:main.c        **** 						}
 320:main.c        **** 					        break;
 321:main.c        **** 								 // display white / black
 322:main.c        **** 					case 0x99:
 323:main.c        **** 					
 324:main.c        **** 						displaychange = 1; if (twdrbuffer == 0xFF)
 325:main.c        **** 						{
 326:main.c        **** 							write_lcd(0x023,9);
 327:main.c        **** 						}
 328:main.c        **** 						else if (twdrbuffer == 0x00)
 329:main.c        **** 						{
 330:main.c        **** 							write_lcd(0x022,9);
 331:main.c        **** 						}
 332:main.c        **** 						else
 333:main.c        **** 						{
 334:main.c        **** 							write_lcd(0x013,16);
 335:main.c        **** 						}
 336:main.c        **** 					        break;
 337:main.c        **** 								 //set Relais 1
 338:main.c        **** 					case 0x8D:
 339:main.c        **** 					
 340:main.c        **** 						if (twdrbuffer == 0xFF)
 341:main.c        **** 						{
 342:main.c        **** 							PORTC |= _BV(PC6);
 343:main.c        **** 						}
 344:main.c        **** 						else
 345:main.c        **** 						{
 346:main.c        **** 							PORTC &= ~_BV(PC6);
 347:main.c        **** 						}
 348:main.c        **** 					        break;
 349:main.c        **** 								 //set Relais 2
 350:main.c        **** 					case 0x8E:
 351:main.c        **** 					
 352:main.c        **** 						if (twdrbuffer == 0xFF)
 353:main.c        **** 						{
 354:main.c        **** 							PORTB |= _BV(PB4);
 355:main.c        **** 						}
 356:main.c        **** 						else
 357:main.c        **** 						{
 358:main.c        **** 							PORTB &= ~_BV(PB4);
 359:main.c        **** 						}
 360:main.c        **** 					        break;
 361:main.c        **** 								 //set Relais 3
 362:main.c        **** 					case 0x8F:
 363:main.c        **** 					
 364:main.c        **** 						if (twdrbuffer == 0xFF)
 365:main.c        **** 						{
 366:main.c        **** 							PORTB |= _BV(PB6);
 367:main.c        **** 						}
 368:main.c        **** 						else
 369:main.c        **** 						{
 370:main.c        **** 							PORTB &= ~_BV(PB6);
 371:main.c        **** 						}
 372:main.c        **** 					        break;
 373:main.c        **** 								 //set D13
 374:main.c        **** 					case 0x90:
 375:main.c        **** 					
 376:main.c        **** 						if (twdrbuffer == 0xFF)
 377:main.c        **** 						{
 378:main.c        **** 							PORTC |= _BV(PC7);
 379:main.c        **** 						}
 380:main.c        **** 						else
 381:main.c        **** 						{
 382:main.c        **** 							PORTC &= ~_BV(PC7);
 383:main.c        **** 						}
 384:main.c        **** 					        break;
 385:main.c        **** 								 //set HWB ->Gasheater      (D13 on prototypes)
 386:main.c        **** 					case 0x91:
 387:main.c        **** 					
 388:main.c        **** 						if (twdrbuffer == 0x00)
 389:main.c        **** 						{
 390:main.c        **** 							PORTE |=  (1<<2);
 391:main.c        **** 						}
 392:main.c        **** 						else
 393:main.c        **** 						{
 394:main.c        **** 							PORTE &= ~(1<<2);
 395:main.c        **** 						}
 396:main.c        **** 					        break;
 397:main.c        **** 								 //set Buzzer
 398:main.c        **** 					case 0x92:
 399:main.c        **** 					
 400:main.c        **** 						if (twdrbuffer == 0xFF)
 401:main.c        **** 						{
 402:main.c        **** 							PORTB |= _BV(PB5);
 403:main.c        **** 						}
 404:main.c        **** 						else if (twdrbuffer == 0x01)
 405:main.c        **** 						{
 406:main.c        **** 							PORTB |= _BV(PB5); twdrbuffer = 0x02;
 407:main.c        **** 						}
 408:main.c        **** 						else
 409:main.c        **** 						{
 410:main.c        **** 							PORTB &= ~_BV(PB5);twdrbuffer = 0x00;
 411:main.c        **** 						}
 412:main.c        **** 					        break;
 413:main.c        **** 								 //set Vent
 414:main.c        **** 					case 0x93:
 415:main.c        **** 					
 416:main.c        **** 						OCR0A = twdrbuffer; fanlevel = twdrbuffer;
 417:main.c        **** 					        break;
 418:main.c        **** 								 //set r color
 419:main.c        **** 					case 0x94:
 420:main.c        **** 					
 421:main.c        **** 						led[led_position].r = twdrbuffer;changeled = 1;
 422:main.c        **** 					        break;
 423:main.c        **** 								 //set g color
 424:main.c        **** 					case 0x95:
 425:main.c        **** 					
 426:main.c        **** 						led[led_position].g = twdrbuffer;changeled = 1;
 427:main.c        **** 					        break;
 428:main.c        **** 								 //set b color
 429:main.c        **** 					case 0x96:
 430:main.c        **** 					
 431:main.c        **** 						led[led_position].b = twdrbuffer;changeled = 1;
 1308               		.loc 4 431 0
 1309 058c 8091 0000 		lds r24,led_position
 1310 0590 90E0      		ldi r25,0
 1311 0592 FC01      		movw r30,r24
 1312 0594 EE0F      		lsl r30
 1313 0596 FF1F      		rol r31
 1314 0598 8E0F      		add r24,r30
 1315 059a 9F1F      		adc r25,r31
 1316 059c FC01      		movw r30,r24
 1317 059e E050      		subi r30,lo8(-(led))
 1318 05a0 F040      		sbci r31,hi8(-(led))
 1319 05a2 8091 0000 		lds r24,twdrbuffer
 1320 05a6 8283      		std Z+2,r24
 1321 05a8 00C0      		rjmp .L220
 1322               	.L95:
 306:main.c        **** 
 1323               		.loc 4 306 0
 1324 05aa 803A      		cpi r24,lo8(-96)
 1325 05ac 01F4      		brne .+2
 1326 05ae 00C0      		rjmp .L99
 1327 05b0 00F4      		brsh .L100
 1328 05b2 8939      		cpi r24,lo8(-103)
 1329 05b4 01F0      		breq .L101
 1330 05b6 00C0      		rjmp .L81
 1331               	.L100:
 1332 05b8 813A      		cpi r24,lo8(-95)
 1333 05ba 01F4      		brne .+2
 1334 05bc 00C0      		rjmp .L102
 1335 05be 8D3F      		cpi r24,lo8(-3)
 1336 05c0 01F4      		brne .+2
 1337 05c2 00C0      		rjmp .L103
 1338 05c4 00C0      		rjmp .L81
 1339               	.L94:
 312:main.c        **** 						{
 1340               		.loc 4 312 0
 1341 05c6 81E0      		ldi r24,lo8(1)
 1342 05c8 8093 0000 		sts displaychange,r24
 1343 05cc C091 0000 		lds r28,twdrbuffer
 314:main.c        **** 						}
 1344               		.loc 4 314 0
 1345 05d0 60E1      		ldi r22,lo8(16)
 312:main.c        **** 						{
 1346               		.loc 4 312 0
 1347 05d2 CF3F      		cpi r28,lo8(-1)
 1348 05d4 01F4      		brne .L105
 314:main.c        **** 						}
 1349               		.loc 4 314 0
 1350 05d6 83E0      		ldi r24,lo8(3)
 1351 05d8 9AE0      		ldi r25,lo8(10)
 1352 05da 0E94 0000 		call write_lcd
 1353               	.LVL76:
 1354 05de C093 0000 		sts display,r28
 1355 05e2 00C0      		rjmp .L104
 1356               	.L105:
 318:main.c        **** 						}
 1357               		.loc 4 318 0
 1358 05e4 82E0      		ldi r24,lo8(2)
 1359 05e6 9AE0      		ldi r25,lo8(10)
 1360 05e8 0E94 0000 		call write_lcd
 1361               	.LVL77:
 1362 05ec 1092 0000 		sts display,__zero_reg__
 1363 05f0 00C0      		rjmp .L104
 1364               	.L101:
 324:main.c        **** 						{
 1365               		.loc 4 324 0
 1366 05f2 81E0      		ldi r24,lo8(1)
 1367 05f4 8093 0000 		sts displaychange,r24
 1368 05f8 8091 0000 		lds r24,twdrbuffer
 1369 05fc 8F3F      		cpi r24,lo8(-1)
 1370 05fe 01F4      		brne .L106
 326:main.c        **** 						}
 1371               		.loc 4 326 0
 1372 0600 69E0      		ldi r22,lo8(9)
 1373 0602 83E2      		ldi r24,lo8(35)
 1374 0604 90E0      		ldi r25,0
 1375 0606 00C0      		rjmp .L219
 1376               	.L106:
 328:main.c        **** 						{
 1377               		.loc 4 328 0
 1378 0608 8111      		cpse r24,__zero_reg__
 1379 060a 00C0      		rjmp .L107
 330:main.c        **** 						}
 1380               		.loc 4 330 0
 1381 060c 69E0      		ldi r22,lo8(9)
 1382 060e 82E2      		ldi r24,lo8(34)
 1383 0610 90E0      		ldi r25,0
 1384 0612 00C0      		rjmp .L219
 1385               	.L107:
 334:main.c        **** 						}
 1386               		.loc 4 334 0
 1387 0614 60E1      		ldi r22,lo8(16)
 1388 0616 83E1      		ldi r24,lo8(19)
 1389 0618 90E0      		ldi r25,0
 1390               	.L219:
 1391 061a 0E94 0000 		call write_lcd
 1392               	.LVL78:
 1393 061e 00C0      		rjmp .L104
 1394               	.L88:
 340:main.c        **** 						{
 1395               		.loc 4 340 0
 1396 0620 8091 0000 		lds r24,twdrbuffer
 1397 0624 8F3F      		cpi r24,lo8(-1)
 1398 0626 01F4      		brne .L108
 342:main.c        **** 						}
 1399               		.loc 4 342 0
 1400 0628 469A      		sbi 0x8,6
 1401 062a 00C0      		rjmp .L104
 1402               	.L108:
 346:main.c        **** 						}
 1403               		.loc 4 346 0
 1404 062c 4698      		cbi 0x8,6
 1405 062e 00C0      		rjmp .L104
 1406               	.L89:
 352:main.c        **** 						{
 1407               		.loc 4 352 0
 1408 0630 8091 0000 		lds r24,twdrbuffer
 1409 0634 8F3F      		cpi r24,lo8(-1)
 1410 0636 01F4      		brne .L109
 354:main.c        **** 						}
 1411               		.loc 4 354 0
 1412 0638 2C9A      		sbi 0x5,4
 1413 063a 00C0      		rjmp .L104
 1414               	.L109:
 358:main.c        **** 						}
 1415               		.loc 4 358 0
 1416 063c 2C98      		cbi 0x5,4
 1417 063e 00C0      		rjmp .L104
 1418               	.L86:
 364:main.c        **** 						{
 1419               		.loc 4 364 0
 1420 0640 8091 0000 		lds r24,twdrbuffer
 1421 0644 8F3F      		cpi r24,lo8(-1)
 1422 0646 01F4      		brne .L110
 366:main.c        **** 						}
 1423               		.loc 4 366 0
 1424 0648 2E9A      		sbi 0x5,6
 1425 064a 00C0      		rjmp .L104
 1426               	.L110:
 370:main.c        **** 						}
 1427               		.loc 4 370 0
 1428 064c 2E98      		cbi 0x5,6
 1429 064e 00C0      		rjmp .L104
 1430               	.L216:
 376:main.c        **** 						{
 1431               		.loc 4 376 0
 1432 0650 9F3F      		cpi r25,lo8(-1)
 1433 0652 01F4      		brne .L111
 378:main.c        **** 						}
 1434               		.loc 4 378 0
 1435 0654 479A      		sbi 0x8,7
 1436 0656 00C0      		rjmp .L104
 1437               	.L111:
 382:main.c        **** 						}
 1438               		.loc 4 382 0
 1439 0658 4798      		cbi 0x8,7
 1440 065a 00C0      		rjmp .L104
 1441               	.L91:
 388:main.c        **** 						{
 1442               		.loc 4 388 0
 1443 065c 9111      		cpse r25,__zero_reg__
 1444 065e 00C0      		rjmp .L112
 390:main.c        **** 						}
 1445               		.loc 4 390 0
 1446 0660 729A      		sbi 0xe,2
 1447 0662 00C0      		rjmp .L104
 1448               	.L112:
 394:main.c        **** 						}
 1449               		.loc 4 394 0
 1450 0664 7298      		cbi 0xe,2
 1451 0666 00C0      		rjmp .L104
 1452               	.L246:
 400:main.c        **** 						{
 1453               		.loc 4 400 0
 1454 0668 9F3F      		cpi r25,lo8(-1)
 1455 066a 01F4      		brne .L113
 402:main.c        **** 						}
 1456               		.loc 4 402 0
 1457 066c 2D9A      		sbi 0x5,5
 1458 066e 00C0      		rjmp .L104
 1459               	.L113:
 404:main.c        **** 						{
 1460               		.loc 4 404 0
 1461 0670 9130      		cpi r25,lo8(1)
 1462 0672 01F4      		brne .L114
 406:main.c        **** 						}
 1463               		.loc 4 406 0
 1464 0674 2D9A      		sbi 0x5,5
 1465 0676 82E0      		ldi r24,lo8(2)
 1466 0678 8093 0000 		sts twdrbuffer,r24
 1467 067c 00C0      		rjmp .L104
 1468               	.L114:
 410:main.c        **** 						}
 1469               		.loc 4 410 0
 1470 067e 2D98      		cbi 0x5,5
 1471 0680 1092 0000 		sts twdrbuffer,__zero_reg__
 1472 0684 00C0      		rjmp .L104
 1473               	.L84:
 416:main.c        **** 					        break;
 1474               		.loc 4 416 0
 1475 0686 8091 0000 		lds r24,twdrbuffer
 1476 068a 87BD      		out 0x27,r24
 1477 068c 8091 0000 		lds r24,twdrbuffer
 1478 0690 8093 0000 		sts fanlevel,r24
 417:main.c        **** 								 //set r color
 1479               		.loc 4 417 0
 1480 0694 00C0      		rjmp .L104
 1481               	.L97:
 421:main.c        **** 					        break;
 1482               		.loc 4 421 0
 1483 0696 8091 0000 		lds r24,led_position
 1484 069a 90E0      		ldi r25,0
 1485 069c FC01      		movw r30,r24
 1486 069e EE0F      		lsl r30
 1487 06a0 FF1F      		rol r31
 1488 06a2 8E0F      		add r24,r30
 1489 06a4 9F1F      		adc r25,r31
 1490 06a6 FC01      		movw r30,r24
 1491 06a8 E050      		subi r30,lo8(-(led))
 1492 06aa F040      		sbci r31,hi8(-(led))
 1493 06ac 8091 0000 		lds r24,twdrbuffer
 1494 06b0 8183      		std Z+1,r24
 1495 06b2 00C0      		rjmp .L220
 1496               	.L96:
 426:main.c        **** 					        break;
 1497               		.loc 4 426 0
 1498 06b4 8091 0000 		lds r24,led_position
 1499 06b8 90E0      		ldi r25,0
 1500 06ba FC01      		movw r30,r24
 1501 06bc EE0F      		lsl r30
 1502 06be FF1F      		rol r31
 1503 06c0 8E0F      		add r24,r30
 1504 06c2 9F1F      		adc r25,r31
 1505 06c4 FC01      		movw r30,r24
 1506 06c6 E050      		subi r30,lo8(-(led))
 1507 06c8 F040      		sbci r31,hi8(-(led))
 1508 06ca 8091 0000 		lds r24,twdrbuffer
 1509 06ce 8083      		st Z,r24
 1510               	.L220:
 1511               		.loc 4 431 0
 1512 06d0 81E0      		ldi r24,lo8(1)
 1513 06d2 8093 0000 		sts changeled,r24
 432:main.c        **** 					        break;
 1514               		.loc 4 432 0
 1515 06d6 00C0      		rjmp .L104
 1516               	.L103:
 433:main.c        **** 								 //jump to bootloader
 434:main.c        **** 					case 0xFD:
 435:main.c        **** 					
 436:main.c        **** 						if (twdrbuffer == 0xFF) jumptobootloader = 1;
 1517               		.loc 4 436 0
 1518 06d8 8091 0000 		lds r24,twdrbuffer
 1519 06dc 8F3F      		cpi r24,lo8(-1)
 1520 06de 01F4      		brne .L104
 1521               		.loc 4 436 0 is_stmt 0 discriminator 1
 1522 06e0 81E0      		ldi r24,lo8(1)
 1523 06e2 8093 0000 		sts jumptobootloader,r24
 1524 06e6 00C0      		rjmp .L104
 1525               	.L102:
 437:main.c        **** 					        break;
 438:main.c        **** 					case 0xA1:  led_position = twdrbuffer; break;
 1526               		.loc 4 438 0 is_stmt 1
 1527 06e8 8091 0000 		lds r24,twdrbuffer
 1528 06ec 8093 0000 		sts led_position,r24
 1529 06f0 00C0      		rjmp .L104
 1530               	.L99:
 439:main.c        **** 					case 0xA0: watchdog = twdrbuffer; break;
 1531               		.loc 4 439 0
 1532 06f2 8091 0000 		lds r24,twdrbuffer
 1533 06f6 8093 0000 		sts watchdog,r24
 1534 06fa 00C0      		rjmp .L104
 1535               	.L81:
 440:main.c        **** 					default: i2cerror++;
 441:main.c        **** 
 442:main.c        ****                                 }
 443:main.c        **** 				}
 444:main.c        **** 				else {i2cerror++;}
 1536               		.loc 4 444 0
 1537 06fc 8091 0000 		lds r24,i2cerror
 1538 0700 8F5F      		subi r24,lo8(-(1))
 1539 0702 8093 0000 		sts i2cerror,r24
 1540               	.L104:
 445:main.c        **** 
 446:main.c        **** 				buffer_address++;
 1541               		.loc 4 446 0
 1542 0706 8091 0000 		lds r24,buffer_address
 1543 070a 8F5F      		subi r24,lo8(-(1))
 1544 070c 8093 0000 		sts buffer_address,r24
 1545               	.L64:
 447:main.c        **** 
 448:main.c        **** 			}
 449:main.c        **** 			TWCR = (1<<TWIE) | (1<<TWINT) | (1<<TWEA) | (1<<TWEN);
 1546               		.loc 4 449 0
 1547 0710 85EC      		ldi r24,lo8(-59)
 1548 0712 8093 BC00 		sts 188,r24
 450:main.c        **** 			if ((commandbyte == 0x92) & (twdrbuffer == 0x02)) {_delay_us(25); PORTB &= ~_BV(PB5);}
 1549               		.loc 4 450 0
 1550 0716 8091 0000 		lds r24,commandbyte
 1551 071a 8239      		cpi r24,lo8(-110)
 1552 071c 01F0      		breq .+2
 1553 071e 00C0      		rjmp .L55
 1554 0720 8091 0000 		lds r24,twdrbuffer
 1555 0724 8230      		cpi r24,lo8(2)
 1556 0726 01F0      		breq .+2
 1557 0728 00C0      		rjmp .L55
 1558               	.LVL79:
 1559               	.LBB97:
 1560               	.LBB98:
 1561               		.loc 3 276 0
 1562 072a 85E8      		ldi r24,lo8(-123)
 1563 072c 8A95      	1:	dec r24
 1564 072e 01F4      		brne 1b
 1565 0730 0000      		nop
 1566               	.LVL80:
 1567               	.LBE98:
 1568               	.LBE97:
 1569               		.loc 4 450 0
 1570 0732 2D98      		cbi 0x5,5
 1571 0734 00C0      		rjmp .L55
 1572               	.L61:
 451:main.c        **** 			break;
 452:main.c        **** 
 453:main.c        **** 		case TW_ST_SLA_ACK:		 //  slave adressed
 454:main.c        **** 		case TW_ST_DATA_ACK:
 455:main.c        **** 
 456:main.c        **** 			switch(commandbyte)
 1573               		.loc 4 456 0
 1574 0736 8091 0000 		lds r24,commandbyte
 1575 073a 8431      		cpi r24,lo8(20)
 1576 073c 01F4      		brne .+2
 1577 073e 00C0      		rjmp .L118
 1578 0740 00F4      		brsh .L119
 1579 0742 8D30      		cpi r24,lo8(13)
 1580 0744 01F4      		brne .+2
 1581 0746 00C0      		rjmp .L120
 1582 0748 00F4      		brsh .L121
 1583 074a 9091 0000 		lds r25,buffer_address
 1584 074e 8730      		cpi r24,lo8(7)
 1585 0750 01F4      		brne .+2
 1586 0752 00C0      		rjmp .L122
 1587 0754 00F4      		brsh .+2
 1588 0756 00C0      		rjmp .L123
 1589 0758 8C30      		cpi r24,lo8(12)
 1590 075a 00F0      		brlo .+2
 1591 075c 00C0      		rjmp .L217
 1592 075e 00C0      		rjmp .L123
 1593               	.L121:
 1594 0760 8031      		cpi r24,lo8(16)
 1595 0762 01F4      		brne .+2
 1596 0764 00C0      		rjmp .L125
 1597 0766 00F4      		brsh .L126
 1598 0768 8E30      		cpi r24,lo8(14)
 1599 076a 01F4      		brne .+2
 1600 076c 00C0      		rjmp .L127
 1601 076e 8F30      		cpi r24,lo8(15)
 1602 0770 01F4      		brne .+2
 1603 0772 00C0      		rjmp .L128
 1604 0774 00C0      		rjmp .L117
 1605               	.L126:
 1606 0776 9091 0000 		lds r25,buffer_address
 1607 077a 8231      		cpi r24,lo8(18)
 1608 077c 01F4      		brne .+2
 1609 077e 00C0      		rjmp .L129
 1610 0780 00F4      		brsh .+2
 1611 0782 00C0      		rjmp .L218
 1612 0784 00C0      		rjmp .L247
 1613               	.L119:
 1614 0786 8E37      		cpi r24,lo8(126)
 1615 0788 01F4      		brne .+2
 1616 078a 00C0      		rjmp .L132
 1617 078c 00F4      		brsh .L133
 1618 078e 8731      		cpi r24,lo8(23)
 1619 0790 01F4      		brne .+2
 1620 0792 00C0      		rjmp .L123
 1621 0794 00F4      		brsh .L134
 1622 0796 8531      		cpi r24,lo8(21)
 1623 0798 01F4      		brne .+2
 1624 079a 00C0      		rjmp .L135
 1625 079c 8631      		cpi r24,lo8(22)
 1626 079e 01F4      		brne .+2
 1627 07a0 00C0      		rjmp .L136
 1628 07a2 00C0      		rjmp .L117
 1629               	.L134:
 1630 07a4 8032      		cpi r24,lo8(32)
 1631 07a6 01F0      		breq .L137
 1632 07a8 8132      		cpi r24,lo8(33)
 1633 07aa 01F0      		breq .L138
 1634 07ac 8831      		cpi r24,lo8(24)
 1635 07ae 01F0      		breq .+2
 1636 07b0 00C0      		rjmp .L117
 1637 07b2 00C0      		rjmp .L248
 1638               	.L133:
 1639 07b4 8739      		cpi r24,lo8(-105)
 1640 07b6 00F4      		brsh .L140
 1641 07b8 8D38      		cpi r24,lo8(-115)
 1642 07ba 00F4      		brsh .L141
 1643 07bc 8F37      		cpi r24,lo8(127)
 1644 07be 01F4      		brne .+2
 1645 07c0 00C0      		rjmp .L142
 1646 07c2 8738      		cpi r24,lo8(-121)
 1647 07c4 01F0      		breq .L141
 1648 07c6 00C0      		rjmp .L117
 1649               	.L140:
 1650 07c8 805A      		subi r24,lo8(-(96))
 1651 07ca 8230      		cpi r24,lo8(2)
 1652 07cc 00F0      		brlo .+2
 1653 07ce 00C0      		rjmp .L117
 1654               	.L141:
 457:main.c        **** 			{
 458:main.c        **** 
 459:main.c        **** 				case 0x87:
 460:main.c        **** 				case 0x8D:
 461:main.c        **** 				case 0x8E:
 462:main.c        **** 				case 0x8F:
 463:main.c        **** 				case 0x90:
 464:main.c        **** 				case 0x91:
 465:main.c        **** 				case 0x92:
 466:main.c        **** 				case 0x93:
 467:main.c        **** 				case 0x94:
 468:main.c        **** 				case 0x95:
 469:main.c        **** 				case 0xA1:
 470:main.c        **** 				case 0XA0:
 471:main.c        **** 				case 0x96:  { TWDR = crc;  crc = 0xFF;}
 1655               		.loc 4 471 0
 1656 07d0 8091 0000 		lds r24,crc
 1657 07d4 8093 BB00 		sts 187,r24
 1658 07d8 8FEF      		ldi r24,lo8(-1)
 1659 07da 00C0      		rjmp .L225
 1660               	.L248:
 472:main.c        **** 				break;
 473:main.c        **** 
 474:main.c        **** 				case 0x18:
 475:main.c        **** 					if (buffer_address == 0)  {TWDR = display; crc = _crc8_ccitt_update(crc,TWDR);}
 1661               		.loc 4 475 0
 1662 07dc 8091 0000 		lds r24,buffer_address
 1663 07e0 8111      		cpse r24,__zero_reg__
 1664 07e2 00C0      		rjmp .L191
 1665               		.loc 4 475 0 is_stmt 0 discriminator 1
 1666 07e4 8091 0000 		lds r24,display
 1667 07e8 00C0      		rjmp .L223
 1668               	.L137:
 476:main.c        **** 					else if (buffer_address == 1)  {TWDR = crc;}
 477:main.c        **** 					else     {TWDR = 0xFF; i2cerror++;}
 478:main.c        **** 
 479:main.c        **** 					break;
 480:main.c        **** 
 481:main.c        **** 				case 0x20:
 482:main.c        **** 					if (buffer_address == 0)  {TWDR = watchdog; crc = _crc8_ccitt_update(crc,TWDR);}
 1669               		.loc 4 482 0 is_stmt 1
 1670 07ea 8091 0000 		lds r24,buffer_address
 1671 07ee 8111      		cpse r24,__zero_reg__
 1672 07f0 00C0      		rjmp .L191
 1673               		.loc 4 482 0 is_stmt 0 discriminator 1
 1674 07f2 8091 0000 		lds r24,watchdog
 1675               	.L223:
 1676 07f6 8093 BB00 		sts 187,r24
 1677               	.L226:
 1678 07fa 6091 BB00 		lds r22,187
 1679 07fe 8091 0000 		lds r24,crc
 1680 0802 0E94 0000 		call _crc8_ccitt_update
 1681               	.LVL81:
 1682               	.L225:
 1683 0806 8093 0000 		sts crc,r24
 1684 080a 00C0      		rjmp .L143
 1685               	.L138:
 483:main.c        **** 					else if (buffer_address == 1)  {TWDR = crc;}
 484:main.c        **** 					else     {TWDR = 0xFF; i2cerror++;}
 485:main.c        **** 
 486:main.c        **** 					break;
 487:main.c        **** 
 488:main.c        **** 				case 0x21:
 489:main.c        **** 					if (buffer_address == 0)  {TWDR = led_position; crc = _crc8_ccitt_update(crc,TWDR);}
 1686               		.loc 4 489 0 is_stmt 1
 1687 080c 8091 0000 		lds r24,buffer_address
 1688 0810 8111      		cpse r24,__zero_reg__
 1689 0812 00C0      		rjmp .L191
 1690               		.loc 4 489 0 is_stmt 0 discriminator 1
 1691 0814 8091 0000 		lds r24,led_position
 1692 0818 00C0      		rjmp .L223
 1693               	.L118:
 490:main.c        **** 					else if (buffer_address == 1)  {TWDR = crc;}
 491:main.c        **** 					else     {TWDR = 0xFF; i2cerror++;}
 492:main.c        **** 
 493:main.c        **** 					break;
 494:main.c        **** 
 495:main.c        **** 				case 0x14:
 496:main.c        **** 					if (buffer_address == 0)  {TWDR = led[led_position].r; crc = _crc8_ccitt_update(crc,TWDR);}
 1694               		.loc 4 496 0 is_stmt 1
 1695 081a 8091 0000 		lds r24,buffer_address
 1696 081e 8111      		cpse r24,__zero_reg__
 1697 0820 00C0      		rjmp .L191
 1698 0822 00C0      		rjmp .L228
 1699               	.L135:
 497:main.c        **** 					else if (buffer_address == 1)  {TWDR = crc;}
 498:main.c        **** 					else                           {TWDR = 0xFF;  i2cerror++;}
 499:main.c        **** 					break;
 500:main.c        **** 				case 0x15:
 501:main.c        **** 					if (buffer_address == 0)  {TWDR = led[led_position].g; crc = _crc8_ccitt_update(crc,TWDR);}
 1700               		.loc 4 501 0
 1701 0824 8091 0000 		lds r24,buffer_address
 1702 0828 8111      		cpse r24,__zero_reg__
 1703 082a 00C0      		rjmp .L191
 1704 082c 00C0      		rjmp .L229
 1705               	.L136:
 502:main.c        **** 					else if (buffer_address == 1)  {TWDR = crc;}
 503:main.c        **** 					else                           {TWDR = 0xFF;  i2cerror++;}
 504:main.c        **** 					break;
 505:main.c        **** 
 506:main.c        **** 				case 0x16:
 507:main.c        **** 					if (buffer_address == 0)  {TWDR = led[led_position].b; crc = _crc8_ccitt_update(crc,TWDR);}
 1706               		.loc 4 507 0
 1707 082e 8091 0000 		lds r24,buffer_address
 1708 0832 8111      		cpse r24,__zero_reg__
 1709 0834 00C0      		rjmp .L191
 1710 0836 00C0      		rjmp .L230
 1711               	.L123:
 508:main.c        **** 					else if (buffer_address == 1)  {TWDR = crc;}
 509:main.c        **** 					else                           {TWDR = 0xFF;  i2cerror++;}
 510:main.c        **** 					break;
 511:main.c        **** 
 512:main.c        **** 				case 0x00:
 513:main.c        **** 				case 0x01:
 514:main.c        **** 				case 0x02:
 515:main.c        **** 				case 0x03:
 516:main.c        **** 				case 0x04:
 517:main.c        **** 				case 0x05:
 518:main.c        **** 				case 0x06:
 519:main.c        **** 				case 0x08:
 520:main.c        **** 				case 0x09:
 521:main.c        **** 				case 0x0A:
 522:main.c        **** 				case 0x0B:
 523:main.c        **** 				case 0x17:
 524:main.c        **** 					if (buffer_address == 0) {TWDR = i2cbuffer & 0xFF; crc = _crc8_ccitt_update(crc,TWDR);}
 1712               		.loc 4 524 0
 1713 0838 8091 0000 		lds r24,buffer_address
 1714 083c 8111      		cpse r24,__zero_reg__
 1715 083e 00C0      		rjmp .L156
 1716               		.loc 4 524 0 is_stmt 0 discriminator 1
 1717 0840 8091 0000 		lds r24,i2cbuffer
 1718 0844 00C0      		rjmp .L223
 1719               	.L156:
 525:main.c        **** 					else if (buffer_address == 1) {TWDR = i2cbuffer >> 8;   crc = _crc8_ccitt_update(crc,TWDR);}
 1720               		.loc 4 525 0 is_stmt 1
 1721 0846 8130      		cpi r24,lo8(1)
 1722 0848 01F4      		brne .L157
 1723               		.loc 4 525 0 is_stmt 0 discriminator 1
 1724 084a 8091 0000 		lds r24,i2cbuffer+1
 1725 084e 00C0      		rjmp .L223
 1726               	.L157:
 526:main.c        **** 					else if (buffer_address == 2) {TWDR = crc;}
 1727               		.loc 4 526 0 is_stmt 1
 1728 0850 8230      		cpi r24,lo8(2)
 1729 0852 01F0      		breq .+2
 1730 0854 00C0      		rjmp .L194
 1731 0856 00C0      		rjmp .L231
 1732               	.L217:
 527:main.c        **** 					else                          {TWDR = 0xFF; i2cerror++;}
 528:main.c        **** 					break;
 529:main.c        **** 
 530:main.c        **** 				case 0x0C:
 531:main.c        **** 					if (buffer_address == 0)  {TWDR = led[led_position].r; crc = _crc8_ccitt_update(crc,TWDR);}
 1733               		.loc 4 531 0
 1734 0858 9111      		cpse r25,__zero_reg__
 1735 085a 00C0      		rjmp .L159
 1736               	.L228:
 1737               		.loc 4 531 0 is_stmt 0 discriminator 1
 1738 085c 8091 0000 		lds r24,led_position
 1739 0860 90E0      		ldi r25,0
 1740 0862 FC01      		movw r30,r24
 1741 0864 EE0F      		lsl r30
 1742 0866 FF1F      		rol r31
 1743 0868 8E0F      		add r24,r30
 1744 086a 9F1F      		adc r25,r31
 1745 086c FC01      		movw r30,r24
 1746 086e E050      		subi r30,lo8(-(led))
 1747 0870 F040      		sbci r31,hi8(-(led))
 1748 0872 8181      		ldd r24,Z+1
 1749 0874 00C0      		rjmp .L223
 1750               	.L159:
 532:main.c        **** 					else if (buffer_address == 1)  {TWDR = led[led_position].g; crc = _crc8_ccitt_update(crc,TWDR)
 1751               		.loc 4 532 0 is_stmt 1
 1752 0876 9130      		cpi r25,lo8(1)
 1753 0878 01F4      		brne .L160
 1754               	.L229:
 1755               		.loc 4 532 0 is_stmt 0 discriminator 1
 1756 087a 8091 0000 		lds r24,led_position
 1757 087e 90E0      		ldi r25,0
 1758 0880 FC01      		movw r30,r24
 1759 0882 EE0F      		lsl r30
 1760 0884 FF1F      		rol r31
 1761 0886 8E0F      		add r24,r30
 1762 0888 9F1F      		adc r25,r31
 1763 088a FC01      		movw r30,r24
 1764 088c E050      		subi r30,lo8(-(led))
 1765 088e F040      		sbci r31,hi8(-(led))
 1766 0890 8081      		ld r24,Z
 1767 0892 00C0      		rjmp .L223
 1768               	.L160:
 533:main.c        **** 					else if (buffer_address == 2)  {TWDR = led[led_position].b; crc = _crc8_ccitt_update(crc,TWDR)
 1769               		.loc 4 533 0 is_stmt 1
 1770 0894 9230      		cpi r25,lo8(2)
 1771 0896 01F4      		brne .L161
 1772               	.L230:
 1773               		.loc 4 533 0 is_stmt 0 discriminator 1
 1774 0898 8091 0000 		lds r24,led_position
 1775 089c 90E0      		ldi r25,0
 1776 089e FC01      		movw r30,r24
 1777 08a0 EE0F      		lsl r30
 1778 08a2 FF1F      		rol r31
 1779 08a4 8E0F      		add r24,r30
 1780 08a6 9F1F      		adc r25,r31
 1781 08a8 FC01      		movw r30,r24
 1782 08aa E050      		subi r30,lo8(-(led))
 1783 08ac F040      		sbci r31,hi8(-(led))
 1784 08ae 8281      		ldd r24,Z+2
 1785 08b0 00C0      		rjmp .L223
 1786               	.L161:
 534:main.c        **** 					else if (buffer_address == 3)  {TWDR = crc;}
 1787               		.loc 4 534 0 is_stmt 1
 1788 08b2 9330      		cpi r25,lo8(3)
 1789 08b4 01F0      		breq .+2
 1790 08b6 00C0      		rjmp .L194
 1791 08b8 00C0      		rjmp .L231
 1792               	.L120:
 535:main.c        **** 					else                           {TWDR = 0xFF;  i2cerror++;}
 536:main.c        **** 					break;
 537:main.c        **** 
 538:main.c        **** 				case 0x0D:
 539:main.c        **** 					if (buffer_address == 0)
 1793               		.loc 4 539 0
 1794 08ba 8091 0000 		lds r24,buffer_address
 1795 08be 8111      		cpse r24,__zero_reg__
 1796 08c0 00C0      		rjmp .L191
 540:main.c        **** 					{
 541:main.c        **** 						if (bit_is_set(PINC,PC6))
 1797               		.loc 4 541 0
 1798 08c2 369B      		sbis 0x6,6
 1799 08c4 00C0      		rjmp .L184
 1800 08c6 00C0      		rjmp .L245
 1801               	.L127:
 542:main.c        **** 						{
 543:main.c        **** 							TWDR = 0xFF;
 544:main.c        **** 						}
 545:main.c        **** 						else
 546:main.c        **** 						{
 547:main.c        **** 							TWDR = 0x00;
 548:main.c        **** 						}
 549:main.c        **** 						crc = _crc8_ccitt_update(crc,TWDR);
 550:main.c        **** 					}
 551:main.c        **** 					else if (buffer_address == 1) {TWDR = crc;}
 552:main.c        **** 					else {TWDR = 0xFF; i2cerror++;}
 553:main.c        **** 					break;
 554:main.c        **** 
 555:main.c        **** 				case 0x0E:
 556:main.c        **** 					if (buffer_address == 0)
 1802               		.loc 4 556 0
 1803 08c8 8091 0000 		lds r24,buffer_address
 1804 08cc 8111      		cpse r24,__zero_reg__
 1805 08ce 00C0      		rjmp .L191
 557:main.c        **** 					{
 558:main.c        **** 						if (bit_is_set(PINB,PB4))
 1806               		.loc 4 558 0
 1807 08d0 1C9B      		sbis 0x3,4
 1808 08d2 00C0      		rjmp .L184
 1809 08d4 00C0      		rjmp .L245
 1810               	.L128:
 559:main.c        **** 						{
 560:main.c        **** 							TWDR = 0xFF;
 561:main.c        **** 						}
 562:main.c        **** 						else
 563:main.c        **** 						{
 564:main.c        **** 							TWDR = 0x00;
 565:main.c        **** 						}
 566:main.c        **** 						crc = _crc8_ccitt_update(crc,TWDR);
 567:main.c        **** 					}
 568:main.c        **** 					else if (buffer_address == 1) {TWDR = crc;}
 569:main.c        **** 					else                          {TWDR = 0xFF; i2cerror++;}
 570:main.c        **** 					break;
 571:main.c        **** 
 572:main.c        **** 				case 0x0F:
 573:main.c        **** 					if (buffer_address == 0)
 1811               		.loc 4 573 0
 1812 08d6 8091 0000 		lds r24,buffer_address
 1813 08da 8111      		cpse r24,__zero_reg__
 1814 08dc 00C0      		rjmp .L191
 574:main.c        **** 					{
 575:main.c        **** 						if (bit_is_set(PINB,PB6))
 1815               		.loc 4 575 0
 1816 08de 1E9B      		sbis 0x3,6
 1817 08e0 00C0      		rjmp .L184
 1818 08e2 00C0      		rjmp .L245
 1819               	.L125:
 576:main.c        **** 						{
 577:main.c        **** 							TWDR = 0xFF;
 578:main.c        **** 						}
 579:main.c        **** 						else
 580:main.c        **** 						{
 581:main.c        **** 							TWDR = 0x00;
 582:main.c        **** 						}
 583:main.c        **** 						crc = _crc8_ccitt_update(crc,TWDR);
 584:main.c        **** 					}
 585:main.c        **** 					else if (buffer_address == 1) { TWDR = crc;}
 586:main.c        **** 					else                          {TWDR = 0xFF; i2cerror++;}
 587:main.c        **** 					break;
 588:main.c        **** 
 589:main.c        **** 				case 0x10:
 590:main.c        **** 					if (buffer_address == 0)
 1820               		.loc 4 590 0
 1821 08e4 8091 0000 		lds r24,buffer_address
 1822 08e8 8111      		cpse r24,__zero_reg__
 1823 08ea 00C0      		rjmp .L191
 591:main.c        **** 					{
 592:main.c        **** 						if (bit_is_set(PINC,PC7))
 1824               		.loc 4 592 0
 1825 08ec 379B      		sbis 0x6,7
 1826 08ee 00C0      		rjmp .L184
 1827 08f0 00C0      		rjmp .L245
 1828               	.L218:
 593:main.c        **** 						{
 594:main.c        **** 							TWDR = 0xFF;
 595:main.c        **** 						}
 596:main.c        **** 						else
 597:main.c        **** 						{
 598:main.c        **** 							TWDR = 0x00;
 599:main.c        **** 						}
 600:main.c        **** 						crc = _crc8_ccitt_update(crc,TWDR);
 601:main.c        **** 					}
 602:main.c        **** 					else if (buffer_address == 1) {TWDR = crc;}
 603:main.c        **** 					else                          {TWDR = 0xFF; i2cerror++;}
 604:main.c        **** 					break;
 605:main.c        **** 
 606:main.c        **** 				case 0x11:
 607:main.c        **** 					if (buffer_address == 0)
 1829               		.loc 4 607 0
 1830 08f2 9111      		cpse r25,__zero_reg__
 1831 08f4 00C0      		rjmp .L179
 608:main.c        **** 					{
 609:main.c        **** 						if (bit_is_set(PINE,PE2))
 1832               		.loc 4 609 0
 1833 08f6 629B      		sbis 0xc,2
 1834 08f8 00C0      		rjmp .L245
 1835 08fa 00C0      		rjmp .L184
 1836               	.L179:
 610:main.c        **** 						{
 611:main.c        **** 							TWDR = 0x00;
 612:main.c        **** 						}
 613:main.c        **** 						else
 614:main.c        **** 						{
 615:main.c        **** 							TWDR = 0xff;
 616:main.c        **** 						}
 617:main.c        **** 						crc = _crc8_ccitt_update(crc,TWDR);
 618:main.c        **** 					}
 619:main.c        **** 					else if (buffer_address == 1) {TWDR = crc;}
 1837               		.loc 4 619 0
 1838 08fc 9130      		cpi r25,lo8(1)
 1839 08fe 01F0      		breq .L231
 620:main.c        **** 					else                          {TWDR = 0xFF; buffer_address = 0xFE; i2cerror++;}
 1840               		.loc 4 620 0
 1841 0900 8FEF      		ldi r24,lo8(-1)
 1842 0902 8093 BB00 		sts 187,r24
 1843 0906 8EEF      		ldi r24,lo8(-2)
 1844 0908 8093 0000 		sts buffer_address,r24
 1845 090c 00C0      		rjmp .L224
 1846               	.L129:
 621:main.c        **** 					break;
 622:main.c        **** 
 623:main.c        **** 				case 0x12:
 624:main.c        **** 					if (buffer_address == 0)
 1847               		.loc 4 624 0
 1848 090e 9111      		cpse r25,__zero_reg__
 1849 0910 00C0      		rjmp .L193
 625:main.c        **** 					{
 626:main.c        **** 						if (bit_is_set(PINB,PB5))
 1850               		.loc 4 626 0
 1851 0912 1D9B      		sbis 0x3,5
 1852 0914 00C0      		rjmp .L184
 1853               	.L245:
 627:main.c        **** 						{
 628:main.c        **** 							TWDR = 0xFF;
 1854               		.loc 4 628 0
 1855 0916 8FEF      		ldi r24,lo8(-1)
 1856 0918 00C0      		rjmp .L223
 1857               	.L184:
 629:main.c        **** 						}
 630:main.c        **** 						else
 631:main.c        **** 						{
 632:main.c        **** 							TWDR = 0x00;
 1858               		.loc 4 632 0
 1859 091a 1092 BB00 		sts 187,__zero_reg__
 1860 091e 00C0      		rjmp .L226
 1861               	.L247:
 633:main.c        **** 						}
 634:main.c        **** 						crc = _crc8_ccitt_update(crc,TWDR);
 635:main.c        **** 					}
 636:main.c        **** 					else if (buffer_address == 1) {TWDR = crc;}
 637:main.c        **** 					else                          {TWDR = 0xFF; i2cerror++;}
 638:main.c        **** 					break;
 639:main.c        **** 
 640:main.c        **** 				case 0x13:
 641:main.c        **** 					if (buffer_address == 0)      {TWDR = fanlevel; crc = _crc8_ccitt_update(crc,TWDR);}
 1862               		.loc 4 641 0
 1863 0920 9111      		cpse r25,__zero_reg__
 1864 0922 00C0      		rjmp .L193
 1865               		.loc 4 641 0 is_stmt 0 discriminator 1
 1866 0924 8091 0000 		lds r24,fanlevel
 1867 0928 00C0      		rjmp .L223
 1868               	.L132:
 642:main.c        **** 					else if (buffer_address == 1) {TWDR = crc;}
 643:main.c        **** 					else                          {TWDR = 0xFF; i2cerror++;}
 644:main.c        **** 					break;
 645:main.c        **** 
 646:main.c        **** 				case 0x7E:
 647:main.c        **** 					if (buffer_address == 0) {TWDR = crc_active; crc = _crc8_ccitt_update(crc,TWDR);}
 1869               		.loc 4 647 0 is_stmt 1
 1870 092a 8091 0000 		lds r24,buffer_address
 1871 092e 8111      		cpse r24,__zero_reg__
 1872 0930 00C0      		rjmp .L191
 1873               		.loc 4 647 0 is_stmt 0 discriminator 1
 1874 0932 8091 0000 		lds r24,crc_active
 1875 0936 00C0      		rjmp .L223
 1876               	.L142:
 648:main.c        **** 					else if (buffer_address == 1) {TWDR = crc;}
 649:main.c        **** 					else                          {TWDR = 0xFF; i2cerror++;}
 650:main.c        **** 					break;
 651:main.c        **** 
 652:main.c        **** 				case 0x7F:
 653:main.c        **** 					if (buffer_address == 0) {TWDR = FW_VERSION; crc = _crc8_ccitt_update(crc,TWDR);}
 1877               		.loc 4 653 0 is_stmt 1
 1878 0938 8091 0000 		lds r24,buffer_address
 1879 093c 8111      		cpse r24,__zero_reg__
 1880 093e 00C0      		rjmp .L191
 1881               		.loc 4 653 0 is_stmt 0 discriminator 1
 1882 0940 81E0      		ldi r24,lo8(1)
 1883 0942 00C0      		rjmp .L223
 1884               	.L191:
 654:main.c        **** 					else if (buffer_address == 1) {TWDR = crc;}
 1885               		.loc 4 654 0 is_stmt 1
 1886 0944 8130      		cpi r24,lo8(1)
 1887 0946 01F4      		brne .L194
 1888 0948 00C0      		rjmp .L231
 1889               	.L122:
 655:main.c        **** 					else                          {TWDR = 0xFF; i2cerror++;}
 656:main.c        **** 					break;
 657:main.c        **** 
 658:main.c        **** 				case 0x07:
 659:main.c        **** 					if (buffer_address == 0)  {TWDR = bllevel; if (crc_active) crc = _crc8_ccitt_update(crc,TWDR);
 1890               		.loc 4 659 0
 1891 094a 9111      		cpse r25,__zero_reg__
 1892 094c 00C0      		rjmp .L193
 1893               		.loc 4 659 0 is_stmt 0 discriminator 1
 1894 094e 8091 0000 		lds r24,bllevel
 1895 0952 8093 BB00 		sts 187,r24
 1896 0956 8091 0000 		lds r24,crc_active
 1897 095a 8823      		tst r24
 1898 095c 01F0      		breq .L143
 1899 095e 00C0      		rjmp .L226
 1900               	.L193:
 660:main.c        **** 					else if (buffer_address == 1)  {TWDR = crc;}
 1901               		.loc 4 660 0 is_stmt 1
 1902 0960 9130      		cpi r25,lo8(1)
 1903 0962 01F4      		brne .L194
 1904               	.L231:
 1905               		.loc 4 660 0 is_stmt 0 discriminator 1
 1906 0964 8091 0000 		lds r24,crc
 1907 0968 00C0      		rjmp .L222
 1908               	.L194:
 661:main.c        **** 					else     {TWDR = 0xFF; i2cerror++;}
 1909               		.loc 4 661 0 is_stmt 1
 1910 096a 8FEF      		ldi r24,lo8(-1)
 1911 096c 8093 BB00 		sts 187,r24
 1912               	.L224:
 1913 0970 8091 0000 		lds r24,i2cerror
 1914 0974 8F5F      		subi r24,lo8(-(1))
 1915 0976 8093 0000 		sts i2cerror,r24
 1916 097a 00C0      		rjmp .L143
 1917               	.L117:
 662:main.c        **** 
 663:main.c        **** 					break;
 664:main.c        **** 
 665:main.c        **** 				default: TWDR = 0xFF;
 1918               		.loc 4 665 0
 1919 097c 8FEF      		ldi r24,lo8(-1)
 1920               	.L222:
 1921 097e 8093 BB00 		sts 187,r24
 1922               	.L143:
 1923               	.LVL82:
 1924               	.LBB99:
 1925               	.LBB100:
 1926               		.loc 3 276 0
 1927 0982 85E3      		ldi r24,lo8(53)
 1928 0984 8A95      	1:	dec r24
 1929 0986 01F4      		brne 1b
 1930 0988 0000      		nop
 1931               	.LVL83:
 1932               	.LBE100:
 1933               	.LBE99:
 666:main.c        **** 
 667:main.c        **** 			}
 668:main.c        **** 
 669:main.c        **** 			_delay_us(10);
 670:main.c        **** 
 671:main.c        **** 			buffer_address++;
 1934               		.loc 4 671 0
 1935 098a 8091 0000 		lds r24,buffer_address
 1936 098e 8F5F      		subi r24,lo8(-(1))
 1937 0990 8093 0000 		sts buffer_address,r24
 1938 0994 00C0      		rjmp .L56
 1939               	.L59:
 672:main.c        **** 			TWCR = (1<<TWIE) | (1<<TWINT) | (1<<TWEA) | (1<<TWEN);
 673:main.c        **** 			break;
 674:main.c        **** 
 675:main.c        **** 		case TW_BUS_ERROR:
 676:main.c        **** 			TWCR =   (1<<TWSTO)|(1<<TWIE) | (1<<TWINT) | (1<<TWEA) | (1<<TWEN);
 1940               		.loc 4 676 0
 1941 0996 85ED      		ldi r24,lo8(-43)
 1942 0998 00C0      		rjmp .L227
 1943               	.L56:
 677:main.c        **** 			break;
 678:main.c        **** 
 679:main.c        **** 
 680:main.c        **** 		default: TWCR = (1<<TWEN)|(1<<TWIE)|(1<<TWINT)| (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|  (0<<TWWC);
 1944               		.loc 4 680 0
 1945 099a 85EC      		ldi r24,lo8(-59)
 1946               	.L227:
 1947 099c 8093 BC00 		sts 188,r24
 1948               	.L55:
 1949               	/* epilogue start */
 681:main.c        **** 
 682:main.c        **** 	}
 683:main.c        **** 
 684:main.c        **** }
 1950               		.loc 4 684 0
 1951 09a0 FF91      		pop r31
 1952 09a2 EF91      		pop r30
 1953 09a4 CF91      		pop r28
 1954 09a6 BF91      		pop r27
 1955 09a8 AF91      		pop r26
 1956 09aa 9F91      		pop r25
 1957 09ac 8F91      		pop r24
 1958 09ae 7F91      		pop r23
 1959 09b0 6F91      		pop r22
 1960 09b2 5F91      		pop r21
 1961 09b4 4F91      		pop r20
 1962 09b6 3F91      		pop r19
 1963 09b8 2F91      		pop r18
 1964 09ba 0F90      		pop r0
 1965 09bc 0FBE      		out __SREG__,r0
 1966 09be 0F90      		pop r0
 1967 09c0 1F90      		pop r1
 1968 09c2 1895      		reti
 1969               		.cfi_endproc
 1970               	.LFE35:
 1972               	.global	setup
 1974               	setup:
 1975               	.LFB36:
 685:main.c        **** 
 686:main.c        **** 
 687:main.c        **** void setup(void)
 688:main.c        **** {
 1976               		.loc 4 688 0
 1977               		.cfi_startproc
 1978 09c4 CF93      		push r28
 1979               	.LCFI29:
 1980               		.cfi_def_cfa_offset 3
 1981               		.cfi_offset 28, -2
 1982 09c6 DF93      		push r29
 1983               	.LCFI30:
 1984               		.cfi_def_cfa_offset 4
 1985               		.cfi_offset 29, -3
 1986               	/* prologue: function */
 1987               	/* frame size = 0 */
 1988               	/* stack size = 2 */
 1989               	.L__stack_usage = 2
 689:main.c        **** 
 690:main.c        **** 	DDRF = 0b00000000;
 1990               		.loc 4 690 0
 1991 09c8 10BA      		out 0x10,__zero_reg__
 691:main.c        **** 	DDRD = 0b01111011;
 1992               		.loc 4 691 0
 1993 09ca 8BE7      		ldi r24,lo8(123)
 1994 09cc 8AB9      		out 0xa,r24
 692:main.c        **** 	PORTD= 0b00000000;
 1995               		.loc 4 692 0
 1996 09ce 1BB8      		out 0xb,__zero_reg__
 693:main.c        **** 	DDRE = 0b00000000;			 // DDRE |= (1<<2);   be carefull with hwb, check if its connected to GND via
 1997               		.loc 4 693 0
 1998 09d0 1DB8      		out 0xd,__zero_reg__
 694:main.c        **** 	DDRB = 0b11110110;
 1999               		.loc 4 694 0
 2000 09d2 86EF      		ldi r24,lo8(-10)
 2001 09d4 84B9      		out 0x4,r24
 695:main.c        **** 	DDRC = 0b11000000;
 2002               		.loc 4 695 0
 2003 09d6 80EC      		ldi r24,lo8(-64)
 2004 09d8 87B9      		out 0x7,r24
 696:main.c        **** 	OCR0A = 0;					 //    start value for FAN  0 / 255  (-> p-channel so inverted)       0x00 is ON  0
 2005               		.loc 4 696 0
 2006 09da 17BC      		out 0x27,__zero_reg__
 697:main.c        **** 	TCCR0B  =  0b00000001;
 2007               		.loc 4 697 0
 2008 09dc 81E0      		ldi r24,lo8(1)
 2009 09de 85BD      		out 0x25,r24
 698:main.c        **** 	TCCR0A  =  0b10000011;		 // 8bit  62khz
 2010               		.loc 4 698 0
 2011 09e0 83E8      		ldi r24,lo8(-125)
 2012 09e2 84BD      		out 0x24,r24
 699:main.c        **** 	TIMSK0 |= (1 << TOIE0);		 // init interrupt for timer0 overflow
 2013               		.loc 4 699 0
 2014 09e4 EEE6      		ldi r30,lo8(110)
 2015 09e6 F0E0      		ldi r31,0
 2016 09e8 8081      		ld r24,Z
 2017 09ea 8160      		ori r24,lo8(1)
 2018 09ec 8083      		st Z,r24
 2019               	.LVL84:
 2020               	.LBB101:
 2021               	.LBB102:
 2022               		.file 5 "/usr/lib/avr/include/avr/power.h"
   1:/usr/lib/avr/include/avr/power.h **** /* Copyright (c) 2006, 2007, 2008  Eric B. Weddington
   2:/usr/lib/avr/include/avr/power.h ****    Copyright (c) 2011 Frdric Nadeau
   3:/usr/lib/avr/include/avr/power.h ****    All rights reserved.
   4:/usr/lib/avr/include/avr/power.h **** 
   5:/usr/lib/avr/include/avr/power.h ****    Redistribution and use in source and binary forms, with or without
   6:/usr/lib/avr/include/avr/power.h ****    modification, are permitted provided that the following conditions are met:
   7:/usr/lib/avr/include/avr/power.h **** 
   8:/usr/lib/avr/include/avr/power.h ****    * Redistributions of source code must retain the above copyright
   9:/usr/lib/avr/include/avr/power.h ****      notice, this list of conditions and the following disclaimer.
  10:/usr/lib/avr/include/avr/power.h ****    * Redistributions in binary form must reproduce the above copyright
  11:/usr/lib/avr/include/avr/power.h ****      notice, this list of conditions and the following disclaimer in
  12:/usr/lib/avr/include/avr/power.h ****      the documentation and/or other materials provided with the
  13:/usr/lib/avr/include/avr/power.h ****      distribution.
  14:/usr/lib/avr/include/avr/power.h ****    * Neither the name of the copyright holders nor the names of
  15:/usr/lib/avr/include/avr/power.h ****      contributors may be used to endorse or promote products derived
  16:/usr/lib/avr/include/avr/power.h ****      from this software without specific prior written permission.
  17:/usr/lib/avr/include/avr/power.h **** 
  18:/usr/lib/avr/include/avr/power.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  19:/usr/lib/avr/include/avr/power.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  20:/usr/lib/avr/include/avr/power.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  21:/usr/lib/avr/include/avr/power.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  22:/usr/lib/avr/include/avr/power.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  23:/usr/lib/avr/include/avr/power.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  24:/usr/lib/avr/include/avr/power.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  25:/usr/lib/avr/include/avr/power.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  26:/usr/lib/avr/include/avr/power.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  27:/usr/lib/avr/include/avr/power.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  28:/usr/lib/avr/include/avr/power.h ****   POSSIBILITY OF SUCH DAMAGE. */
  29:/usr/lib/avr/include/avr/power.h **** 
  30:/usr/lib/avr/include/avr/power.h **** /* $Id$ */
  31:/usr/lib/avr/include/avr/power.h **** 
  32:/usr/lib/avr/include/avr/power.h **** #ifndef _AVR_POWER_H_
  33:/usr/lib/avr/include/avr/power.h **** #define _AVR_POWER_H_   1
  34:/usr/lib/avr/include/avr/power.h **** 
  35:/usr/lib/avr/include/avr/power.h **** #include <avr/io.h>
  36:/usr/lib/avr/include/avr/power.h **** #include <stdint.h>
  37:/usr/lib/avr/include/avr/power.h **** 
  38:/usr/lib/avr/include/avr/power.h **** 
  39:/usr/lib/avr/include/avr/power.h **** /** \file */
  40:/usr/lib/avr/include/avr/power.h **** /** \defgroup avr_power <avr/power.h>: Power Reduction Management
  41:/usr/lib/avr/include/avr/power.h **** 
  42:/usr/lib/avr/include/avr/power.h **** \code #include <avr/power.h>\endcode
  43:/usr/lib/avr/include/avr/power.h **** 
  44:/usr/lib/avr/include/avr/power.h **** Many AVRs contain a Power Reduction Register (PRR) or Registers (PRRx) that 
  45:/usr/lib/avr/include/avr/power.h **** allow you to reduce power consumption by disabling or enabling various on-board 
  46:/usr/lib/avr/include/avr/power.h **** peripherals as needed. Some devices have the XTAL Divide Control Register
  47:/usr/lib/avr/include/avr/power.h **** (XDIV) which offer similar functionality as System Clock Prescale
  48:/usr/lib/avr/include/avr/power.h **** Register (CLKPR).
  49:/usr/lib/avr/include/avr/power.h **** 
  50:/usr/lib/avr/include/avr/power.h **** There are many macros in this header file that provide an easy interface
  51:/usr/lib/avr/include/avr/power.h **** to enable or disable on-board peripherals to reduce power. See the table below.
  52:/usr/lib/avr/include/avr/power.h **** 
  53:/usr/lib/avr/include/avr/power.h **** \note Not all AVR devices have a Power Reduction Register (for example
  54:/usr/lib/avr/include/avr/power.h **** the ATmega8). On those devices without a Power Reduction Register, the
  55:/usr/lib/avr/include/avr/power.h **** power reduction macros are not available..
  56:/usr/lib/avr/include/avr/power.h **** 
  57:/usr/lib/avr/include/avr/power.h **** \note Not all AVR devices contain the same peripherals (for example, the LCD
  58:/usr/lib/avr/include/avr/power.h **** interface), or they will be named differently (for example, USART and 
  59:/usr/lib/avr/include/avr/power.h **** USART0). Please consult your device's datasheet, or the header file, to 
  60:/usr/lib/avr/include/avr/power.h **** find out which macros are applicable to your device.
  61:/usr/lib/avr/include/avr/power.h **** 
  62:/usr/lib/avr/include/avr/power.h **** \note For device using the XTAL Divide Control Register (XDIV), when prescaler
  63:/usr/lib/avr/include/avr/power.h **** is used, Timer/Counter0 can only be used in asynchronous mode. Keep in mind
  64:/usr/lib/avr/include/avr/power.h **** that Timer/Counter0 source shall be less than th of peripheral clock.
  65:/usr/lib/avr/include/avr/power.h **** Therefore, when using a typical 32.768 kHz crystal, one shall not scale
  66:/usr/lib/avr/include/avr/power.h **** the clock below 131.072 kHz.
  67:/usr/lib/avr/include/avr/power.h **** 
  68:/usr/lib/avr/include/avr/power.h **** */
  69:/usr/lib/avr/include/avr/power.h **** 
  70:/usr/lib/avr/include/avr/power.h **** 
  71:/usr/lib/avr/include/avr/power.h **** /** \addtogroup avr_power
  72:/usr/lib/avr/include/avr/power.h **** 
  73:/usr/lib/avr/include/avr/power.h **** \anchor avr_powermacros
  74:/usr/lib/avr/include/avr/power.h **** <small>
  75:/usr/lib/avr/include/avr/power.h **** <center>
  76:/usr/lib/avr/include/avr/power.h **** <table border="3">
  77:/usr/lib/avr/include/avr/power.h ****   <tr>
  78:/usr/lib/avr/include/avr/power.h ****     <td width="10%"><strong>Power Macro</strong></td>
  79:/usr/lib/avr/include/avr/power.h ****     <td width="15%"><strong>Description</strong></td>
  80:/usr/lib/avr/include/avr/power.h ****   </tr>
  81:/usr/lib/avr/include/avr/power.h **** 
  82:/usr/lib/avr/include/avr/power.h ****   <tr>
  83:/usr/lib/avr/include/avr/power.h ****     <td>power_aca_disable()</td>
  84:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Analog Comparator on PortA.</td>
  85:/usr/lib/avr/include/avr/power.h ****   </tr>
  86:/usr/lib/avr/include/avr/power.h **** 
  87:/usr/lib/avr/include/avr/power.h ****   <tr>
  88:/usr/lib/avr/include/avr/power.h ****     <td>power_aca_enable()</td>
  89:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Analog Comparator on PortA.</td>
  90:/usr/lib/avr/include/avr/power.h ****   </tr>
  91:/usr/lib/avr/include/avr/power.h **** 
  92:/usr/lib/avr/include/avr/power.h ****   <tr>
  93:/usr/lib/avr/include/avr/power.h ****     <td>power_adc_enable()</td>
  94:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Analog to Digital Converter module.</td>
  95:/usr/lib/avr/include/avr/power.h ****   </tr>
  96:/usr/lib/avr/include/avr/power.h **** 
  97:/usr/lib/avr/include/avr/power.h ****   <tr>
  98:/usr/lib/avr/include/avr/power.h ****     <td>power_adc_disable()</td>
  99:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Analog to Digital Converter module.</td>
 100:/usr/lib/avr/include/avr/power.h ****   </tr>
 101:/usr/lib/avr/include/avr/power.h **** 
 102:/usr/lib/avr/include/avr/power.h ****   <tr>
 103:/usr/lib/avr/include/avr/power.h ****     <td>power_adca_disable()</td>
 104:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Analog to Digital Converter module on PortA</td>
 105:/usr/lib/avr/include/avr/power.h ****   </tr>
 106:/usr/lib/avr/include/avr/power.h **** 
 107:/usr/lib/avr/include/avr/power.h ****   <tr>
 108:/usr/lib/avr/include/avr/power.h ****     <td>power_adca_enable()</td>
 109:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Analog to Digital Converter module on PortA</td>
 110:/usr/lib/avr/include/avr/power.h ****   </tr>
 111:/usr/lib/avr/include/avr/power.h **** 
 112:/usr/lib/avr/include/avr/power.h ****   <tr>
 113:/usr/lib/avr/include/avr/power.h ****     <td>power_evsys_disable()</td>
 114:/usr/lib/avr/include/avr/power.h ****     <td>Disable the EVSYS module</td>
 115:/usr/lib/avr/include/avr/power.h ****   </tr>
 116:/usr/lib/avr/include/avr/power.h **** 
 117:/usr/lib/avr/include/avr/power.h ****   <tr>
 118:/usr/lib/avr/include/avr/power.h ****     <td>power_evsys_enable()</td>
 119:/usr/lib/avr/include/avr/power.h ****     <td>Enable the EVSYS module</td>
 120:/usr/lib/avr/include/avr/power.h ****   </tr>
 121:/usr/lib/avr/include/avr/power.h **** 
 122:/usr/lib/avr/include/avr/power.h ****   <tr>
 123:/usr/lib/avr/include/avr/power.h ****     <td>power_hiresc_disable()</td>
 124:/usr/lib/avr/include/avr/power.h ****     <td>Disable the HIRES module on PortC</td>
 125:/usr/lib/avr/include/avr/power.h ****   </tr>
 126:/usr/lib/avr/include/avr/power.h **** 
 127:/usr/lib/avr/include/avr/power.h ****   <tr>
 128:/usr/lib/avr/include/avr/power.h ****     <td>power_hiresc_enable()</td>
 129:/usr/lib/avr/include/avr/power.h ****     <td>Enable the HIRES module on PortC</td>
 130:/usr/lib/avr/include/avr/power.h ****   </tr>
 131:/usr/lib/avr/include/avr/power.h **** 
 132:/usr/lib/avr/include/avr/power.h ****    <tr>
 133:/usr/lib/avr/include/avr/power.h ****     <td>power_lcd_enable()</td>
 134:/usr/lib/avr/include/avr/power.h ****     <td>Enable the LCD module.</td>
 135:/usr/lib/avr/include/avr/power.h ****   </tr>
 136:/usr/lib/avr/include/avr/power.h **** 
 137:/usr/lib/avr/include/avr/power.h ****   <tr>
 138:/usr/lib/avr/include/avr/power.h ****     <td>power_lcd_disable().</td>
 139:/usr/lib/avr/include/avr/power.h ****     <td>Disable the LCD module.</td>
 140:/usr/lib/avr/include/avr/power.h ****   </tr>
 141:/usr/lib/avr/include/avr/power.h **** 
 142:/usr/lib/avr/include/avr/power.h ****   <tr>
 143:/usr/lib/avr/include/avr/power.h ****     <td>power_pga_enable()</td>
 144:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Programmable Gain Amplifier module.</td>
 145:/usr/lib/avr/include/avr/power.h ****   </tr>
 146:/usr/lib/avr/include/avr/power.h **** 
 147:/usr/lib/avr/include/avr/power.h ****   <tr>
 148:/usr/lib/avr/include/avr/power.h ****     <td>power_pga_disable()</td>
 149:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Programmable Gain Amplifier module.</td>
 150:/usr/lib/avr/include/avr/power.h ****   </tr>
 151:/usr/lib/avr/include/avr/power.h ****   
 152:/usr/lib/avr/include/avr/power.h ****   <tr>
 153:/usr/lib/avr/include/avr/power.h ****     <td>power_pscr_enable()</td>
 154:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Reduced Power Stage Controller module.</td>
 155:/usr/lib/avr/include/avr/power.h ****   </tr>
 156:/usr/lib/avr/include/avr/power.h **** 
 157:/usr/lib/avr/include/avr/power.h ****   <tr>
 158:/usr/lib/avr/include/avr/power.h ****     <td>power_pscr_disable()</td>
 159:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Reduced Power Stage Controller module.</td>
 160:/usr/lib/avr/include/avr/power.h ****   </tr>
 161:/usr/lib/avr/include/avr/power.h **** 
 162:/usr/lib/avr/include/avr/power.h ****   <tr>
 163:/usr/lib/avr/include/avr/power.h ****     <td>power_psc0_enable()</td>
 164:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Power Stage Controller 0 module.</td>
 165:/usr/lib/avr/include/avr/power.h ****   </tr>
 166:/usr/lib/avr/include/avr/power.h **** 
 167:/usr/lib/avr/include/avr/power.h ****   <tr>
 168:/usr/lib/avr/include/avr/power.h ****     <td>power_psc0_disable()</td>
 169:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Power Stage Controller 0 module.</td>
 170:/usr/lib/avr/include/avr/power.h ****   </tr>
 171:/usr/lib/avr/include/avr/power.h **** 
 172:/usr/lib/avr/include/avr/power.h ****   <tr>
 173:/usr/lib/avr/include/avr/power.h ****     <td>power_psc1_enable()</td>
 174:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Power Stage Controller 1 module.</td>
 175:/usr/lib/avr/include/avr/power.h ****   </tr>
 176:/usr/lib/avr/include/avr/power.h **** 
 177:/usr/lib/avr/include/avr/power.h ****   <tr>
 178:/usr/lib/avr/include/avr/power.h ****     <td>power_psc1_disable()</td>
 179:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Power Stage Controller 1 module.</td>
 180:/usr/lib/avr/include/avr/power.h ****   </tr>
 181:/usr/lib/avr/include/avr/power.h **** 
 182:/usr/lib/avr/include/avr/power.h ****   <tr>
 183:/usr/lib/avr/include/avr/power.h ****     <td>power_psc2_enable()</td>
 184:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Power Stage Controller 2 module.</td>
 185:/usr/lib/avr/include/avr/power.h ****   </tr>
 186:/usr/lib/avr/include/avr/power.h **** 
 187:/usr/lib/avr/include/avr/power.h ****   <tr>
 188:/usr/lib/avr/include/avr/power.h ****     <td>power_psc2_disable()</td>
 189:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Power Stage Controller 2 module.</td>
 190:/usr/lib/avr/include/avr/power.h ****   </tr>
 191:/usr/lib/avr/include/avr/power.h **** 
 192:/usr/lib/avr/include/avr/power.h ****   <tr>
 193:/usr/lib/avr/include/avr/power.h ****     <td>power_ram0_enable()</td>
 194:/usr/lib/avr/include/avr/power.h ****     <td>Enable the SRAM block 0 .</td>
 195:/usr/lib/avr/include/avr/power.h ****   </tr>
 196:/usr/lib/avr/include/avr/power.h **** 
 197:/usr/lib/avr/include/avr/power.h ****   <tr>
 198:/usr/lib/avr/include/avr/power.h ****     <td>power_ram0_disable()</td>
 199:/usr/lib/avr/include/avr/power.h ****     <td>Disable the SRAM block 0. </td>
 200:/usr/lib/avr/include/avr/power.h ****   </tr>
 201:/usr/lib/avr/include/avr/power.h **** 
 202:/usr/lib/avr/include/avr/power.h ****   <tr>
 203:/usr/lib/avr/include/avr/power.h ****     <td>power_ram1_enable()</td>
 204:/usr/lib/avr/include/avr/power.h ****     <td>Enable the SRAM block 1 .</td>
 205:/usr/lib/avr/include/avr/power.h ****   </tr>
 206:/usr/lib/avr/include/avr/power.h **** 
 207:/usr/lib/avr/include/avr/power.h ****   <tr>
 208:/usr/lib/avr/include/avr/power.h ****     <td>power_ram1_disable()</td>
 209:/usr/lib/avr/include/avr/power.h ****     <td>Disable the SRAM block 1. </td>
 210:/usr/lib/avr/include/avr/power.h ****   </tr>
 211:/usr/lib/avr/include/avr/power.h **** 
 212:/usr/lib/avr/include/avr/power.h ****   <tr>
 213:/usr/lib/avr/include/avr/power.h ****     <td>power_ram2_enable()</td>
 214:/usr/lib/avr/include/avr/power.h ****     <td>Enable the SRAM block 2 .</td>
 215:/usr/lib/avr/include/avr/power.h ****   </tr>
 216:/usr/lib/avr/include/avr/power.h **** 
 217:/usr/lib/avr/include/avr/power.h ****   <tr>
 218:/usr/lib/avr/include/avr/power.h ****     <td>power_ram2_disable()</td>
 219:/usr/lib/avr/include/avr/power.h ****     <td>Disable the SRAM block 2. </td>
 220:/usr/lib/avr/include/avr/power.h ****   </tr>
 221:/usr/lib/avr/include/avr/power.h **** 
 222:/usr/lib/avr/include/avr/power.h ****   <tr>
 223:/usr/lib/avr/include/avr/power.h ****     <td>power_ram3_enable()</td>
 224:/usr/lib/avr/include/avr/power.h ****     <td>Enable the SRAM block 3 .</td>
 225:/usr/lib/avr/include/avr/power.h ****   </tr>
 226:/usr/lib/avr/include/avr/power.h **** 
 227:/usr/lib/avr/include/avr/power.h ****   <tr>
 228:/usr/lib/avr/include/avr/power.h ****     <td>power_ram3_disable()</td>
 229:/usr/lib/avr/include/avr/power.h ****     <td>Disable the SRAM block 3. </td>
 230:/usr/lib/avr/include/avr/power.h ****   </tr>
 231:/usr/lib/avr/include/avr/power.h **** 
 232:/usr/lib/avr/include/avr/power.h ****   <tr>
 233:/usr/lib/avr/include/avr/power.h ****     <td>power_rtc_disable()</td>
 234:/usr/lib/avr/include/avr/power.h ****     <td>Disable the RTC module</td>
 235:/usr/lib/avr/include/avr/power.h ****   </tr>
 236:/usr/lib/avr/include/avr/power.h **** 
 237:/usr/lib/avr/include/avr/power.h ****   <tr>
 238:/usr/lib/avr/include/avr/power.h ****     <td>power_rtc_enable()</td>
 239:/usr/lib/avr/include/avr/power.h ****     <td>Enable the RTC module</td>
 240:/usr/lib/avr/include/avr/power.h ****   </tr>
 241:/usr/lib/avr/include/avr/power.h **** 
 242:/usr/lib/avr/include/avr/power.h ****   <tr>
 243:/usr/lib/avr/include/avr/power.h ****     <td>power_spi_enable()</td>
 244:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Serial Peripheral Interface module.</td>
 245:/usr/lib/avr/include/avr/power.h ****   </tr>
 246:/usr/lib/avr/include/avr/power.h **** 
 247:/usr/lib/avr/include/avr/power.h ****   <tr>
 248:/usr/lib/avr/include/avr/power.h ****     <td>power_spi_disable()</td>
 249:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Serial Peripheral Interface module.</td>
 250:/usr/lib/avr/include/avr/power.h ****   </tr>
 251:/usr/lib/avr/include/avr/power.h **** 
 252:/usr/lib/avr/include/avr/power.h ****   <tr>
 253:/usr/lib/avr/include/avr/power.h ****     <td>power_spic_disable()</td>
 254:/usr/lib/avr/include/avr/power.h ****     <td>Disable the SPI module on PortC</td>
 255:/usr/lib/avr/include/avr/power.h ****   </tr>
 256:/usr/lib/avr/include/avr/power.h **** 
 257:/usr/lib/avr/include/avr/power.h ****   <tr>
 258:/usr/lib/avr/include/avr/power.h ****     <td>power_spic_enable()</td>
 259:/usr/lib/avr/include/avr/power.h ****     <td>Enable the SPI module on PortC</td>
 260:/usr/lib/avr/include/avr/power.h ****   </tr>
 261:/usr/lib/avr/include/avr/power.h **** 
 262:/usr/lib/avr/include/avr/power.h ****   <tr>
 263:/usr/lib/avr/include/avr/power.h ****     <td>power_spid_disable()</td>
 264:/usr/lib/avr/include/avr/power.h ****     <td>Disable the SPI module on PortD</td>
 265:/usr/lib/avr/include/avr/power.h ****   </tr>
 266:/usr/lib/avr/include/avr/power.h **** 
 267:/usr/lib/avr/include/avr/power.h ****   <tr>
 268:/usr/lib/avr/include/avr/power.h ****     <td>power_spid_enable()</td>
 269:/usr/lib/avr/include/avr/power.h ****     <td>Enable the SPI module on PortD</td>
 270:/usr/lib/avr/include/avr/power.h ****   </tr>
 271:/usr/lib/avr/include/avr/power.h **** 
 272:/usr/lib/avr/include/avr/power.h ****   <tr>
 273:/usr/lib/avr/include/avr/power.h ****     <td>power_tc0c_disable()</td>
 274:/usr/lib/avr/include/avr/power.h ****     <td>Disable the TC0 module on PortC</td>
 275:/usr/lib/avr/include/avr/power.h ****   </tr>
 276:/usr/lib/avr/include/avr/power.h **** 
 277:/usr/lib/avr/include/avr/power.h ****   <tr>
 278:/usr/lib/avr/include/avr/power.h ****     <td>power_tc0c_enable()</td>
 279:/usr/lib/avr/include/avr/power.h ****     <td>Enable the TC0 module on PortC</td>
 280:/usr/lib/avr/include/avr/power.h ****   </tr>
 281:/usr/lib/avr/include/avr/power.h **** 
 282:/usr/lib/avr/include/avr/power.h ****   <tr>
 283:/usr/lib/avr/include/avr/power.h ****     <td>power_tc0d_disable()</td>
 284:/usr/lib/avr/include/avr/power.h ****     <td>Disable the TC0 module on PortD</td>
 285:/usr/lib/avr/include/avr/power.h ****   </tr>
 286:/usr/lib/avr/include/avr/power.h **** 
 287:/usr/lib/avr/include/avr/power.h ****   <tr>
 288:/usr/lib/avr/include/avr/power.h ****     <td>power_tc0d_enable()</td>
 289:/usr/lib/avr/include/avr/power.h ****     <td>Enable the TC0 module on PortD</td>
 290:/usr/lib/avr/include/avr/power.h ****   </tr>
 291:/usr/lib/avr/include/avr/power.h **** 
 292:/usr/lib/avr/include/avr/power.h ****   <tr>
 293:/usr/lib/avr/include/avr/power.h ****     <td>power_tc0e_disable()</td>
 294:/usr/lib/avr/include/avr/power.h ****     <td>Disable the TC0 module on PortE</td>
 295:/usr/lib/avr/include/avr/power.h ****   </tr>
 296:/usr/lib/avr/include/avr/power.h **** 
 297:/usr/lib/avr/include/avr/power.h ****   <tr>
 298:/usr/lib/avr/include/avr/power.h ****     <td>power_tc0e_enable()</td>
 299:/usr/lib/avr/include/avr/power.h ****     <td>Enable the TC0 module on PortE</td>
 300:/usr/lib/avr/include/avr/power.h ****   </tr>
 301:/usr/lib/avr/include/avr/power.h **** 
 302:/usr/lib/avr/include/avr/power.h ****   <tr>
 303:/usr/lib/avr/include/avr/power.h ****     <td>power_tc0f_disable()</td>
 304:/usr/lib/avr/include/avr/power.h ****     <td>Disable the TC0 module on PortF</td>
 305:/usr/lib/avr/include/avr/power.h ****   </tr>
 306:/usr/lib/avr/include/avr/power.h **** 
 307:/usr/lib/avr/include/avr/power.h ****   <tr>
 308:/usr/lib/avr/include/avr/power.h ****     <td>power_tc0f_enable()</td>
 309:/usr/lib/avr/include/avr/power.h ****     <td>Enable the TC0 module on PortF</td>
 310:/usr/lib/avr/include/avr/power.h ****   </tr>
 311:/usr/lib/avr/include/avr/power.h **** 
 312:/usr/lib/avr/include/avr/power.h ****   <tr>
 313:/usr/lib/avr/include/avr/power.h ****     <td>power_tc1c_disable()</td>
 314:/usr/lib/avr/include/avr/power.h ****     <td>Disable the TC1 module on PortC</td>
 315:/usr/lib/avr/include/avr/power.h ****   </tr>
 316:/usr/lib/avr/include/avr/power.h **** 
 317:/usr/lib/avr/include/avr/power.h ****   <tr>
 318:/usr/lib/avr/include/avr/power.h ****     <td>power_tc1c_enable()</td>
 319:/usr/lib/avr/include/avr/power.h ****     <td>Enable the TC1 module on PortC</td>
 320:/usr/lib/avr/include/avr/power.h ****   </tr>
 321:/usr/lib/avr/include/avr/power.h **** 
 322:/usr/lib/avr/include/avr/power.h ****   <tr>
 323:/usr/lib/avr/include/avr/power.h ****     <td>power_twic_disable()</td>
 324:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Two Wire Interface module on PortC</td>
 325:/usr/lib/avr/include/avr/power.h ****   </tr>
 326:/usr/lib/avr/include/avr/power.h **** 
 327:/usr/lib/avr/include/avr/power.h ****   <tr>
 328:/usr/lib/avr/include/avr/power.h ****     <td>power_twic_enable()</td>
 329:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Two Wire Interface module on PortC</td>
 330:/usr/lib/avr/include/avr/power.h ****   </tr>
 331:/usr/lib/avr/include/avr/power.h **** 
 332:/usr/lib/avr/include/avr/power.h ****   <tr>
 333:/usr/lib/avr/include/avr/power.h ****     <td>power_twie_disable()</td>
 334:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Two Wire Interface module on PortE</td>
 335:/usr/lib/avr/include/avr/power.h ****   </tr>
 336:/usr/lib/avr/include/avr/power.h **** 
 337:/usr/lib/avr/include/avr/power.h ****   <tr>
 338:/usr/lib/avr/include/avr/power.h ****     <td>power_twie_enable()</td>
 339:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Two Wire Interface module on PortE</td>
 340:/usr/lib/avr/include/avr/power.h ****   </tr>
 341:/usr/lib/avr/include/avr/power.h **** 
 342:/usr/lib/avr/include/avr/power.h ****   <tr>
 343:/usr/lib/avr/include/avr/power.h ****     <td>power_timer0_enable()</td>
 344:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Timer 0 module.</td>
 345:/usr/lib/avr/include/avr/power.h ****   </tr>
 346:/usr/lib/avr/include/avr/power.h **** 
 347:/usr/lib/avr/include/avr/power.h ****   <tr>
 348:/usr/lib/avr/include/avr/power.h ****     <td>power_timer0_disable()</td>
 349:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Timer 0 module.</td>
 350:/usr/lib/avr/include/avr/power.h ****   </tr>
 351:/usr/lib/avr/include/avr/power.h **** 
 352:/usr/lib/avr/include/avr/power.h ****   <tr>
 353:/usr/lib/avr/include/avr/power.h ****     <td>power_timer1_enable()</td>
 354:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Timer 1 module.</td>
 355:/usr/lib/avr/include/avr/power.h ****   </tr>
 356:/usr/lib/avr/include/avr/power.h **** 
 357:/usr/lib/avr/include/avr/power.h ****   <tr>
 358:/usr/lib/avr/include/avr/power.h ****     <td>power_timer1_disable()</td>
 359:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Timer 1 module.</td>
 360:/usr/lib/avr/include/avr/power.h ****   </tr>
 361:/usr/lib/avr/include/avr/power.h **** 
 362:/usr/lib/avr/include/avr/power.h ****   <tr>
 363:/usr/lib/avr/include/avr/power.h ****     <td>power_timer2_enable()</td>
 364:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Timer 2 module.</td>
 365:/usr/lib/avr/include/avr/power.h ****   </tr>
 366:/usr/lib/avr/include/avr/power.h **** 
 367:/usr/lib/avr/include/avr/power.h ****   <tr>
 368:/usr/lib/avr/include/avr/power.h ****     <td>power_timer2_disable()</td>
 369:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Timer 2 module.</td>
 370:/usr/lib/avr/include/avr/power.h ****   </tr>
 371:/usr/lib/avr/include/avr/power.h **** 
 372:/usr/lib/avr/include/avr/power.h ****   <tr>
 373:/usr/lib/avr/include/avr/power.h ****     <td>power_timer3_enable()</td>
 374:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Timer 3 module.</td>
 375:/usr/lib/avr/include/avr/power.h ****   </tr>
 376:/usr/lib/avr/include/avr/power.h **** 
 377:/usr/lib/avr/include/avr/power.h ****   <tr>
 378:/usr/lib/avr/include/avr/power.h ****     <td>power_timer3_disable()</td>
 379:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Timer 3 module.</td>
 380:/usr/lib/avr/include/avr/power.h ****   </tr>
 381:/usr/lib/avr/include/avr/power.h **** 
 382:/usr/lib/avr/include/avr/power.h ****   <tr>
 383:/usr/lib/avr/include/avr/power.h ****     <td>power_timer4_enable()</td>
 384:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Timer 4 module.</td>
 385:/usr/lib/avr/include/avr/power.h ****   </tr>
 386:/usr/lib/avr/include/avr/power.h **** 
 387:/usr/lib/avr/include/avr/power.h ****   <tr>
 388:/usr/lib/avr/include/avr/power.h ****     <td>power_timer4_disable()</td>
 389:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Timer 4 module.</td>
 390:/usr/lib/avr/include/avr/power.h ****   </tr>
 391:/usr/lib/avr/include/avr/power.h **** 
 392:/usr/lib/avr/include/avr/power.h ****   <tr>
 393:/usr/lib/avr/include/avr/power.h ****     <td>power_timer5_enable()</td>
 394:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Timer 5 module.</td>
 395:/usr/lib/avr/include/avr/power.h ****   </tr>
 396:/usr/lib/avr/include/avr/power.h **** 
 397:/usr/lib/avr/include/avr/power.h ****   <tr>
 398:/usr/lib/avr/include/avr/power.h ****     <td>power_timer5_disable()</td>
 399:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Timer 5 module.</td>
 400:/usr/lib/avr/include/avr/power.h ****   </tr>
 401:/usr/lib/avr/include/avr/power.h **** 
 402:/usr/lib/avr/include/avr/power.h ****   <tr>
 403:/usr/lib/avr/include/avr/power.h ****     <td>power_twi_enable()</td>
 404:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Two Wire Interface module.</td>
 405:/usr/lib/avr/include/avr/power.h ****   </tr>
 406:/usr/lib/avr/include/avr/power.h **** 
 407:/usr/lib/avr/include/avr/power.h ****   <tr>
 408:/usr/lib/avr/include/avr/power.h ****     <td>power_twi_disable()</td>
 409:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Two Wire Interface module.</td>
 410:/usr/lib/avr/include/avr/power.h ****   </tr>
 411:/usr/lib/avr/include/avr/power.h **** 
 412:/usr/lib/avr/include/avr/power.h ****   <tr>
 413:/usr/lib/avr/include/avr/power.h ****     <td>power_usart_enable()</td>
 414:/usr/lib/avr/include/avr/power.h ****     <td>Enable the USART module.</td>
 415:/usr/lib/avr/include/avr/power.h ****   </tr>
 416:/usr/lib/avr/include/avr/power.h **** 
 417:/usr/lib/avr/include/avr/power.h ****   <tr>
 418:/usr/lib/avr/include/avr/power.h ****     <td>power_usart_disable()</td>
 419:/usr/lib/avr/include/avr/power.h ****     <td>Disable the USART module.</td>
 420:/usr/lib/avr/include/avr/power.h ****   </tr>
 421:/usr/lib/avr/include/avr/power.h **** 
 422:/usr/lib/avr/include/avr/power.h ****   <tr>
 423:/usr/lib/avr/include/avr/power.h ****     <td>power_usart0_enable()</td>
 424:/usr/lib/avr/include/avr/power.h ****     <td>Enable the USART 0 module.</td>
 425:/usr/lib/avr/include/avr/power.h ****   </tr>
 426:/usr/lib/avr/include/avr/power.h **** 
 427:/usr/lib/avr/include/avr/power.h ****   <tr>
 428:/usr/lib/avr/include/avr/power.h ****     <td>power_usart0_disable()</td>
 429:/usr/lib/avr/include/avr/power.h ****     <td>Disable the USART 0 module.</td>
 430:/usr/lib/avr/include/avr/power.h ****   </tr>
 431:/usr/lib/avr/include/avr/power.h **** 
 432:/usr/lib/avr/include/avr/power.h ****   <tr>
 433:/usr/lib/avr/include/avr/power.h ****     <td>power_usart1_enable()</td>
 434:/usr/lib/avr/include/avr/power.h ****     <td>Enable the USART 1 module.</td>
 435:/usr/lib/avr/include/avr/power.h ****   </tr>
 436:/usr/lib/avr/include/avr/power.h **** 
 437:/usr/lib/avr/include/avr/power.h ****   <tr>
 438:/usr/lib/avr/include/avr/power.h ****     <td>power_usart1_disable()</td>
 439:/usr/lib/avr/include/avr/power.h ****     <td>Disable the USART 1 module.</td>
 440:/usr/lib/avr/include/avr/power.h ****   </tr>
 441:/usr/lib/avr/include/avr/power.h **** 
 442:/usr/lib/avr/include/avr/power.h ****   <tr>
 443:/usr/lib/avr/include/avr/power.h ****     <td>power_usart2_enable()</td>
 444:/usr/lib/avr/include/avr/power.h ****     <td>Enable the USART 2 module.</td>
 445:/usr/lib/avr/include/avr/power.h ****   </tr>
 446:/usr/lib/avr/include/avr/power.h **** 
 447:/usr/lib/avr/include/avr/power.h ****   <tr>
 448:/usr/lib/avr/include/avr/power.h ****     <td>power_usart2_disable()</td>
 449:/usr/lib/avr/include/avr/power.h ****     <td>Disable the USART 2 module.</td>
 450:/usr/lib/avr/include/avr/power.h ****   </tr>
 451:/usr/lib/avr/include/avr/power.h **** 
 452:/usr/lib/avr/include/avr/power.h ****   <tr>
 453:/usr/lib/avr/include/avr/power.h ****     <td>power_usart3_enable()</td>
 454:/usr/lib/avr/include/avr/power.h ****     <td>Enable the USART 3 module.</td>
 455:/usr/lib/avr/include/avr/power.h ****   </tr>
 456:/usr/lib/avr/include/avr/power.h **** 
 457:/usr/lib/avr/include/avr/power.h ****   <tr>
 458:/usr/lib/avr/include/avr/power.h ****     <td>power_usart3_disable()</td>
 459:/usr/lib/avr/include/avr/power.h ****     <td>Disable the USART 3 module.</td>
 460:/usr/lib/avr/include/avr/power.h ****   </tr>
 461:/usr/lib/avr/include/avr/power.h **** 
 462:/usr/lib/avr/include/avr/power.h ****   <tr>
 463:/usr/lib/avr/include/avr/power.h ****     <td>power_usartc0_disable()</td>
 464:/usr/lib/avr/include/avr/power.h ****     <td> Disable the USART0 module on PortC</td>
 465:/usr/lib/avr/include/avr/power.h ****   </tr>
 466:/usr/lib/avr/include/avr/power.h **** 
 467:/usr/lib/avr/include/avr/power.h ****   <tr>
 468:/usr/lib/avr/include/avr/power.h ****     <td>power_usartc0_enable()</td>
 469:/usr/lib/avr/include/avr/power.h ****     <td> Enable the USART0 module on PortC</td>
 470:/usr/lib/avr/include/avr/power.h ****   </tr>
 471:/usr/lib/avr/include/avr/power.h **** 
 472:/usr/lib/avr/include/avr/power.h ****   <tr>
 473:/usr/lib/avr/include/avr/power.h ****     <td>power_usartd0_disable()</td>
 474:/usr/lib/avr/include/avr/power.h ****     <td> Disable the USART0 module on PortD</td>
 475:/usr/lib/avr/include/avr/power.h ****   </tr>
 476:/usr/lib/avr/include/avr/power.h **** 
 477:/usr/lib/avr/include/avr/power.h ****   <tr>
 478:/usr/lib/avr/include/avr/power.h ****     <td>power_usartd0_enable()</td>
 479:/usr/lib/avr/include/avr/power.h ****     <td> Enable the USART0 module on PortD</td>
 480:/usr/lib/avr/include/avr/power.h ****   </tr>
 481:/usr/lib/avr/include/avr/power.h **** 
 482:/usr/lib/avr/include/avr/power.h ****   <tr>
 483:/usr/lib/avr/include/avr/power.h ****     <td>power_usarte0_disable()</td>
 484:/usr/lib/avr/include/avr/power.h ****     <td> Disable the USART0 module on PortE</td>
 485:/usr/lib/avr/include/avr/power.h ****   </tr>
 486:/usr/lib/avr/include/avr/power.h **** 
 487:/usr/lib/avr/include/avr/power.h ****   <tr>
 488:/usr/lib/avr/include/avr/power.h ****     <td>power_usarte0_enable()</td>
 489:/usr/lib/avr/include/avr/power.h ****     <td> Enable the USART0 module on PortE</td>
 490:/usr/lib/avr/include/avr/power.h ****   </tr>
 491:/usr/lib/avr/include/avr/power.h **** 
 492:/usr/lib/avr/include/avr/power.h ****   <tr>
 493:/usr/lib/avr/include/avr/power.h ****     <td>power_usartf0_disable()</td>
 494:/usr/lib/avr/include/avr/power.h ****     <td> Disable the USART0 module on PortF</td>
 495:/usr/lib/avr/include/avr/power.h ****   </tr>
 496:/usr/lib/avr/include/avr/power.h **** 
 497:/usr/lib/avr/include/avr/power.h ****   <tr>
 498:/usr/lib/avr/include/avr/power.h ****     <td>power_usartf0_enable()</td>
 499:/usr/lib/avr/include/avr/power.h ****     <td> Enable the USART0 module on PortF</td>
 500:/usr/lib/avr/include/avr/power.h ****   </tr>
 501:/usr/lib/avr/include/avr/power.h **** 
 502:/usr/lib/avr/include/avr/power.h ****   <tr>
 503:/usr/lib/avr/include/avr/power.h ****     <td>power_usb_enable()</td>
 504:/usr/lib/avr/include/avr/power.h ****     <td>Enable the USB module.</td>
 505:/usr/lib/avr/include/avr/power.h ****   </tr>
 506:/usr/lib/avr/include/avr/power.h **** 
 507:/usr/lib/avr/include/avr/power.h ****   <tr>
 508:/usr/lib/avr/include/avr/power.h ****     <td>power_usb_disable()</td>
 509:/usr/lib/avr/include/avr/power.h ****     <td>Disable the USB module.</td>
 510:/usr/lib/avr/include/avr/power.h ****   </tr>
 511:/usr/lib/avr/include/avr/power.h **** 
 512:/usr/lib/avr/include/avr/power.h ****   <tr>
 513:/usr/lib/avr/include/avr/power.h ****     <td>power_usi_enable()</td>
 514:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Universal Serial Interface module.</td>
 515:/usr/lib/avr/include/avr/power.h ****   </tr>
 516:/usr/lib/avr/include/avr/power.h **** 
 517:/usr/lib/avr/include/avr/power.h ****   <tr>
 518:/usr/lib/avr/include/avr/power.h ****     <td>power_usi_disable()</td>
 519:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Universal Serial Interface module.</td>
 520:/usr/lib/avr/include/avr/power.h ****   </tr>
 521:/usr/lib/avr/include/avr/power.h **** 
 522:/usr/lib/avr/include/avr/power.h ****   <tr>
 523:/usr/lib/avr/include/avr/power.h ****     <td>power_vadc_enable()</td>
 524:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Voltage ADC module.</td>
 525:/usr/lib/avr/include/avr/power.h ****   </tr>
 526:/usr/lib/avr/include/avr/power.h **** 
 527:/usr/lib/avr/include/avr/power.h ****   <tr>
 528:/usr/lib/avr/include/avr/power.h ****     <td>power_vadc_disable()</td>
 529:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Voltage ADC module.</td>
 530:/usr/lib/avr/include/avr/power.h ****   </tr>
 531:/usr/lib/avr/include/avr/power.h **** 
 532:/usr/lib/avr/include/avr/power.h ****   <tr>
 533:/usr/lib/avr/include/avr/power.h ****     <td>power_all_enable()</td>
 534:/usr/lib/avr/include/avr/power.h ****     <td>Enable all modules.</td>
 535:/usr/lib/avr/include/avr/power.h ****   </tr>
 536:/usr/lib/avr/include/avr/power.h **** 
 537:/usr/lib/avr/include/avr/power.h ****   <tr>
 538:/usr/lib/avr/include/avr/power.h ****     <td>power_all_disable()</td>
 539:/usr/lib/avr/include/avr/power.h ****     <td>Disable all modules.</td>
 540:/usr/lib/avr/include/avr/power.h ****   </tr>
 541:/usr/lib/avr/include/avr/power.h **** </table>
 542:/usr/lib/avr/include/avr/power.h **** </center>
 543:/usr/lib/avr/include/avr/power.h **** </small>
 544:/usr/lib/avr/include/avr/power.h **** 
 545:/usr/lib/avr/include/avr/power.h **** @} */
 546:/usr/lib/avr/include/avr/power.h **** 
 547:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRADC)
 548:/usr/lib/avr/include/avr/power.h **** #define power_adc_enable()      (PRR &= (uint8_t)~(1 << PRADC))
 549:/usr/lib/avr/include/avr/power.h **** #define power_adc_disable()     (PRR |= (uint8_t)(1 << PRADC))
 550:/usr/lib/avr/include/avr/power.h **** #endif
 551:/usr/lib/avr/include/avr/power.h **** 
 552:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRCAN)
 553:/usr/lib/avr/include/avr/power.h **** #define power_can_enable()      (PRR &= (uint8_t)~(1 << PRCAN))
 554:/usr/lib/avr/include/avr/power.h **** #define power_can_disable()     (PRR |= (uint8_t)(1 << PRCAN))
 555:/usr/lib/avr/include/avr/power.h **** #endif
 556:/usr/lib/avr/include/avr/power.h **** 
 557:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRLCD)
 558:/usr/lib/avr/include/avr/power.h **** #define power_lcd_enable()      (PRR &= (uint8_t)~(1 << PRLCD))
 559:/usr/lib/avr/include/avr/power.h **** #define power_lcd_disable()     (PRR |= (uint8_t)(1 << PRLCD))
 560:/usr/lib/avr/include/avr/power.h **** #endif
 561:/usr/lib/avr/include/avr/power.h **** 
 562:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRLIN)
 563:/usr/lib/avr/include/avr/power.h **** #define power_lin_enable()      (PRR &= (uint8_t)~(1 << PRLIN))
 564:/usr/lib/avr/include/avr/power.h **** #define power_lin_disable()     (PRR |= (uint8_t)(1 << PRLIN))
 565:/usr/lib/avr/include/avr/power.h **** #endif
 566:/usr/lib/avr/include/avr/power.h **** 
 567:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRPSC)
 568:/usr/lib/avr/include/avr/power.h **** #define power_psc_enable()      (PRR &= (uint8_t)~(1 << PRPSC))
 569:/usr/lib/avr/include/avr/power.h **** #define power_psc_disable()     (PRR |= (uint8_t)(1 << PRPSC))
 570:/usr/lib/avr/include/avr/power.h **** #endif
 571:/usr/lib/avr/include/avr/power.h **** 
 572:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRPSC0)
 573:/usr/lib/avr/include/avr/power.h **** #define power_psc0_enable()     (PRR &= (uint8_t)~(1 << PRPSC0))
 574:/usr/lib/avr/include/avr/power.h **** #define power_psc0_disable()    (PRR |= (uint8_t)(1 << PRPSC0))
 575:/usr/lib/avr/include/avr/power.h **** #endif
 576:/usr/lib/avr/include/avr/power.h **** 
 577:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRPSC1)
 578:/usr/lib/avr/include/avr/power.h **** #define power_psc1_enable()     (PRR &= (uint8_t)~(1 << PRPSC1))
 579:/usr/lib/avr/include/avr/power.h **** #define power_psc1_disable()    (PRR |= (uint8_t)(1 << PRPSC1))
 580:/usr/lib/avr/include/avr/power.h **** #endif
 581:/usr/lib/avr/include/avr/power.h **** 
 582:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRPSC2)
 583:/usr/lib/avr/include/avr/power.h **** #define power_psc2_enable()     (PRR &= (uint8_t)~(1 << PRPSC2))
 584:/usr/lib/avr/include/avr/power.h **** #define power_psc2_disable()    (PRR |= (uint8_t)(1 << PRPSC2))
 585:/usr/lib/avr/include/avr/power.h **** #endif
 586:/usr/lib/avr/include/avr/power.h **** 
 587:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRPSCR)
 588:/usr/lib/avr/include/avr/power.h **** #define power_pscr_enable()     (PRR &= (uint8_t)~(1 << PRPSCR))
 589:/usr/lib/avr/include/avr/power.h **** #define power_pscr_disable()    (PRR |= (uint8_t)(1 << PRPSCR))
 590:/usr/lib/avr/include/avr/power.h **** #endif
 591:/usr/lib/avr/include/avr/power.h **** 
 592:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRSPI)
 593:/usr/lib/avr/include/avr/power.h **** #define power_spi_enable()      (PRR &= (uint8_t)~(1 << PRSPI))
 594:/usr/lib/avr/include/avr/power.h **** #define power_spi_disable()     (PRR |= (uint8_t)(1 << PRSPI))
 595:/usr/lib/avr/include/avr/power.h **** #endif
 596:/usr/lib/avr/include/avr/power.h **** 
 597:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRTIM0)
 598:/usr/lib/avr/include/avr/power.h **** #define power_timer0_enable()   (PRR &= (uint8_t)~(1 << PRTIM0))
 599:/usr/lib/avr/include/avr/power.h **** #define power_timer0_disable()  (PRR |= (uint8_t)(1 << PRTIM0))
 600:/usr/lib/avr/include/avr/power.h **** #endif
 601:/usr/lib/avr/include/avr/power.h **** 
 602:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRTIM1)
 603:/usr/lib/avr/include/avr/power.h **** #define power_timer1_enable()   (PRR &= (uint8_t)~(1 << PRTIM1))
 604:/usr/lib/avr/include/avr/power.h **** #define power_timer1_disable()  (PRR |= (uint8_t)(1 << PRTIM1))
 605:/usr/lib/avr/include/avr/power.h **** #endif
 606:/usr/lib/avr/include/avr/power.h **** 
 607:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRTIM2)
 608:/usr/lib/avr/include/avr/power.h **** #define power_timer2_enable()   (PRR &= (uint8_t)~(1 << PRTIM2))
 609:/usr/lib/avr/include/avr/power.h **** #define power_timer2_disable()  (PRR |= (uint8_t)(1 << PRTIM2))
 610:/usr/lib/avr/include/avr/power.h **** #endif
 611:/usr/lib/avr/include/avr/power.h **** 
 612:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRTWI)
 613:/usr/lib/avr/include/avr/power.h **** #define power_twi_enable()      (PRR &= (uint8_t)~(1 << PRTWI))
 614:/usr/lib/avr/include/avr/power.h **** #define power_twi_disable()     (PRR |= (uint8_t)(1 << PRTWI))
 615:/usr/lib/avr/include/avr/power.h **** #endif
 616:/usr/lib/avr/include/avr/power.h **** 
 617:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRUSART)
 618:/usr/lib/avr/include/avr/power.h **** #define power_usart_enable()    (PRR &= (uint8_t)~(1 << PRUSART))
 619:/usr/lib/avr/include/avr/power.h **** #define power_usart_disable()   (PRR |= (uint8_t)(1 << PRUSART))
 620:/usr/lib/avr/include/avr/power.h **** #endif
 621:/usr/lib/avr/include/avr/power.h **** 
 622:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRUSART0)
 623:/usr/lib/avr/include/avr/power.h **** #define power_usart0_enable()   (PRR &= (uint8_t)~(1 << PRUSART0))
 624:/usr/lib/avr/include/avr/power.h **** #define power_usart0_disable()  (PRR |= (uint8_t)(1 << PRUSART0))
 625:/usr/lib/avr/include/avr/power.h **** #endif
 626:/usr/lib/avr/include/avr/power.h **** 
 627:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRUSART1)
 628:/usr/lib/avr/include/avr/power.h **** #define power_usart1_enable()   (PRR &= (uint8_t)~(1 << PRUSART1))
 629:/usr/lib/avr/include/avr/power.h **** #define power_usart1_disable()  (PRR |= (uint8_t)(1 << PRUSART1))
 630:/usr/lib/avr/include/avr/power.h **** #endif
 631:/usr/lib/avr/include/avr/power.h **** 
 632:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR_PRUSI)
 633:/usr/lib/avr/include/avr/power.h **** #define power_usi_enable()      (PRR &= (uint8_t)~(1 << PRUSI))
 634:/usr/lib/avr/include/avr/power.h **** #define power_usi_disable()     (PRR |= (uint8_t)(1 << PRUSI))
 635:/usr/lib/avr/include/avr/power.h **** #endif
 636:/usr/lib/avr/include/avr/power.h **** 
 637:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRADC)
 638:/usr/lib/avr/include/avr/power.h **** #define power_adc_enable()      (PRR0 &= (uint8_t)~(1 << PRADC))
 639:/usr/lib/avr/include/avr/power.h **** #define power_adc_disable()     (PRR0 |= (uint8_t)(1 << PRADC))
 640:/usr/lib/avr/include/avr/power.h **** #endif
 641:/usr/lib/avr/include/avr/power.h **** 
 642:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRCO)
 643:/usr/lib/avr/include/avr/power.h **** #define power_clock_output_enable()     (PRR0 &= (uint8_t)~(1 << PRCO))
 644:/usr/lib/avr/include/avr/power.h **** #define power_clock_output_disable()    (PRR0 |= (uint8_t)(1 << PRCO))
 645:/usr/lib/avr/include/avr/power.h **** #endif
 646:/usr/lib/avr/include/avr/power.h **** 
 647:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRCRC)
 648:/usr/lib/avr/include/avr/power.h **** #define power_crc_enable()              (PRR0 &= (uint8_t)~(1 << PRCRC))
 649:/usr/lib/avr/include/avr/power.h **** #define power_crc_disable()             (PRR0 |= (uint8_t)(1 << PRCRC))
 650:/usr/lib/avr/include/avr/power.h **** #endif
 651:/usr/lib/avr/include/avr/power.h **** 
 652:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRCU)
 653:/usr/lib/avr/include/avr/power.h **** #define power_crypto_enable()           (PRR0 &= (uint8_t)~(1 << PRCU))
 654:/usr/lib/avr/include/avr/power.h **** #define power_crypto_disable()          (PRR0 |= (uint8_t)(1 << PRCU))
 655:/usr/lib/avr/include/avr/power.h **** #endif
 656:/usr/lib/avr/include/avr/power.h **** 
 657:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRDS)
 658:/usr/lib/avr/include/avr/power.h **** #define power_irdriver_enable()         (PRR0 &= (uint8_t)~(1 << PRDS))
 659:/usr/lib/avr/include/avr/power.h **** #define power_irdriver_disable()        (PRR0 |= (uint8_t)(1 << PRDS))
 660:/usr/lib/avr/include/avr/power.h **** #endif
 661:/usr/lib/avr/include/avr/power.h **** 
 662:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRLFR)
 663:/usr/lib/avr/include/avr/power.h **** #define power_lfreceiver_enable()       (PRR0 &= (uint8_t)~(1 << PRLFR))
 664:/usr/lib/avr/include/avr/power.h **** #define power_lfreceiver_disable()      (PRR0 |= (uint8_t)(1 << PRLFR))
 665:/usr/lib/avr/include/avr/power.h **** #endif
 666:/usr/lib/avr/include/avr/power.h **** 
 667:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRLFRS)
 668:/usr/lib/avr/include/avr/power.h **** #define power_lfrs_enable()             (PRR0 &= (uint8_t)~(1 << PRLFRS))
 669:/usr/lib/avr/include/avr/power.h **** #define power_lfrs_disable()            (PRR0 |= (uint8_t)(1 << PRLFRS))
 670:/usr/lib/avr/include/avr/power.h **** #endif
 671:/usr/lib/avr/include/avr/power.h **** 
 672:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRLIN)
 673:/usr/lib/avr/include/avr/power.h **** #define power_lin_enable()              (PRR0 &= (uint8_t)~(1 << PRLIN))
 674:/usr/lib/avr/include/avr/power.h **** #define power_lin_disable()             (PRR0 |= (uint8_t)(1 << PRLIN))
 675:/usr/lib/avr/include/avr/power.h **** #endif
 676:/usr/lib/avr/include/avr/power.h **** 
 677:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRPGA)
 678:/usr/lib/avr/include/avr/power.h **** #define power_pga_enable()              (PRR0 &= (uint8_t)~(1 << PRPGA))
 679:/usr/lib/avr/include/avr/power.h **** #define power_pga_disable()             (PRR0 |= (uint8_t)(1 << PRPGA))
 680:/usr/lib/avr/include/avr/power.h **** #endif
 681:/usr/lib/avr/include/avr/power.h **** 
 682:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRRXDC)
 683:/usr/lib/avr/include/avr/power.h **** #define power_receive_dsp_control_enable()  (PRR0 &= (uint8_t)~(1 << PRRXDC))
 684:/usr/lib/avr/include/avr/power.h **** #define power_receive_dsp_control_disable() (PRR0 |= (uint8_t)(1 << PRRXDC))
 685:/usr/lib/avr/include/avr/power.h **** #endif
 686:/usr/lib/avr/include/avr/power.h **** 
 687:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRSPI)
 688:/usr/lib/avr/include/avr/power.h **** #define power_spi_enable()              (PRR0 &= (uint8_t)~(1 << PRSPI))
 689:/usr/lib/avr/include/avr/power.h **** #define power_spi_disable()             (PRR0 |= (uint8_t)(1 << PRSPI))
 690:/usr/lib/avr/include/avr/power.h **** #endif
 691:/usr/lib/avr/include/avr/power.h **** 
 692:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRT0)
 693:/usr/lib/avr/include/avr/power.h **** #define power_timer0_enable()           (PRR0 &= (uint8_t)~(1 << PRT0))
 694:/usr/lib/avr/include/avr/power.h **** #define power_timer0_disable()          (PRR0 |= (uint8_t)(1 << PRT0))
 695:/usr/lib/avr/include/avr/power.h **** #endif
 696:/usr/lib/avr/include/avr/power.h **** 
 697:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRTIM0)
 698:/usr/lib/avr/include/avr/power.h **** #define power_timer0_enable()           (PRR0 &= (uint8_t)~(1 << PRTIM0))
 699:/usr/lib/avr/include/avr/power.h **** #define power_timer0_disable()          (PRR0 |= (uint8_t)(1 << PRTIM0))
 700:/usr/lib/avr/include/avr/power.h **** #endif
 701:/usr/lib/avr/include/avr/power.h **** 
 702:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRT1)
 703:/usr/lib/avr/include/avr/power.h **** #define power_timer1_enable()           (PRR0 &= (uint8_t)~(1 << PRT1))
 704:/usr/lib/avr/include/avr/power.h **** #define power_timer1_disable()          (PRR0 |= (uint8_t)(1 << PRT1))
 705:/usr/lib/avr/include/avr/power.h **** #endif
 706:/usr/lib/avr/include/avr/power.h **** 
 707:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRTIM1)
 708:/usr/lib/avr/include/avr/power.h **** #define power_timer1_enable()           (PRR0 &= (uint8_t)~(1 << PRTIM1))
 709:/usr/lib/avr/include/avr/power.h **** #define power_timer1_disable()          (PRR0 |= (uint8_t)(1 << PRTIM1))
 710:/usr/lib/avr/include/avr/power.h **** #endif
 711:/usr/lib/avr/include/avr/power.h **** 
 712:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRT2)
 713:/usr/lib/avr/include/avr/power.h **** #define power_timer2_enable()           (PRR0 &= (uint8_t)~(1 << PRT2))
 714:/usr/lib/avr/include/avr/power.h **** #define power_timer2_disable()          (PRR0 |= (uint8_t)(1 << PRT2))
 715:/usr/lib/avr/include/avr/power.h **** #endif
 716:/usr/lib/avr/include/avr/power.h **** 
 717:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRTIM2)
 718:/usr/lib/avr/include/avr/power.h **** #define power_timer2_enable()           (PRR0 &= (uint8_t)~(1 << PRTIM2))
 719:/usr/lib/avr/include/avr/power.h **** #define power_timer2_disable()          (PRR0 |= (uint8_t)(1 << PRTIM2))
 720:/usr/lib/avr/include/avr/power.h **** #endif
 721:/usr/lib/avr/include/avr/power.h **** 
 722:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRT3)
 723:/usr/lib/avr/include/avr/power.h **** #define power_timer3_enable()           (PRR0 &= (uint8_t)~(1 << PRT3))
 724:/usr/lib/avr/include/avr/power.h **** #define power_timer3_disable()          (PRR0 |= (uint8_t)(1 << PRT3))
 725:/usr/lib/avr/include/avr/power.h **** #endif
 726:/usr/lib/avr/include/avr/power.h **** 
 727:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRTM)
 728:/usr/lib/avr/include/avr/power.h **** #define power_timermodulator_enable()   (PRR0 &= (uint8_t)~(1 << PRTM))
 729:/usr/lib/avr/include/avr/power.h **** #define power_timermodulator_disable()  (PRR0 |= (uint8_t)(1 << PRTM))
 730:/usr/lib/avr/include/avr/power.h **** #endif
 731:/usr/lib/avr/include/avr/power.h **** 
 732:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRTWI)
 733:/usr/lib/avr/include/avr/power.h **** #define power_twi_enable()              (PRR0 &= (uint8_t)~(1 << PRTWI))
 734:/usr/lib/avr/include/avr/power.h **** #define power_twi_disable()             (PRR0 |= (uint8_t)(1 << PRTWI))
 735:/usr/lib/avr/include/avr/power.h **** #endif
 736:/usr/lib/avr/include/avr/power.h **** 
 737:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRTWI1)
 738:/usr/lib/avr/include/avr/power.h **** #define power_twi1_enable()             (PRR0 &= (uint8_t)~(1 << PRTWI1))
 739:/usr/lib/avr/include/avr/power.h **** #define power_twi1_disable()            (PRR0 |= (uint8_t)(1 << PRTWI1))
 740:/usr/lib/avr/include/avr/power.h **** #endif
 741:/usr/lib/avr/include/avr/power.h **** 
 742:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRTXDC)
 743:/usr/lib/avr/include/avr/power.h **** #define power_transmit_dsp_control_enable()   (PRR0 &= (uint8_t)~(1 << PRTXDC))
 744:/usr/lib/avr/include/avr/power.h **** #define power_transmit_dsp_control_disable()  (PRR0 |= (uint8_t)(1 << PRTXDC))
 745:/usr/lib/avr/include/avr/power.h **** #endif
 746:/usr/lib/avr/include/avr/power.h **** 
 747:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRUSART0)
 748:/usr/lib/avr/include/avr/power.h **** #define power_usart0_enable()           (PRR0 &= (uint8_t)~(1 << PRUSART0))
 749:/usr/lib/avr/include/avr/power.h **** #define power_usart0_disable()          (PRR0 |= (uint8_t)(1 << PRUSART0))
 750:/usr/lib/avr/include/avr/power.h **** #endif
 751:/usr/lib/avr/include/avr/power.h **** 
 752:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRUSART1)
 753:/usr/lib/avr/include/avr/power.h **** #define power_usart1_enable()           (PRR0 &= (uint8_t)~(1 << PRUSART1))
 754:/usr/lib/avr/include/avr/power.h **** #define power_usart1_disable()          (PRR0 |= (uint8_t)(1 << PRUSART1))
 755:/usr/lib/avr/include/avr/power.h **** #endif
 756:/usr/lib/avr/include/avr/power.h **** 
 757:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRVADC)
 758:/usr/lib/avr/include/avr/power.h **** #define power_vadc_enable()             (PRR0 &= (uint8_t)~(1 << PRVADC))
 759:/usr/lib/avr/include/avr/power.h **** #define power_vadc_disable()            (PRR0 |= (uint8_t)(1 << PRVADC))
 760:/usr/lib/avr/include/avr/power.h **** #endif
 761:/usr/lib/avr/include/avr/power.h **** 
 762:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRVM)
 763:/usr/lib/avr/include/avr/power.h **** #define power_voltage_monitor_enable()  (PRR0 &= (uint8_t)~(1 << PRVM))
 764:/usr/lib/avr/include/avr/power.h **** #define power_voltage_monitor_disable() (PRR0 |= (uint8_t)(1 << PRVM))
 765:/usr/lib/avr/include/avr/power.h **** #endif
 766:/usr/lib/avr/include/avr/power.h **** 
 767:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR0_PRVRM)
 768:/usr/lib/avr/include/avr/power.h **** #define power_vrm_enable()              (PRR0 &= (uint8_t)~(1 << PRVRM))
 769:/usr/lib/avr/include/avr/power.h **** #define power_vrm_disable()             (PRR0 |= (uint8_t)(1 << PRVRM))
 770:/usr/lib/avr/include/avr/power.h **** #endif
 771:/usr/lib/avr/include/avr/power.h **** 
 772:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRAES)
 773:/usr/lib/avr/include/avr/power.h **** #define power_aes_enable()              (PRR1 &= (uint8_t)~(1 << PRAES))
 774:/usr/lib/avr/include/avr/power.h **** #define power_aes_disable()             (PRR1 |= (uint8_t)(1 << PRAES))
 775:/usr/lib/avr/include/avr/power.h **** #endif
 776:/usr/lib/avr/include/avr/power.h **** 
 777:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRCI)
 778:/usr/lib/avr/include/avr/power.h **** #define power_cinterface_enable()       (PRR1 &= (uint8_t)~(1 << PRCI))
 779:/usr/lib/avr/include/avr/power.h **** #define power_cinterface_disable()      (PRR1 |= (uint8_t)(1 << PRCI))
 780:/usr/lib/avr/include/avr/power.h **** #endif
 781:/usr/lib/avr/include/avr/power.h **** 
 782:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRHSSPI)
 783:/usr/lib/avr/include/avr/power.h **** #define power_hsspi_enable()            (PRR1 &= (uint8_t)~(1 << PRHSSPI))
 784:/usr/lib/avr/include/avr/power.h **** #define power_hsspi_disable()           (PRR1 |= (uint8_t)(1 << PRHSSPI))
 785:/usr/lib/avr/include/avr/power.h **** #endif
 786:/usr/lib/avr/include/avr/power.h **** 
 787:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRKB)
 788:/usr/lib/avr/include/avr/power.h **** #define power_kb_enable()               (PRR1 &= (uint8_t)~(1 << PRKB))
 789:/usr/lib/avr/include/avr/power.h **** #define power_kb_disable()              (PRR1 |= (uint8_t)(1 << PRKB))
 790:/usr/lib/avr/include/avr/power.h **** #endif
 791:/usr/lib/avr/include/avr/power.h **** 
 792:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRLFPH)
 793:/usr/lib/avr/include/avr/power.h **** #define power_lfph_enable()             (PRR1 &= (uint8_t)~(1 << PRLFPH))
 794:/usr/lib/avr/include/avr/power.h **** #define power_lfph_disable()            (PRR1 |= (uint8_t)(1 << PRLFPH))
 795:/usr/lib/avr/include/avr/power.h **** #endif
 796:/usr/lib/avr/include/avr/power.h **** 
 797:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRLFR)
 798:/usr/lib/avr/include/avr/power.h **** #define power_lfreceiver_enable()       (PRR1 &= (uint8_t)~(1 << PRLFR))            
 799:/usr/lib/avr/include/avr/power.h **** #define power_lfreceiver_disable()      (PRR1 |= (uint8_t)(1 << PRLFR))            
 800:/usr/lib/avr/include/avr/power.h **** #endif
 801:/usr/lib/avr/include/avr/power.h **** 
 802:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRLFTP)
 803:/usr/lib/avr/include/avr/power.h **** #define power_lftp_enable()             (PRR1 &= (uint8_t)~(1 << PRLFTP))
 804:/usr/lib/avr/include/avr/power.h **** #define power_lftp_disable()            (PRR1 |= (uint8_t)(1 << PRLFTP))
 805:/usr/lib/avr/include/avr/power.h **** #endif
 806:/usr/lib/avr/include/avr/power.h **** 
 807:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRSCI)
 808:/usr/lib/avr/include/avr/power.h **** #define power_sci_enable()              (PRR1 &= (uint8_t)~(1 << PRSCI))
 809:/usr/lib/avr/include/avr/power.h **** #define power_sci_disable()             (PRR1 |= (uint8_t)(1 << PRSCI))
 810:/usr/lib/avr/include/avr/power.h **** #endif
 811:/usr/lib/avr/include/avr/power.h **** 
 812:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRSPI)
 813:/usr/lib/avr/include/avr/power.h **** #define power_spi_enable()              (PRR1 &= (uint8_t)~(1 << PRSPI))
 814:/usr/lib/avr/include/avr/power.h **** #define power_spi_disable()             (PRR1 |= (uint8_t)(1 << PRSPI))
 815:/usr/lib/avr/include/avr/power.h **** #endif
 816:/usr/lib/avr/include/avr/power.h **** 
 817:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRT1)
 818:/usr/lib/avr/include/avr/power.h **** #define power_timer1_enable()           (PRR1 &= (uint8_t)~(1 << PRT1))
 819:/usr/lib/avr/include/avr/power.h **** #define power_timer1_disable()          (PRR1 |= (uint8_t)(1 << PRT1))
 820:/usr/lib/avr/include/avr/power.h **** #endif
 821:/usr/lib/avr/include/avr/power.h **** 
 822:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRT2)
 823:/usr/lib/avr/include/avr/power.h **** #define power_timer2_enable()           (PRR1 &= (uint8_t)~(1 << PRT2))
 824:/usr/lib/avr/include/avr/power.h **** #define power_timer2_disable()          (PRR1 |= (uint8_t)(1 << PRT2))
 825:/usr/lib/avr/include/avr/power.h **** #endif
 826:/usr/lib/avr/include/avr/power.h **** 
 827:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRT3)
 828:/usr/lib/avr/include/avr/power.h **** #define power_timer3_enable()           (PRR1 &= (uint8_t)~(1 << PRT3))
 829:/usr/lib/avr/include/avr/power.h **** #define power_timer3_disable()          (PRR1 |= (uint8_t)(1 << PRT3))
 830:/usr/lib/avr/include/avr/power.h **** #endif
 831:/usr/lib/avr/include/avr/power.h **** 
 832:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRT4)
 833:/usr/lib/avr/include/avr/power.h **** #define power_timer4_enable()           (PRR1 &= (uint8_t)~(1 << PRT4))
 834:/usr/lib/avr/include/avr/power.h **** #define power_timer4_disable()          (PRR1 |= (uint8_t)(1 << PRT4))
 835:/usr/lib/avr/include/avr/power.h **** #endif
 836:/usr/lib/avr/include/avr/power.h **** 
 837:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRT5)
 838:/usr/lib/avr/include/avr/power.h **** #define power_timer5_enable()           (PRR1 &= (uint8_t)~(1 << PRT5))
 839:/usr/lib/avr/include/avr/power.h **** #define power_timer5_disable()          (PRR1 |= (uint8_t)(1 << PRT5))
 840:/usr/lib/avr/include/avr/power.h **** #endif
 841:/usr/lib/avr/include/avr/power.h **** 
 842:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRTIM3)
 843:/usr/lib/avr/include/avr/power.h **** #define power_timer3_enable()           (PRR1 &= (uint8_t)~(1 << PRTIM3))
 844:/usr/lib/avr/include/avr/power.h **** #define power_timer3_disable()          (PRR1 |= (uint8_t)(1 << PRTIM3))
 845:/usr/lib/avr/include/avr/power.h **** #endif
 846:/usr/lib/avr/include/avr/power.h **** 
 847:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRTIM4)
 848:/usr/lib/avr/include/avr/power.h **** #define power_timer4_enable()           (PRR1 &= (uint8_t)~(1 << PRTIM4))
 849:/usr/lib/avr/include/avr/power.h **** #define power_timer4_disable()          (PRR1 |= (uint8_t)(1 << PRTIM4))
 850:/usr/lib/avr/include/avr/power.h **** #endif
 851:/usr/lib/avr/include/avr/power.h **** 
 852:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRTIM5)
 853:/usr/lib/avr/include/avr/power.h **** #define power_timer5_enable()           (PRR1 &= (uint8_t)~(1 << PRTIM5))
 854:/usr/lib/avr/include/avr/power.h **** #define power_timer5_disable()          (PRR1 |= (uint8_t)(1 << PRTIM5))
 855:/usr/lib/avr/include/avr/power.h **** #endif
 856:/usr/lib/avr/include/avr/power.h **** 
 857:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRTRX24)
 858:/usr/lib/avr/include/avr/power.h **** #define power_transceiver_enable()      (PRR1 &= (uint8_t)~(1 << PRTRX24))
 859:/usr/lib/avr/include/avr/power.h **** #define power_transceiver_disable()     (PRR1 |= (uint8_t)(1 << PRTRX24))
 860:/usr/lib/avr/include/avr/power.h **** #endif
 861:/usr/lib/avr/include/avr/power.h **** 
 862:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRUSART1)
 863:/usr/lib/avr/include/avr/power.h **** #define power_usart1_enable()           (PRR1 &= (uint8_t)~(1 << PRUSART1))
 864:/usr/lib/avr/include/avr/power.h **** #define power_usart1_disable()          (PRR1 |= (uint8_t)(1 << PRUSART1))
 865:/usr/lib/avr/include/avr/power.h **** #endif
 866:/usr/lib/avr/include/avr/power.h **** 
 867:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRUSART2)
 868:/usr/lib/avr/include/avr/power.h **** #define power_usart2_enable()           (PRR1 &= (uint8_t)~(1 << PRUSART2))
 869:/usr/lib/avr/include/avr/power.h **** #define power_usart2_disable()          (PRR1 |= (uint8_t)(1 << PRUSART2))
 870:/usr/lib/avr/include/avr/power.h **** #endif
 871:/usr/lib/avr/include/avr/power.h **** 
 872:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRUSART3)
 873:/usr/lib/avr/include/avr/power.h **** #define power_usart3_enable()           (PRR1 &= (uint8_t)~(1 << PRUSART3))
 874:/usr/lib/avr/include/avr/power.h **** #define power_usart3_disable()          (PRR1 |= (uint8_t)(1 << PRUSART3))
 875:/usr/lib/avr/include/avr/power.h **** #endif
 876:/usr/lib/avr/include/avr/power.h **** 
 877:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRUSB)
 878:/usr/lib/avr/include/avr/power.h **** #define power_usb_enable()              (PRR1 &= (uint8_t)~(1 << PRUSB))
 879:/usr/lib/avr/include/avr/power.h **** #define power_usb_disable()             (PRR1 |= (uint8_t)(1 << PRUSB))
 880:/usr/lib/avr/include/avr/power.h **** #endif
 881:/usr/lib/avr/include/avr/power.h **** 
 882:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR1_PRUSBH)
 883:/usr/lib/avr/include/avr/power.h **** #define power_usbh_enable()             (PRR1 &= (uint8_t)~(1 << PRUSBH))
 884:/usr/lib/avr/include/avr/power.h **** #define power_usbh_disable()            (PRR1 |= (uint8_t)(1 << PRUSBH))
 885:/usr/lib/avr/include/avr/power.h **** #endif
 886:/usr/lib/avr/include/avr/power.h **** 
 887:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRDF)
 888:/usr/lib/avr/include/avr/power.h **** #define power_data_fifo_enable()        (PRR2 &= (uint8_t)~(1 << PRDF))
 889:/usr/lib/avr/include/avr/power.h **** #define power_data_fifo_disable()       (PRR2 |= (uint8_t)(1 << PRDF))
 890:/usr/lib/avr/include/avr/power.h **** #endif
 891:/usr/lib/avr/include/avr/power.h **** 
 892:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRIDS)
 893:/usr/lib/avr/include/avr/power.h **** #define power_id_scan_enable()          (PRR2 &= (uint8_t)~(1 << PRIDS))
 894:/usr/lib/avr/include/avr/power.h **** #define power_id_scan_disable()         (PRR2 |= (uint8_t)(1 << PRIDS))
 895:/usr/lib/avr/include/avr/power.h **** #endif
 896:/usr/lib/avr/include/avr/power.h **** 
 897:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRRAM0)
 898:/usr/lib/avr/include/avr/power.h **** #define power_ram0_enable()             (PRR2 &= (uint8_t)~(1 << PRRAM0))
 899:/usr/lib/avr/include/avr/power.h **** #define power_ram0_disable()            (PRR2 |= (uint8_t)(1 << PRRAM0))
 900:/usr/lib/avr/include/avr/power.h **** #endif
 901:/usr/lib/avr/include/avr/power.h **** 
 902:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRRAM1)
 903:/usr/lib/avr/include/avr/power.h **** #define power_ram1_enable()             (PRR2 &= (uint8_t)~(1 << PRRAM1))
 904:/usr/lib/avr/include/avr/power.h **** #define power_ram1_disable()            (PRR2 |= (uint8_t)(1 << PRRAM1))
 905:/usr/lib/avr/include/avr/power.h **** #endif
 906:/usr/lib/avr/include/avr/power.h **** 
 907:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRRAM2)
 908:/usr/lib/avr/include/avr/power.h **** #define power_ram2_enable()             (PRR2 &= (uint8_t)~(1 << PRRAM2))
 909:/usr/lib/avr/include/avr/power.h **** #define power_ram2_disable()            (PRR2 |= (uint8_t)(1 << PRRAM2))
 910:/usr/lib/avr/include/avr/power.h **** #endif
 911:/usr/lib/avr/include/avr/power.h **** 
 912:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRRAM3)
 913:/usr/lib/avr/include/avr/power.h **** #define power_ram3_enable()             (PRR2 &= (uint8_t)~(1 << PRRAM3))
 914:/usr/lib/avr/include/avr/power.h **** #define power_ram3_disable()            (PRR2 |= (uint8_t)(1 << PRRAM3))
 915:/usr/lib/avr/include/avr/power.h **** #endif
 916:/usr/lib/avr/include/avr/power.h **** 
 917:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRRS)
 918:/usr/lib/avr/include/avr/power.h **** #define power_rssi_buffer_enable()      (PRR2 &= (uint8_t)~(1 << PRRS))
 919:/usr/lib/avr/include/avr/power.h **** #define power_rssi_buffer_disable()     (PRR2 |= (uint8_t)(1 << PRRS))
 920:/usr/lib/avr/include/avr/power.h **** #endif
 921:/usr/lib/avr/include/avr/power.h **** 
 922:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRSF)
 923:/usr/lib/avr/include/avr/power.h **** #define power_preamble_rssi_fifo_enable()       (PRR2 &= (uint8_t)~(1 << PRSF))
 924:/usr/lib/avr/include/avr/power.h **** #define power_preamble_rssi_fifo_disable()      (PRR2 |= (uint8_t)(1 << PRSF))
 925:/usr/lib/avr/include/avr/power.h **** #endif
 926:/usr/lib/avr/include/avr/power.h **** 
 927:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRSPI2)
 928:/usr/lib/avr/include/avr/power.h **** #define power_spi2_enable()             (PRR2 &= (uint8_t)~(1 << PRSPI2))
 929:/usr/lib/avr/include/avr/power.h **** #define power_spi2_disable()            (PRR2 |= (uint8_t)(1 << PRSPI2))
 930:/usr/lib/avr/include/avr/power.h **** #endif
 931:/usr/lib/avr/include/avr/power.h **** 
 932:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRSSM)
 933:/usr/lib/avr/include/avr/power.h **** #define power_sequencer_state_machine_enable()  (PRR2 &= (uint8_t)~(1 << PRSSM))
 934:/usr/lib/avr/include/avr/power.h **** #define power_sequencer_state_machine_disable() (PRR2 |= (uint8_t)(1 << PRSSM))
 935:/usr/lib/avr/include/avr/power.h **** #endif
 936:/usr/lib/avr/include/avr/power.h **** 
 937:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRTM)
 938:/usr/lib/avr/include/avr/power.h **** #define power_tx_modulator_enable()     (PRR2 &= (uint8_t)~(1 << PRTM))
 939:/usr/lib/avr/include/avr/power.h **** #define power_tx_modulator_disable()    (PRR2 |= (uint8_t)(1 << PRTM))
 940:/usr/lib/avr/include/avr/power.h **** #endif
 941:/usr/lib/avr/include/avr/power.h **** 
 942:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRTWI2)
 943:/usr/lib/avr/include/avr/power.h **** #define power_twi2_enable()             (PRR2 &= (uint8_t)~(1 << PRTWI2))
 944:/usr/lib/avr/include/avr/power.h **** #define power_twi2_disable()            (PRR2 |= (uint8_t)(1 << PRTWI2))
 945:/usr/lib/avr/include/avr/power.h **** #endif
 946:/usr/lib/avr/include/avr/power.h **** 
 947:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRXA)
 948:/usr/lib/avr/include/avr/power.h **** #define power_rx_buffer_A_enable()      (PRR2 &= (uint8_t)~(1 << PRXA))
 949:/usr/lib/avr/include/avr/power.h **** #define power_rx_buffer_A_disable()     (PRR2 |= (uint8_t)(1 << PRXA))
 950:/usr/lib/avr/include/avr/power.h **** #endif
 951:/usr/lib/avr/include/avr/power.h **** 
 952:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRR2_PRXB)
 953:/usr/lib/avr/include/avr/power.h **** #define power_rx_buffer_B_enable()      (PRR2 &= (uint8_t)~(1 << PRXB))
 954:/usr/lib/avr/include/avr/power.h **** #define power_rx_buffer_B_disable()     (PRR2 |= (uint8_t)(1 << PRXB))
 955:/usr/lib/avr/include/avr/power.h **** #endif
 956:/usr/lib/avr/include/avr/power.h **** 
 957:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRGEN_AES)
 958:/usr/lib/avr/include/avr/power.h **** #define power_aes_enable()              (PR_PRGEN &= (uint8_t)~(PR_AES_bm))
 959:/usr/lib/avr/include/avr/power.h **** #define power_aes_disable()             (PR_PRGEN |= (uint8_t)PR_AES_bm)
 960:/usr/lib/avr/include/avr/power.h **** #endif
 961:/usr/lib/avr/include/avr/power.h **** 
 962:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRGEN_DMA)
 963:/usr/lib/avr/include/avr/power.h **** #define power_dma_enable()              (PR_PRGEN &= (uint8_t)~(PR_DMA_bm))
 964:/usr/lib/avr/include/avr/power.h **** #define power_dma_disable()             (PR_PRGEN |= (uint8_t)PR_DMA_bm)
 965:/usr/lib/avr/include/avr/power.h **** #endif
 966:/usr/lib/avr/include/avr/power.h **** 
 967:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRGEN_EBI)
 968:/usr/lib/avr/include/avr/power.h **** #define power_ebi_enable()              (PR_PRGEN &= (uint8_t)~(PR_EBI_bm))
 969:/usr/lib/avr/include/avr/power.h **** #define power_ebi_disable()             (PR_PRGEN |= (uint8_t)PR_EBI_bm)
 970:/usr/lib/avr/include/avr/power.h **** #endif
 971:/usr/lib/avr/include/avr/power.h **** 
 972:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRGEN_EDMA)
 973:/usr/lib/avr/include/avr/power.h **** #define power_edma_enable()             (PR_PRGEN &= (uint8_t)~(PR_EDMA_bm))
 974:/usr/lib/avr/include/avr/power.h **** #define power_edma_disable()            (PR_PRGEN |= (uint8_t)PR_EDMA_bm)
 975:/usr/lib/avr/include/avr/power.h **** #endif
 976:/usr/lib/avr/include/avr/power.h **** 
 977:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRGEN_EVSYS)
 978:/usr/lib/avr/include/avr/power.h **** #define power_evsys_enable()            (PR_PRGEN &= (uint8_t)~(PR_EVSYS_bm))
 979:/usr/lib/avr/include/avr/power.h **** #define power_evsys_disable()           (PR_PRGEN |= (uint8_t)PR_EVSYS_bm)
 980:/usr/lib/avr/include/avr/power.h **** #endif
 981:/usr/lib/avr/include/avr/power.h **** 
 982:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRGEN_LCD)
 983:/usr/lib/avr/include/avr/power.h **** #define power_lcd_enable()              (PR_PRGEN &= (uint8_t)~(PR_LCD_bm))
 984:/usr/lib/avr/include/avr/power.h **** #define power_lcd_disable()             (PR_PRGEN |= (uint8_t)PR_LCD_bm)
 985:/usr/lib/avr/include/avr/power.h **** #endif
 986:/usr/lib/avr/include/avr/power.h **** 
 987:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRGEN_RTC)
 988:/usr/lib/avr/include/avr/power.h **** #define power_rtc_enable()              (PR_PRGEN &= (uint8_t)~(PR_RTC_bm))
 989:/usr/lib/avr/include/avr/power.h **** #define power_rtc_disable()             (PR_PRGEN |= (uint8_t)PR_RTC_bm)
 990:/usr/lib/avr/include/avr/power.h **** #endif
 991:/usr/lib/avr/include/avr/power.h **** 
 992:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRGEN_USB)
 993:/usr/lib/avr/include/avr/power.h **** #define power_usb_enable()              (PR_PRGEN &= (uint8_t)~(PR_USB_bm))
 994:/usr/lib/avr/include/avr/power.h **** #define power_usb_disable()             (PR_PRGEN &= (uint8_t)(PR_USB_bm))
 995:/usr/lib/avr/include/avr/power.h **** #endif
 996:/usr/lib/avr/include/avr/power.h **** 
 997:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRGEN_XCL)
 998:/usr/lib/avr/include/avr/power.h **** #define power_xcl_enable()              (PR_PRGEN &= (uint8_t)~(PR_XCL_bm))
 999:/usr/lib/avr/include/avr/power.h **** #define power_xcl_disable()             (PR_PRGEN |= (uint8_t)PR_XCL_bm)
1000:/usr/lib/avr/include/avr/power.h **** #endif
1001:/usr/lib/avr/include/avr/power.h **** 
1002:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPA_AC)
1003:/usr/lib/avr/include/avr/power.h **** #define power_aca_enable()      (PR_PRPA &= (uint8_t)~(PR_AC_bm))
1004:/usr/lib/avr/include/avr/power.h **** #define power_aca_disable()     (PR_PRPA |= (uint8_t)PR_AC_bm)
1005:/usr/lib/avr/include/avr/power.h **** #endif
1006:/usr/lib/avr/include/avr/power.h **** 
1007:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPA_ADC)
1008:/usr/lib/avr/include/avr/power.h **** #define power_adca_enable()     (PR_PRPA &= (uint8_t)~(PR_ADC_bm))
1009:/usr/lib/avr/include/avr/power.h **** #define power_adca_disable()    (PR_PRPA |= (uint8_t)PR_ADC_bm)
1010:/usr/lib/avr/include/avr/power.h **** #endif
1011:/usr/lib/avr/include/avr/power.h **** 
1012:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPA_DAC)
1013:/usr/lib/avr/include/avr/power.h **** #define power_daca_enable()     (PR_PRPA &= (uint8_t)~(PR_DAC_bm))
1014:/usr/lib/avr/include/avr/power.h **** #define power_daca_disable()    (PR_PRPA |= (uint8_t)PR_DAC_bm)
1015:/usr/lib/avr/include/avr/power.h **** #endif
1016:/usr/lib/avr/include/avr/power.h **** 
1017:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPB_AC)
1018:/usr/lib/avr/include/avr/power.h **** #define power_acb_enable()      (PR_PRPB &= (uint8_t)~(PR_AC_bm))
1019:/usr/lib/avr/include/avr/power.h **** #define power_acb_disable()     (PR_PRPB |= (uint8_t)PR_AC_bm)
1020:/usr/lib/avr/include/avr/power.h **** #endif
1021:/usr/lib/avr/include/avr/power.h **** 
1022:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPB_ADC)
1023:/usr/lib/avr/include/avr/power.h **** #define power_adcb_enable()     (PR_PRPB &= (uint8_t)~(PR_ADC_bm))
1024:/usr/lib/avr/include/avr/power.h **** #define power_adcb_disable()    (PR_PRPB |= (uint8_t)PR_ADC_bm)
1025:/usr/lib/avr/include/avr/power.h **** #endif
1026:/usr/lib/avr/include/avr/power.h **** 
1027:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPB_DAC)
1028:/usr/lib/avr/include/avr/power.h **** #define power_dacb_enable()     (PR_PRPB &= (uint8_t)~(PR_DAC_bm))
1029:/usr/lib/avr/include/avr/power.h **** #define power_dacb_disable()    (PR_PRPB |= (uint8_t)PR_DAC_bm)
1030:/usr/lib/avr/include/avr/power.h **** #endif
1031:/usr/lib/avr/include/avr/power.h **** 
1032:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPC_HIRES)
1033:/usr/lib/avr/include/avr/power.h **** #define power_hiresc_enable()   (PR_PRPC &= (uint8_t)~(PR_HIRES_bm))
1034:/usr/lib/avr/include/avr/power.h **** #define power_hiresc_disable()  (PR_PRPC |= (uint8_t)PR_HIRES_bm)
1035:/usr/lib/avr/include/avr/power.h **** #endif
1036:/usr/lib/avr/include/avr/power.h **** 
1037:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPC_SPI)
1038:/usr/lib/avr/include/avr/power.h **** #define power_spic_enable()     (PR_PRPC &= (uint8_t)~(PR_SPI_bm))
1039:/usr/lib/avr/include/avr/power.h **** #define power_spic_disable()    (PR_PRPC |= (uint8_t)PR_SPI_bm)
1040:/usr/lib/avr/include/avr/power.h **** #endif
1041:/usr/lib/avr/include/avr/power.h **** 
1042:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPC_TC0)
1043:/usr/lib/avr/include/avr/power.h **** #define power_tc0c_enable()     (PR_PRPC &= (uint8_t)~(PR_TC0_bm))
1044:/usr/lib/avr/include/avr/power.h **** #define power_tc0c_disable()    (PR_PRPC |= (uint8_t)PR_TC0_bm)
1045:/usr/lib/avr/include/avr/power.h **** #endif
1046:/usr/lib/avr/include/avr/power.h **** 
1047:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPC_TC1)
1048:/usr/lib/avr/include/avr/power.h **** #define power_tc1c_enable()     (PR_PRPC &= (uint8_t)~(PR_TC1_bm))
1049:/usr/lib/avr/include/avr/power.h **** #define power_tc1c_disable()    (PR_PRPC |= (uint8_t)PR_TC1_bm)
1050:/usr/lib/avr/include/avr/power.h **** #endif
1051:/usr/lib/avr/include/avr/power.h **** 
1052:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPC_TC4)
1053:/usr/lib/avr/include/avr/power.h **** #define power_tc4c_enable()     (PR_PRPC  &= (uint8_t)~(PR_TC4_bm))
1054:/usr/lib/avr/include/avr/power.h **** #define power_tc4c_disable()    (PR_PRPC  |= (uint8_t)PR_TC4_bm)
1055:/usr/lib/avr/include/avr/power.h **** #endif
1056:/usr/lib/avr/include/avr/power.h **** 
1057:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPC_TC5)
1058:/usr/lib/avr/include/avr/power.h **** #define power_tc5c_enable()     (PR_PRPC  &= (uint8_t)~(PR_TC5_bm))
1059:/usr/lib/avr/include/avr/power.h **** #define power_tc5c_disable()    (PR_PRPC  |= (uint8_t)PR_TC5_bm)
1060:/usr/lib/avr/include/avr/power.h **** #endif
1061:/usr/lib/avr/include/avr/power.h **** 
1062:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPC_TWI)
1063:/usr/lib/avr/include/avr/power.h **** #define power_twic_enable()     (PR_PRPC &= (uint8_t)~(PR_TWI_bm))
1064:/usr/lib/avr/include/avr/power.h **** #define power_twic_disable()    (PR_PRPC |= (uint8_t)PR_TWI_bm)
1065:/usr/lib/avr/include/avr/power.h **** #endif
1066:/usr/lib/avr/include/avr/power.h **** 
1067:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPC_USART0)
1068:/usr/lib/avr/include/avr/power.h **** #define power_usartc0_enable()  (PR_PRPC &= (uint8_t)~(PR_USART0_bm))
1069:/usr/lib/avr/include/avr/power.h **** #define power_usartc0_disable() (PR_PRPC |= (uint8_t)PR_USART0_bm)
1070:/usr/lib/avr/include/avr/power.h **** #endif
1071:/usr/lib/avr/include/avr/power.h **** 
1072:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPC_USART1)
1073:/usr/lib/avr/include/avr/power.h **** #define power_usartc1_enable()  (PR_PRPC &= (uint8_t)~(PR_USART1_bm))
1074:/usr/lib/avr/include/avr/power.h **** #define power_usartc1_disable() (PR_PRPC |= (uint8_t)PR_USART1_bm)
1075:/usr/lib/avr/include/avr/power.h **** #endif
1076:/usr/lib/avr/include/avr/power.h **** 
1077:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPD_HIRES)
1078:/usr/lib/avr/include/avr/power.h **** #define power_hiresd_enable()   (PR_PRPD &= (uint8_t)~(PR_HIRES_bm))
1079:/usr/lib/avr/include/avr/power.h **** #define power_hiresd_disable()  (PR_PRPD |= (uint8_t)PR_HIRES_bm)
1080:/usr/lib/avr/include/avr/power.h **** #endif
1081:/usr/lib/avr/include/avr/power.h **** 
1082:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPD_SPI)
1083:/usr/lib/avr/include/avr/power.h **** #define power_spid_enable()     (PR_PRPD &= (uint8_t)~(PR_SPI_bm))
1084:/usr/lib/avr/include/avr/power.h **** #define power_spid_disable()    (PR_PRPD |= (uint8_t)PR_SPI_bm)
1085:/usr/lib/avr/include/avr/power.h **** #endif
1086:/usr/lib/avr/include/avr/power.h **** 
1087:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPD_TC0)
1088:/usr/lib/avr/include/avr/power.h **** #define power_tc0d_enable()     (PR_PRPD &= (uint8_t)~(PR_TC0_bm))
1089:/usr/lib/avr/include/avr/power.h **** #define power_tc0d_disable()    (PR_PRPD |= (uint8_t)PR_TC0_bm)
1090:/usr/lib/avr/include/avr/power.h **** #endif
1091:/usr/lib/avr/include/avr/power.h **** 
1092:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPD_TC1)
1093:/usr/lib/avr/include/avr/power.h **** #define power_tc1d_enable()     (PR_PRPD &= (uint8_t)~(PR_TC1_bm))
1094:/usr/lib/avr/include/avr/power.h **** #define power_tc1d_disable()    (PR_PRPD |= (uint8_t)PR_TC1_bm)
1095:/usr/lib/avr/include/avr/power.h **** #endif
1096:/usr/lib/avr/include/avr/power.h **** 
1097:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPD_TC5)
1098:/usr/lib/avr/include/avr/power.h **** #define power_tc5d_enable()     (PR_PRPD  &= (uint8_t)~(PR_TC5_bm))
1099:/usr/lib/avr/include/avr/power.h **** #define power_tc5d_disable()    (PR_PRPD  |= (uint8_t)PR_TC5_bm)
1100:/usr/lib/avr/include/avr/power.h **** #endif
1101:/usr/lib/avr/include/avr/power.h **** 
1102:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPD_TWI)
1103:/usr/lib/avr/include/avr/power.h **** #define power_twid_enable()     (PR_PRPD &= (uint8_t)~(PR_TWI_bm))
1104:/usr/lib/avr/include/avr/power.h **** #define power_twid_disable()    (PR_PRPD |= (uint8_t)PR_TWI_bm)
1105:/usr/lib/avr/include/avr/power.h **** #endif
1106:/usr/lib/avr/include/avr/power.h **** 
1107:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPD_USART0)
1108:/usr/lib/avr/include/avr/power.h **** #define power_usartd0_enable()  (PR_PRPD &= (uint8_t)~(PR_USART0_bm))
1109:/usr/lib/avr/include/avr/power.h **** #define power_usartd0_disable() (PR_PRPD |= (uint8_t)PR_USART0_bm)
1110:/usr/lib/avr/include/avr/power.h **** #endif
1111:/usr/lib/avr/include/avr/power.h **** 
1112:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPD_USART1)
1113:/usr/lib/avr/include/avr/power.h **** #define power_usartd1_enable()  (PR_PRPD &= (uint8_t)~(PR_USART1_bm))
1114:/usr/lib/avr/include/avr/power.h **** #define power_usartd1_disable() (PR_PRPD |= (uint8_t)PR_USART1_bm)
1115:/usr/lib/avr/include/avr/power.h **** #endif
1116:/usr/lib/avr/include/avr/power.h **** 
1117:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPE_HIRES)
1118:/usr/lib/avr/include/avr/power.h **** #define power_hirese_enable()   (PR_PRPE &= (uint8_t)~(PR_HIRES_bm))
1119:/usr/lib/avr/include/avr/power.h **** #define power_hirese_disable()  (PR_PRPE |= (uint8_t)PR_HIRES_bm)
1120:/usr/lib/avr/include/avr/power.h **** #endif
1121:/usr/lib/avr/include/avr/power.h **** 
1122:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPE_SPI)
1123:/usr/lib/avr/include/avr/power.h **** #define power_spie_enable()     (PR_PRPE &= (uint8_t)~(PR_SPI_bm))
1124:/usr/lib/avr/include/avr/power.h **** #define power_spie_disable()    (PR_PRPE |= (uint8_t)PR_SPI_bm)
1125:/usr/lib/avr/include/avr/power.h **** #endif
1126:/usr/lib/avr/include/avr/power.h **** 
1127:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPE_TC0)
1128:/usr/lib/avr/include/avr/power.h **** #define power_tc0e_enable()     (PR_PRPE &= (uint8_t)~(PR_TC0_bm))
1129:/usr/lib/avr/include/avr/power.h **** #define power_tc0e_disable()    (PR_PRPE |= (uint8_t)PR_TC0_bm)
1130:/usr/lib/avr/include/avr/power.h **** #endif
1131:/usr/lib/avr/include/avr/power.h **** 
1132:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPE_TC1)
1133:/usr/lib/avr/include/avr/power.h **** #define power_tc1e_enable()     (PR_PRPE &= (uint8_t)~(PR_TC1_bm))
1134:/usr/lib/avr/include/avr/power.h **** #define power_tc1e_disable()    (PR_PRPE |= (uint8_t)PR_TC1_bm)
1135:/usr/lib/avr/include/avr/power.h **** #endif
1136:/usr/lib/avr/include/avr/power.h **** 
1137:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPE_TWI)
1138:/usr/lib/avr/include/avr/power.h **** #define power_twie_enable()     (PR_PRPE &= (uint8_t)~(PR_TWI_bm))
1139:/usr/lib/avr/include/avr/power.h **** #define power_twie_disable()    (PR_PRPE |= (uint8_t)PR_TWI_bm)
1140:/usr/lib/avr/include/avr/power.h **** #endif
1141:/usr/lib/avr/include/avr/power.h **** 
1142:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPE_USART0)
1143:/usr/lib/avr/include/avr/power.h **** #define power_usarte0_enable()  (PR_PRPE &= (uint8_t)~(PR_USART0_bm))
1144:/usr/lib/avr/include/avr/power.h **** #define power_usarte0_disable() (PR_PRPE |= (uint8_t)PR_USART0_bm)
1145:/usr/lib/avr/include/avr/power.h **** #endif
1146:/usr/lib/avr/include/avr/power.h **** 
1147:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPE_USART1)
1148:/usr/lib/avr/include/avr/power.h **** #define power_usarte1_enable()  (PR_PRPE &= (uint8_t)~(PR_USART1_bm))
1149:/usr/lib/avr/include/avr/power.h **** #define power_usarte1_disable() (PR_PRPE |= (uint8_t)PR_USART1_bm)
1150:/usr/lib/avr/include/avr/power.h **** #endif
1151:/usr/lib/avr/include/avr/power.h **** 
1152:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPF_HIRES)
1153:/usr/lib/avr/include/avr/power.h **** #define power_hiresf_enable()   (PR_PRPF &= (uint8_t)~(PR_HIRES_bm))
1154:/usr/lib/avr/include/avr/power.h **** #define power_hiresf_disable()  (PR_PRPF |= (uint8_t)PR_HIRES_bm)
1155:/usr/lib/avr/include/avr/power.h **** #endif
1156:/usr/lib/avr/include/avr/power.h **** 
1157:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPF_SPI)
1158:/usr/lib/avr/include/avr/power.h **** #define power_spif_enable()     (PR_PRPF &= (uint8_t)~(PR_SPI_bm))
1159:/usr/lib/avr/include/avr/power.h **** #define power_spif_disable()    (PR_PRPF |= (uint8_t)PR_SPI_bm)
1160:/usr/lib/avr/include/avr/power.h **** #endif
1161:/usr/lib/avr/include/avr/power.h **** 
1162:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPF_TC0)
1163:/usr/lib/avr/include/avr/power.h **** #define power_tc0f_enable()     (PR_PRPF &= (uint8_t)~(PR_TC0_bm))
1164:/usr/lib/avr/include/avr/power.h **** #define power_tc0f_disable()    (PR_PRPF |= (uint8_t)PR_TC0_bm)
1165:/usr/lib/avr/include/avr/power.h **** #endif
1166:/usr/lib/avr/include/avr/power.h **** 
1167:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPF_TC1)
1168:/usr/lib/avr/include/avr/power.h **** #define power_tc1f_enable()     (PR_PRPF &= (uint8_t)~(PR_TC1_bm))
1169:/usr/lib/avr/include/avr/power.h **** #define power_tc1f_disable()    (PR_PRPF |= (uint8_t)PR_TC1_bm)
1170:/usr/lib/avr/include/avr/power.h **** #endif
1171:/usr/lib/avr/include/avr/power.h **** 
1172:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPF_TWI)
1173:/usr/lib/avr/include/avr/power.h **** #define power_twif_enable()     (PR_PRPF &= (uint8_t)~(PR_TWI_bm))
1174:/usr/lib/avr/include/avr/power.h **** #define power_twif_disable()    (PR_PRPF |= (uint8_t)PR_TWI_bm)
1175:/usr/lib/avr/include/avr/power.h **** #endif
1176:/usr/lib/avr/include/avr/power.h **** 
1177:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPF_USART0)
1178:/usr/lib/avr/include/avr/power.h **** #define power_usartf0_enable()  (PR_PRPF &= (uint8_t)~(PR_USART0_bm))
1179:/usr/lib/avr/include/avr/power.h **** #define power_usartf0_disable() (PR_PRPF |= (uint8_t)PR_USART0_bm)
1180:/usr/lib/avr/include/avr/power.h **** #endif
1181:/usr/lib/avr/include/avr/power.h **** 
1182:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_HAVE_PRPF_USART1)
1183:/usr/lib/avr/include/avr/power.h **** #define power_usartf1_enable()  (PR_PRPF &= (uint8_t)~(PR_USART1_bm))
1184:/usr/lib/avr/include/avr/power.h **** #define power_usartf1_disable() (PR_PRPF |= (uint8_t)PR_USART1_bm)
1185:/usr/lib/avr/include/avr/power.h **** #endif
1186:/usr/lib/avr/include/avr/power.h **** 
1187:/usr/lib/avr/include/avr/power.h **** static __inline void
1188:/usr/lib/avr/include/avr/power.h **** __attribute__ ((__always_inline__))
1189:/usr/lib/avr/include/avr/power.h **** __power_all_enable()
1190:/usr/lib/avr/include/avr/power.h **** {
1191:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRR
1192:/usr/lib/avr/include/avr/power.h ****     PRR &= (uint8_t)~(__AVR_HAVE_PRR);
1193:/usr/lib/avr/include/avr/power.h **** #endif
1194:/usr/lib/avr/include/avr/power.h **** 
1195:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRR0
1196:/usr/lib/avr/include/avr/power.h ****     PRR0 &= (uint8_t)~(__AVR_HAVE_PRR0);
1197:/usr/lib/avr/include/avr/power.h **** #endif
1198:/usr/lib/avr/include/avr/power.h **** 
1199:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRR1
1200:/usr/lib/avr/include/avr/power.h ****     PRR1 &= (uint8_t)~(__AVR_HAVE_PRR1);
1201:/usr/lib/avr/include/avr/power.h **** #endif
1202:/usr/lib/avr/include/avr/power.h **** 
1203:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRR2
1204:/usr/lib/avr/include/avr/power.h ****    PRR2 &= (uint8_t)~(__AVR_HAVE_PRR2);
1205:/usr/lib/avr/include/avr/power.h **** #endif
1206:/usr/lib/avr/include/avr/power.h **** 
1207:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRGEN
1208:/usr/lib/avr/include/avr/power.h ****     PR_PRGEN &= (uint8_t)~(__AVR_HAVE_PRGEN);
1209:/usr/lib/avr/include/avr/power.h **** #endif
1210:/usr/lib/avr/include/avr/power.h **** 
1211:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPA
1212:/usr/lib/avr/include/avr/power.h ****     PR_PRPA &= (uint8_t)~(__AVR_HAVE_PRPA);
1213:/usr/lib/avr/include/avr/power.h **** #endif
1214:/usr/lib/avr/include/avr/power.h **** 
1215:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPB
1216:/usr/lib/avr/include/avr/power.h ****     PR_PRPB &= (uint8_t)~(__AVR_HAVE_PRPB);
1217:/usr/lib/avr/include/avr/power.h **** #endif
1218:/usr/lib/avr/include/avr/power.h **** 
1219:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPC
1220:/usr/lib/avr/include/avr/power.h ****     PR_PRPC &= (uint8_t)~(__AVR_HAVE_PRPC);
1221:/usr/lib/avr/include/avr/power.h **** #endif
1222:/usr/lib/avr/include/avr/power.h **** 
1223:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPD
1224:/usr/lib/avr/include/avr/power.h ****     PR_PRPD &= (uint8_t)~(__AVR_HAVE_PRPD);
1225:/usr/lib/avr/include/avr/power.h **** #endif
1226:/usr/lib/avr/include/avr/power.h **** 
1227:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPE
1228:/usr/lib/avr/include/avr/power.h ****     PR_PRPE &= (uint8_t)~(__AVR_HAVE_PRPE);
1229:/usr/lib/avr/include/avr/power.h **** #endif
1230:/usr/lib/avr/include/avr/power.h **** 
1231:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPF
1232:/usr/lib/avr/include/avr/power.h ****     PR_PRPF &= (uint8_t)~(__AVR_HAVE_PRPF);
1233:/usr/lib/avr/include/avr/power.h **** #endif
1234:/usr/lib/avr/include/avr/power.h **** }
1235:/usr/lib/avr/include/avr/power.h **** 
1236:/usr/lib/avr/include/avr/power.h **** static __inline void
1237:/usr/lib/avr/include/avr/power.h **** __attribute__ ((__always_inline__))
1238:/usr/lib/avr/include/avr/power.h **** __power_all_disable()
1239:/usr/lib/avr/include/avr/power.h **** {
1240:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRR
1241:/usr/lib/avr/include/avr/power.h ****     PRR |= (uint8_t)(__AVR_HAVE_PRR);
1242:/usr/lib/avr/include/avr/power.h **** #endif
1243:/usr/lib/avr/include/avr/power.h **** 
1244:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRR0
1245:/usr/lib/avr/include/avr/power.h ****     PRR0 |= (uint8_t)(__AVR_HAVE_PRR0);
1246:/usr/lib/avr/include/avr/power.h **** #endif
1247:/usr/lib/avr/include/avr/power.h **** 
1248:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRR1
1249:/usr/lib/avr/include/avr/power.h ****     PRR1 |= (uint8_t)(__AVR_HAVE_PRR1);
1250:/usr/lib/avr/include/avr/power.h **** #endif
1251:/usr/lib/avr/include/avr/power.h **** 
1252:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRR2
1253:/usr/lib/avr/include/avr/power.h ****     PRR2 |= (uint8_t)(__AVR_HAVE_PRR2);
1254:/usr/lib/avr/include/avr/power.h **** #endif
1255:/usr/lib/avr/include/avr/power.h **** 
1256:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRGEN
1257:/usr/lib/avr/include/avr/power.h ****     PR_PRGEN |= (uint8_t)(__AVR_HAVE_PRGEN);
1258:/usr/lib/avr/include/avr/power.h **** #endif
1259:/usr/lib/avr/include/avr/power.h **** 
1260:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPA
1261:/usr/lib/avr/include/avr/power.h ****     PR_PRPA |= (uint8_t)(__AVR_HAVE_PRPA);
1262:/usr/lib/avr/include/avr/power.h **** #endif
1263:/usr/lib/avr/include/avr/power.h **** 
1264:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPB
1265:/usr/lib/avr/include/avr/power.h ****     PR_PRPB |= (uint8_t)(__AVR_HAVE_PRPB);
1266:/usr/lib/avr/include/avr/power.h **** #endif
1267:/usr/lib/avr/include/avr/power.h **** 
1268:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPC
1269:/usr/lib/avr/include/avr/power.h ****     PR_PRPC |= (uint8_t)(__AVR_HAVE_PRPC);
1270:/usr/lib/avr/include/avr/power.h **** #endif
1271:/usr/lib/avr/include/avr/power.h **** 
1272:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPD
1273:/usr/lib/avr/include/avr/power.h ****     PR_PRPD |= (uint8_t)(__AVR_HAVE_PRPD);
1274:/usr/lib/avr/include/avr/power.h **** #endif
1275:/usr/lib/avr/include/avr/power.h **** 
1276:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPE
1277:/usr/lib/avr/include/avr/power.h ****     PR_PRPE |= (uint8_t)(__AVR_HAVE_PRPE);
1278:/usr/lib/avr/include/avr/power.h **** #endif
1279:/usr/lib/avr/include/avr/power.h **** 
1280:/usr/lib/avr/include/avr/power.h **** #ifdef __AVR_HAVE_PRPF
1281:/usr/lib/avr/include/avr/power.h ****     PR_PRPF |= (uint8_t)(__AVR_HAVE_PRPF);
1282:/usr/lib/avr/include/avr/power.h **** #endif
1283:/usr/lib/avr/include/avr/power.h **** }
1284:/usr/lib/avr/include/avr/power.h **** 
1285:/usr/lib/avr/include/avr/power.h **** #ifndef __DOXYGEN__
1286:/usr/lib/avr/include/avr/power.h **** #ifndef power_all_enable
1287:/usr/lib/avr/include/avr/power.h **** #define power_all_enable() __power_all_enable()
1288:/usr/lib/avr/include/avr/power.h **** #endif
1289:/usr/lib/avr/include/avr/power.h **** 
1290:/usr/lib/avr/include/avr/power.h **** #ifndef power_all_disable
1291:/usr/lib/avr/include/avr/power.h **** #define power_all_disable() __power_all_disable()
1292:/usr/lib/avr/include/avr/power.h **** #endif
1293:/usr/lib/avr/include/avr/power.h **** #endif	/* !__DOXYGEN__ */
1294:/usr/lib/avr/include/avr/power.h **** 
1295:/usr/lib/avr/include/avr/power.h **** 
1296:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_AT90CAN32__) \
1297:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90CAN64__) \
1298:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90CAN128__) \
1299:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90PWM1__) \
1300:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90PWM2__) \
1301:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90PWM2B__) \
1302:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90PWM3__) \
1303:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90PWM3B__) \
1304:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90PWM81__) \
1305:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90PWM161__) \
1306:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90PWM216__) \
1307:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90PWM316__) \
1308:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90SCR100__) \
1309:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90USB646__) \
1310:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90USB647__) \
1311:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90USB82__) \
1312:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90USB1286__) \
1313:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90USB1287__) \
1314:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90USB162__) \
1315:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATA5505__) \
1316:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATA5272__) \
1317:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATA6617C__) \
1318:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATA664251__) \
1319:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega1280__) \
1320:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega1281__) \
1321:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega1284__) \
1322:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega128RFA1__) \
1323:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega1284RFR2__) \
1324:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega128RFR2__) \
1325:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega1284P__) \
1326:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega162__) \
1327:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega164A__) \
1328:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega164P__) \
1329:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega164PA__) \
1330:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega165__) \
1331:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega165A__) \
1332:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega165P__) \
1333:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega165PA__) \
1334:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega168__) \
1335:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega168A__) \
1336:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega168P__) \
1337:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega168PA__) \
1338:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega168PB__) \
1339:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega169__) \
1340:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega169A__) \
1341:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega169P__) \
1342:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega169PA__) \
1343:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega16M1__) \
1344:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega16U2__) \
1345:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega16U4__) \
1346:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega2560__) \
1347:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega2561__) \
1348:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega2564RFR2__) \
1349:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega256RFR2__) \
1350:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega324A__) \
1351:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega324P__) \
1352:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega324PA__) \
1353:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega325__) \
1354:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega325A__) \
1355:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega325P__) \
1356:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega325PA__) \
1357:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega3250__) \
1358:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega3250A__) \
1359:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega3250P__) \
1360:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega3250PA__) \
1361:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega328__) \
1362:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega328P__) \
1363:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega329__) \
1364:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega329A__) \
1365:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega329P__) \
1366:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega329PA__) \
1367:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega3290__) \
1368:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega3290A__) \
1369:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega3290P__) \
1370:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega3290PA__) \
1371:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega32C1__) \
1372:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega32M1__) \
1373:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega32U2__) \
1374:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega32U4__) \
1375:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega32U6__) \
1376:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega48__) \
1377:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega48A__) \
1378:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega48PA__) \
1379:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega48PB__) \
1380:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega48P__) \
1381:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega640__) \
1382:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega649P__) \
1383:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega644__) \
1384:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega644A__) \
1385:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega644P__) \
1386:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega644PA__) \
1387:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega645__) \
1388:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega645A__) \
1389:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega645P__) \
1390:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega6450__) \
1391:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega6450A__) \
1392:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega6450P__) \
1393:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega649__) \
1394:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega649A__) \
1395:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega64M1__) \
1396:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega64C1__) \
1397:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega88A__) \
1398:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega88PA__) \
1399:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega88PB__) \
1400:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega6490__) \
1401:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega6490A__) \
1402:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega6490P__) \
1403:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega644RFR2__) \
1404:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega64RFR2__) \
1405:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega88__) \
1406:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega88P__) \
1407:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega8U2__) \
1408:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega16U2__) \
1409:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega32U2__) \
1410:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATtiny48__) \
1411:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATtiny88__) \
1412:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATtiny87__) \
1413:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATtiny167__) \
1414:/usr/lib/avr/include/avr/power.h **** || defined(__DOXYGEN__)
1415:/usr/lib/avr/include/avr/power.h **** 
1416:/usr/lib/avr/include/avr/power.h **** 
1417:/usr/lib/avr/include/avr/power.h **** /** \addtogroup avr_power
1418:/usr/lib/avr/include/avr/power.h **** 
1419:/usr/lib/avr/include/avr/power.h **** Some of the newer AVRs contain a System Clock Prescale Register (CLKPR) that
1420:/usr/lib/avr/include/avr/power.h **** allows you to decrease the system clock frequency and the power consumption
1421:/usr/lib/avr/include/avr/power.h **** when the need for processing power is low.
1422:/usr/lib/avr/include/avr/power.h **** On some earlier AVRs (ATmega103, ATmega64, ATmega128), similar
1423:/usr/lib/avr/include/avr/power.h **** functionality can be achieved through the XTAL Divide Control Register.
1424:/usr/lib/avr/include/avr/power.h **** Below are two macros and an enumerated type that can be used to
1425:/usr/lib/avr/include/avr/power.h **** interface to the Clock Prescale Register or
1426:/usr/lib/avr/include/avr/power.h **** XTAL Divide Control Register.
1427:/usr/lib/avr/include/avr/power.h **** 
1428:/usr/lib/avr/include/avr/power.h **** \note Not all AVR devices have a clock prescaler. On those devices
1429:/usr/lib/avr/include/avr/power.h **** without a Clock Prescale Register or XTAL Divide Control Register, these
1430:/usr/lib/avr/include/avr/power.h **** macros are not available.
1431:/usr/lib/avr/include/avr/power.h **** */
1432:/usr/lib/avr/include/avr/power.h **** 
1433:/usr/lib/avr/include/avr/power.h **** 
1434:/usr/lib/avr/include/avr/power.h **** /** \addtogroup avr_power
1435:/usr/lib/avr/include/avr/power.h **** \code 
1436:/usr/lib/avr/include/avr/power.h **** typedef enum
1437:/usr/lib/avr/include/avr/power.h **** {
1438:/usr/lib/avr/include/avr/power.h ****     clock_div_1 = 0,
1439:/usr/lib/avr/include/avr/power.h ****     clock_div_2 = 1,
1440:/usr/lib/avr/include/avr/power.h ****     clock_div_4 = 2,
1441:/usr/lib/avr/include/avr/power.h ****     clock_div_8 = 3,
1442:/usr/lib/avr/include/avr/power.h ****     clock_div_16 = 4,
1443:/usr/lib/avr/include/avr/power.h ****     clock_div_32 = 5,
1444:/usr/lib/avr/include/avr/power.h ****     clock_div_64 = 6,
1445:/usr/lib/avr/include/avr/power.h ****     clock_div_128 = 7,
1446:/usr/lib/avr/include/avr/power.h ****     clock_div_256 = 8,
1447:/usr/lib/avr/include/avr/power.h ****     clock_div_1_rc = 15, // ATmega128RFA1 only
1448:/usr/lib/avr/include/avr/power.h **** } clock_div_t;
1449:/usr/lib/avr/include/avr/power.h **** \endcode
1450:/usr/lib/avr/include/avr/power.h **** Clock prescaler setting enumerations for device using
1451:/usr/lib/avr/include/avr/power.h **** System Clock Prescale Register.
1452:/usr/lib/avr/include/avr/power.h **** 
1453:/usr/lib/avr/include/avr/power.h **** \code
1454:/usr/lib/avr/include/avr/power.h **** typedef enum
1455:/usr/lib/avr/include/avr/power.h **** {
1456:/usr/lib/avr/include/avr/power.h ****     clock_div_1 = 1,
1457:/usr/lib/avr/include/avr/power.h ****     clock_div_2 = 2,
1458:/usr/lib/avr/include/avr/power.h ****     clock_div_4 = 4,
1459:/usr/lib/avr/include/avr/power.h ****     clock_div_8 = 8,
1460:/usr/lib/avr/include/avr/power.h ****     clock_div_16 = 16,
1461:/usr/lib/avr/include/avr/power.h ****     clock_div_32 = 32,
1462:/usr/lib/avr/include/avr/power.h ****     clock_div_64 = 64,
1463:/usr/lib/avr/include/avr/power.h ****     clock_div_128 = 128
1464:/usr/lib/avr/include/avr/power.h **** } clock_div_t;
1465:/usr/lib/avr/include/avr/power.h **** \endcode
1466:/usr/lib/avr/include/avr/power.h **** Clock prescaler setting enumerations for device using
1467:/usr/lib/avr/include/avr/power.h **** XTAL Divide Control Register.
1468:/usr/lib/avr/include/avr/power.h **** 
1469:/usr/lib/avr/include/avr/power.h **** */
1470:/usr/lib/avr/include/avr/power.h **** #ifndef __DOXYGEN__
1471:/usr/lib/avr/include/avr/power.h **** typedef enum
1472:/usr/lib/avr/include/avr/power.h **** {
1473:/usr/lib/avr/include/avr/power.h ****     clock_div_1 = 0,
1474:/usr/lib/avr/include/avr/power.h ****     clock_div_2 = 1,
1475:/usr/lib/avr/include/avr/power.h ****     clock_div_4 = 2,
1476:/usr/lib/avr/include/avr/power.h ****     clock_div_8 = 3,
1477:/usr/lib/avr/include/avr/power.h ****     clock_div_16 = 4,
1478:/usr/lib/avr/include/avr/power.h ****     clock_div_32 = 5,
1479:/usr/lib/avr/include/avr/power.h ****     clock_div_64 = 6,
1480:/usr/lib/avr/include/avr/power.h ****     clock_div_128 = 7,
1481:/usr/lib/avr/include/avr/power.h ****     clock_div_256 = 8
1482:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_ATmega128RFA1__) \
1483:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega2564RFR2__) \
1484:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega1284RFR2__) \
1485:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega644RFR2__) \
1486:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega256RFR2__) \
1487:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega128RFR2__) \
1488:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega64RFR2__)
1489:/usr/lib/avr/include/avr/power.h ****     , clock_div_1_rc = 15
1490:/usr/lib/avr/include/avr/power.h **** #endif
1491:/usr/lib/avr/include/avr/power.h **** } clock_div_t;
1492:/usr/lib/avr/include/avr/power.h **** 
1493:/usr/lib/avr/include/avr/power.h **** static __inline__ void clock_prescale_set(clock_div_t) __attribute__((__always_inline__));
1494:/usr/lib/avr/include/avr/power.h **** #endif	/* !__DOXYGEN__ */
1495:/usr/lib/avr/include/avr/power.h **** 
1496:/usr/lib/avr/include/avr/power.h **** /**
1497:/usr/lib/avr/include/avr/power.h ****    \ingroup avr_power
1498:/usr/lib/avr/include/avr/power.h ****    \fn clock_prescale_set(clock_div_t x)
1499:/usr/lib/avr/include/avr/power.h **** 
1500:/usr/lib/avr/include/avr/power.h **** Set the clock prescaler register select bits, selecting a system clock
1501:/usr/lib/avr/include/avr/power.h **** division setting. This function is inlined, even if compiler
1502:/usr/lib/avr/include/avr/power.h **** optimizations are disabled.
1503:/usr/lib/avr/include/avr/power.h **** 
1504:/usr/lib/avr/include/avr/power.h **** The type of \c x is \c clock_div_t.
1505:/usr/lib/avr/include/avr/power.h **** 
1506:/usr/lib/avr/include/avr/power.h **** \note For device with XTAL Divide Control Register (XDIV), \c x can actually range
1507:/usr/lib/avr/include/avr/power.h **** from 1 to 129. Thus, one does not need to use \c clock_div_t type as argument.
1508:/usr/lib/avr/include/avr/power.h **** */
1509:/usr/lib/avr/include/avr/power.h **** void clock_prescale_set(clock_div_t __x)
1510:/usr/lib/avr/include/avr/power.h **** {
1511:/usr/lib/avr/include/avr/power.h ****     uint8_t __tmp = _BV(CLKPCE);
1512:/usr/lib/avr/include/avr/power.h ****     __asm__ __volatile__ (
 2023               		.loc 5 1512 0
 2024 09ee 90E0      		ldi r25,0
 2025 09f0 80E8      		ldi r24,lo8(-128)
 2026               	/* #APP */
 2027               	 ;  1512 "/usr/lib/avr/include/avr/power.h" 1
 2028 09f2 0FB6      		in __tmp_reg__,__SREG__
 2029 09f4 F894      		cli
 2030 09f6 8093 6100 		sts 97, r24
 2031 09fa 9093 6100 		sts 97, r25
 2032 09fe 0FBE      		out __SREG__, __tmp_reg__
 2033               	 ;  0 "" 2
 2034               	.LVL85:
 2035               	/* #NOAPP */
 2036               	.LBE102:
 2037               	.LBE101:
 2038               	.LBB103:
 2039               	.LBB104:
 187:/usr/lib/avr/include/util/delay.h **** 
 2040               		.loc 3 187 0
 2041 0a00 2FEF      		ldi r18,lo8(319999)
 2042 0a02 81EE      		ldi r24,hi8(319999)
 2043 0a04 94E0      		ldi r25,hlo8(319999)
 2044 0a06 2150      	1:	subi r18,1
 2045 0a08 8040      		sbci r24,0
 2046 0a0a 9040      		sbci r25,0
 2047 0a0c 01F4      		brne 1b
 2048 0a0e 00C0      		rjmp .
 2049 0a10 0000      		nop
 2050               	.LVL86:
 2051               	.LBE104:
 2052               	.LBE103:
 700:main.c        **** 	clock_prescale_set(clock_div_1);
 701:main.c        **** 
 702:main.c        ****         _delay_ms(100);
 703:main.c        **** 
 704:main.c        **** 	I2C_init(I2C_ADDR);
 2053               		.loc 4 704 0
 2054 0a12 8AE2      		ldi r24,lo8(42)
 2055 0a14 0E94 0000 		call I2C_init
 2056               	.LVL87:
 705:main.c        **** 
 706:main.c        **** 	PCICR |= _BV(PCIE0);		 // enable pin change interrupt for PB0 (rpm)
 2057               		.loc 4 706 0
 2058 0a18 E8E6      		ldi r30,lo8(104)
 2059 0a1a F0E0      		ldi r31,0
 2060 0a1c 8081      		ld r24,Z
 2061 0a1e 8160      		ori r24,lo8(1)
 2062 0a20 8083      		st Z,r24
 707:main.c        **** 	PCMSK0 |= _BV(PCINT0);
 2063               		.loc 4 707 0
 2064 0a22 EBE6      		ldi r30,lo8(107)
 2065 0a24 F0E0      		ldi r31,0
 2066 0a26 8081      		ld r24,Z
 2067 0a28 8160      		ori r24,lo8(1)
 2068 0a2a 8083      		st Z,r24
 708:main.c        **** 
 709:main.c        **** 	sei();
 2069               		.loc 4 709 0
 2070               	/* #APP */
 2071               	 ;  709 "main.c" 1
 2072 0a2c 7894      		sei
 2073               	 ;  0 "" 2
 710:main.c        **** 
 711:main.c        **** 	led[0].r = 255;
 2074               		.loc 4 711 0
 2075               	/* #NOAPP */
 2076 0a2e C0E0      		ldi r28,lo8(led)
 2077 0a30 D0E0      		ldi r29,hi8(led)
 2078 0a32 8FEF      		ldi r24,lo8(-1)
 2079 0a34 8983      		std Y+1,r24
 712:main.c        **** 	led[0].g = 255;
 2080               		.loc 4 712 0
 2081 0a36 8883      		st Y,r24
 713:main.c        **** 	led[0].b = 255;
 2082               		.loc 4 713 0
 2083 0a38 8A83      		std Y+2,r24
 714:main.c        **** 
 715:main.c        **** 	ws2812_setleds(led,2);
 2084               		.loc 4 715 0
 2085 0a3a 62E0      		ldi r22,lo8(2)
 2086 0a3c 70E0      		ldi r23,0
 2087 0a3e CE01      		movw r24,r28
 2088 0a40 0E94 0000 		call ws2812_setleds
 2089               	.LVL88:
 716:main.c        **** 
 717:main.c        **** 	setup_lcd();
 2090               		.loc 4 717 0
 2091 0a44 0E94 0000 		call setup_lcd
 2092               	.LVL89:
 718:main.c        **** 
 719:main.c        **** 	init_backlight();
 2093               		.loc 4 719 0
 2094 0a48 0E94 0000 		call init_backlight
 2095               	.LVL90:
 720:main.c        **** 
 721:main.c        **** 	led[0].r = 0;
 2096               		.loc 4 721 0
 2097 0a4c 1982      		std Y+1,__zero_reg__
 722:main.c        **** 	led[0].g = 0;
 2098               		.loc 4 722 0
 2099 0a4e 1882      		st Y,__zero_reg__
 723:main.c        **** 	led[0].b = 0;
 2100               		.loc 4 723 0
 2101 0a50 1A82      		std Y+2,__zero_reg__
 724:main.c        **** 
 725:main.c        **** 	ws2812_setleds(led,1);
 2102               		.loc 4 725 0
 2103 0a52 61E0      		ldi r22,lo8(1)
 2104 0a54 70E0      		ldi r23,0
 2105 0a56 CE01      		movw r24,r28
 2106 0a58 0E94 0000 		call ws2812_setleds
 2107               	.LVL91:
 726:main.c        **** 
 727:main.c        **** 	OCR0A = 210;
 2108               		.loc 4 727 0
 2109 0a5c 82ED      		ldi r24,lo8(-46)
 2110 0a5e 87BD      		out 0x27,r24
 2111               	.LVL92:
 2112               	.LBB105:
 2113               	.LBB106:
 2114               		.file 6 "/usr/lib/avr/include/avr/wdt.h"
   1:/usr/lib/avr/include/avr/wdt.h **** /* Copyright (c) 2002, 2004 Marek Michalkiewicz
   2:/usr/lib/avr/include/avr/wdt.h ****    Copyright (c) 2005, 2006, 2007 Eric B. Weddington
   3:/usr/lib/avr/include/avr/wdt.h ****    All rights reserved.
   4:/usr/lib/avr/include/avr/wdt.h **** 
   5:/usr/lib/avr/include/avr/wdt.h ****    Redistribution and use in source and binary forms, with or without
   6:/usr/lib/avr/include/avr/wdt.h ****    modification, are permitted provided that the following conditions are met:
   7:/usr/lib/avr/include/avr/wdt.h **** 
   8:/usr/lib/avr/include/avr/wdt.h ****    * Redistributions of source code must retain the above copyright
   9:/usr/lib/avr/include/avr/wdt.h ****      notice, this list of conditions and the following disclaimer.
  10:/usr/lib/avr/include/avr/wdt.h **** 
  11:/usr/lib/avr/include/avr/wdt.h ****    * Redistributions in binary form must reproduce the above copyright
  12:/usr/lib/avr/include/avr/wdt.h ****      notice, this list of conditions and the following disclaimer in
  13:/usr/lib/avr/include/avr/wdt.h ****      the documentation and/or other materials provided with the
  14:/usr/lib/avr/include/avr/wdt.h ****      distribution.
  15:/usr/lib/avr/include/avr/wdt.h **** 
  16:/usr/lib/avr/include/avr/wdt.h ****    * Neither the name of the copyright holders nor the names of
  17:/usr/lib/avr/include/avr/wdt.h ****      contributors may be used to endorse or promote products derived
  18:/usr/lib/avr/include/avr/wdt.h ****      from this software without specific prior written permission.
  19:/usr/lib/avr/include/avr/wdt.h **** 
  20:/usr/lib/avr/include/avr/wdt.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:/usr/lib/avr/include/avr/wdt.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:/usr/lib/avr/include/avr/wdt.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:/usr/lib/avr/include/avr/wdt.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:/usr/lib/avr/include/avr/wdt.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:/usr/lib/avr/include/avr/wdt.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:/usr/lib/avr/include/avr/wdt.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:/usr/lib/avr/include/avr/wdt.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:/usr/lib/avr/include/avr/wdt.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:/usr/lib/avr/include/avr/wdt.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:/usr/lib/avr/include/avr/wdt.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:/usr/lib/avr/include/avr/wdt.h **** 
  32:/usr/lib/avr/include/avr/wdt.h **** /* $Id$ */
  33:/usr/lib/avr/include/avr/wdt.h **** 
  34:/usr/lib/avr/include/avr/wdt.h **** /*
  35:/usr/lib/avr/include/avr/wdt.h ****    avr/wdt.h - macros for AVR watchdog timer
  36:/usr/lib/avr/include/avr/wdt.h ****  */
  37:/usr/lib/avr/include/avr/wdt.h **** 
  38:/usr/lib/avr/include/avr/wdt.h **** #ifndef _AVR_WDT_H_
  39:/usr/lib/avr/include/avr/wdt.h **** #define _AVR_WDT_H_
  40:/usr/lib/avr/include/avr/wdt.h **** 
  41:/usr/lib/avr/include/avr/wdt.h **** #include <avr/io.h>
  42:/usr/lib/avr/include/avr/wdt.h **** #include <stdint.h>
  43:/usr/lib/avr/include/avr/wdt.h **** 
  44:/usr/lib/avr/include/avr/wdt.h **** /** \file */
  45:/usr/lib/avr/include/avr/wdt.h **** /** \defgroup avr_watchdog <avr/wdt.h>: Watchdog timer handling
  46:/usr/lib/avr/include/avr/wdt.h ****     \code #include <avr/wdt.h> \endcode
  47:/usr/lib/avr/include/avr/wdt.h **** 
  48:/usr/lib/avr/include/avr/wdt.h ****     This header file declares the interface to some inline macros
  49:/usr/lib/avr/include/avr/wdt.h ****     handling the watchdog timer present in many AVR devices.  In order
  50:/usr/lib/avr/include/avr/wdt.h ****     to prevent the watchdog timer configuration from being
  51:/usr/lib/avr/include/avr/wdt.h ****     accidentally altered by a crashing application, a special timed
  52:/usr/lib/avr/include/avr/wdt.h ****     sequence is required in order to change it.  The macros within
  53:/usr/lib/avr/include/avr/wdt.h ****     this header file handle the required sequence automatically
  54:/usr/lib/avr/include/avr/wdt.h ****     before changing any value.  Interrupts will be disabled during
  55:/usr/lib/avr/include/avr/wdt.h ****     the manipulation.
  56:/usr/lib/avr/include/avr/wdt.h **** 
  57:/usr/lib/avr/include/avr/wdt.h ****     \note Depending on the fuse configuration of the particular
  58:/usr/lib/avr/include/avr/wdt.h ****     device, further restrictions might apply, in particular it might
  59:/usr/lib/avr/include/avr/wdt.h ****     be disallowed to turn off the watchdog timer.
  60:/usr/lib/avr/include/avr/wdt.h **** 
  61:/usr/lib/avr/include/avr/wdt.h ****     Note that for newer devices (ATmega88 and newer, effectively any
  62:/usr/lib/avr/include/avr/wdt.h ****     AVR that has the option to also generate interrupts), the watchdog
  63:/usr/lib/avr/include/avr/wdt.h ****     timer remains active even after a system reset (except a power-on
  64:/usr/lib/avr/include/avr/wdt.h ****     condition), using the fastest prescaler value (approximately 15
  65:/usr/lib/avr/include/avr/wdt.h ****     ms).  It is therefore required to turn off the watchdog early
  66:/usr/lib/avr/include/avr/wdt.h ****     during program startup, the datasheet recommends a sequence like
  67:/usr/lib/avr/include/avr/wdt.h ****     the following:
  68:/usr/lib/avr/include/avr/wdt.h **** 
  69:/usr/lib/avr/include/avr/wdt.h ****     \code
  70:/usr/lib/avr/include/avr/wdt.h ****     #include <stdint.h>
  71:/usr/lib/avr/include/avr/wdt.h ****     #include <avr/wdt.h>
  72:/usr/lib/avr/include/avr/wdt.h **** 
  73:/usr/lib/avr/include/avr/wdt.h ****     uint8_t mcusr_mirror __attribute__ ((section (".noinit")));
  74:/usr/lib/avr/include/avr/wdt.h **** 
  75:/usr/lib/avr/include/avr/wdt.h ****     void get_mcusr(void) \
  76:/usr/lib/avr/include/avr/wdt.h ****       __attribute__((naked)) \
  77:/usr/lib/avr/include/avr/wdt.h ****       __attribute__((section(".init3")));
  78:/usr/lib/avr/include/avr/wdt.h ****     void get_mcusr(void)
  79:/usr/lib/avr/include/avr/wdt.h ****     {
  80:/usr/lib/avr/include/avr/wdt.h ****       mcusr_mirror = MCUSR;
  81:/usr/lib/avr/include/avr/wdt.h ****       MCUSR = 0;
  82:/usr/lib/avr/include/avr/wdt.h ****       wdt_disable();
  83:/usr/lib/avr/include/avr/wdt.h ****     }
  84:/usr/lib/avr/include/avr/wdt.h ****     \endcode
  85:/usr/lib/avr/include/avr/wdt.h **** 
  86:/usr/lib/avr/include/avr/wdt.h ****     Saving the value of MCUSR in \c mcusr_mirror is only needed if the
  87:/usr/lib/avr/include/avr/wdt.h ****     application later wants to examine the reset source, but in particular, 
  88:/usr/lib/avr/include/avr/wdt.h ****     clearing the watchdog reset flag before disabling the
  89:/usr/lib/avr/include/avr/wdt.h ****     watchdog is required, according to the datasheet.
  90:/usr/lib/avr/include/avr/wdt.h **** */
  91:/usr/lib/avr/include/avr/wdt.h **** 
  92:/usr/lib/avr/include/avr/wdt.h **** /**
  93:/usr/lib/avr/include/avr/wdt.h ****    \ingroup avr_watchdog
  94:/usr/lib/avr/include/avr/wdt.h ****    Reset the watchdog timer.  When the watchdog timer is enabled,
  95:/usr/lib/avr/include/avr/wdt.h ****    a call to this instruction is required before the timer expires,
  96:/usr/lib/avr/include/avr/wdt.h ****    otherwise a watchdog-initiated device reset will occur. 
  97:/usr/lib/avr/include/avr/wdt.h **** */
  98:/usr/lib/avr/include/avr/wdt.h **** 
  99:/usr/lib/avr/include/avr/wdt.h **** #define wdt_reset() __asm__ __volatile__ ("wdr")
 100:/usr/lib/avr/include/avr/wdt.h **** 
 101:/usr/lib/avr/include/avr/wdt.h **** #ifndef __DOXYGEN__
 102:/usr/lib/avr/include/avr/wdt.h **** 
 103:/usr/lib/avr/include/avr/wdt.h **** #if defined(WDP3)
 104:/usr/lib/avr/include/avr/wdt.h **** # define _WD_PS3_MASK       _BV(WDP3)
 105:/usr/lib/avr/include/avr/wdt.h **** #else
 106:/usr/lib/avr/include/avr/wdt.h **** # define _WD_PS3_MASK       0x00
 107:/usr/lib/avr/include/avr/wdt.h **** #endif
 108:/usr/lib/avr/include/avr/wdt.h **** 
 109:/usr/lib/avr/include/avr/wdt.h **** #if defined(WDTCSR)
 110:/usr/lib/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDTCSR
 111:/usr/lib/avr/include/avr/wdt.h **** #elif defined(WDTCR)
 112:/usr/lib/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDTCR
 113:/usr/lib/avr/include/avr/wdt.h **** #else
 114:/usr/lib/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDT
 115:/usr/lib/avr/include/avr/wdt.h **** #endif
 116:/usr/lib/avr/include/avr/wdt.h **** 
 117:/usr/lib/avr/include/avr/wdt.h **** #if defined(WDTOE)
 118:/usr/lib/avr/include/avr/wdt.h **** #define _WD_CHANGE_BIT      WDTOE
 119:/usr/lib/avr/include/avr/wdt.h **** #else
 120:/usr/lib/avr/include/avr/wdt.h **** #define _WD_CHANGE_BIT      WDCE
 121:/usr/lib/avr/include/avr/wdt.h **** #endif
 122:/usr/lib/avr/include/avr/wdt.h **** 
 123:/usr/lib/avr/include/avr/wdt.h **** #endif	/* !__DOXYGEN__ */
 124:/usr/lib/avr/include/avr/wdt.h **** 
 125:/usr/lib/avr/include/avr/wdt.h **** 
 126:/usr/lib/avr/include/avr/wdt.h **** /**
 127:/usr/lib/avr/include/avr/wdt.h ****    \ingroup avr_watchdog
 128:/usr/lib/avr/include/avr/wdt.h ****    Enable the watchdog timer, configuring it for expiry after
 129:/usr/lib/avr/include/avr/wdt.h ****    \c timeout (which is a combination of the \c WDP0 through
 130:/usr/lib/avr/include/avr/wdt.h ****    \c WDP2 bits to write into the \c WDTCR register; For those devices 
 131:/usr/lib/avr/include/avr/wdt.h ****    that have a \c WDTCSR register, it uses the combination of the \c WDP0 
 132:/usr/lib/avr/include/avr/wdt.h ****    through \c WDP3 bits).
 133:/usr/lib/avr/include/avr/wdt.h **** 
 134:/usr/lib/avr/include/avr/wdt.h ****    See also the symbolic constants \c WDTO_15MS et al.
 135:/usr/lib/avr/include/avr/wdt.h **** */
 136:/usr/lib/avr/include/avr/wdt.h **** 
 137:/usr/lib/avr/include/avr/wdt.h **** 
 138:/usr/lib/avr/include/avr/wdt.h **** #if defined(__AVR_XMEGA__)
 139:/usr/lib/avr/include/avr/wdt.h **** 
 140:/usr/lib/avr/include/avr/wdt.h **** #if defined (WDT_CTRLA) && !defined(RAMPD)
 141:/usr/lib/avr/include/avr/wdt.h **** 
 142:/usr/lib/avr/include/avr/wdt.h **** #define wdt_enable(timeout) \
 143:/usr/lib/avr/include/avr/wdt.h **** do { \
 144:/usr/lib/avr/include/avr/wdt.h **** uint8_t temp; \
 145:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 146:/usr/lib/avr/include/avr/wdt.h **** 	"wdr"									"\n\t" \
 147:/usr/lib/avr/include/avr/wdt.h **** 	"out %[ccp_reg], %[ioreg_cen_mask]"		"\n\t" \
 148:/usr/lib/avr/include/avr/wdt.h **** 	"lds %[tmp], %[wdt_reg]"				"\n\t" \
 149:/usr/lib/avr/include/avr/wdt.h **** 	"sbr %[tmp], %[wdt_enable_timeout]"		"\n\t" \
 150:/usr/lib/avr/include/avr/wdt.h **** 	"sts %[wdt_reg], %[tmp]"				"\n\t" \
 151:/usr/lib/avr/include/avr/wdt.h **** 	"1:lds %[tmp], %[wdt_status_reg]"		"\n\t" \
 152:/usr/lib/avr/include/avr/wdt.h **** 	"sbrc %[tmp], %[wdt_syncbusy_bit]"		"\n\t" \
 153:/usr/lib/avr/include/avr/wdt.h **** 	"rjmp 1b"								"\n\t" \
 154:/usr/lib/avr/include/avr/wdt.h **** 	: [tmp]					"=r" (temp) \
 155:/usr/lib/avr/include/avr/wdt.h **** 	: [ccp_reg]				"I"  (_SFR_IO_ADDR(CCP)), \
 156:/usr/lib/avr/include/avr/wdt.h **** 	  [ioreg_cen_mask]		"r"  ((uint8_t)CCP_IOREG_gc), \
 157:/usr/lib/avr/include/avr/wdt.h **** 	  [wdt_reg]				"n"  (_SFR_MEM_ADDR(WDT_CTRLA)), \
 158:/usr/lib/avr/include/avr/wdt.h **** 	  [wdt_enable_timeout]	"M"  (timeout), \
 159:/usr/lib/avr/include/avr/wdt.h **** 	  [wdt_status_reg]		"n"  (_SFR_MEM_ADDR(WDT_STATUS)), \
 160:/usr/lib/avr/include/avr/wdt.h **** 	  [wdt_syncbusy_bit]	"I"  (WDT_SYNCBUSY_bm) \
 161:/usr/lib/avr/include/avr/wdt.h **** ); \
 162:/usr/lib/avr/include/avr/wdt.h **** } while(0)
 163:/usr/lib/avr/include/avr/wdt.h **** 
 164:/usr/lib/avr/include/avr/wdt.h **** #define wdt_disable() \
 165:/usr/lib/avr/include/avr/wdt.h **** do { \
 166:/usr/lib/avr/include/avr/wdt.h **** uint8_t temp; \
 167:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ (  \
 168:/usr/lib/avr/include/avr/wdt.h **** 	"wdr"								"\n\t" \
 169:/usr/lib/avr/include/avr/wdt.h **** 	"out %[ccp_reg], %[ioreg_cen_mask]" "\n\t" \
 170:/usr/lib/avr/include/avr/wdt.h **** 	"lds %[tmp], %[wdt_reg]"			"\n\t" \
 171:/usr/lib/avr/include/avr/wdt.h **** 	"cbr %[tmp], %[timeout_mask]"       "\n\t" \
 172:/usr/lib/avr/include/avr/wdt.h **** 	"sts %[wdt_reg], %[tmp]"			"\n\t" \
 173:/usr/lib/avr/include/avr/wdt.h ****     : [tmp]            "=r" (temp) \
 174:/usr/lib/avr/include/avr/wdt.h ****     : [ccp_reg]        "I" (_SFR_IO_ADDR(CCP)),       \
 175:/usr/lib/avr/include/avr/wdt.h ****       [ioreg_cen_mask] "r" ((uint8_t)CCP_IOREG_gc),   \
 176:/usr/lib/avr/include/avr/wdt.h ****       [wdt_reg]        "n" (_SFR_MEM_ADDR(WDT_CTRLA)),\
 177:/usr/lib/avr/include/avr/wdt.h ****       [timeout_mask]   "I" (WDT_PERIOD_gm) \
 178:/usr/lib/avr/include/avr/wdt.h **** ); \
 179:/usr/lib/avr/include/avr/wdt.h **** } while(0)
 180:/usr/lib/avr/include/avr/wdt.h **** 
 181:/usr/lib/avr/include/avr/wdt.h **** #else // defined (WDT_CTRLA) && !defined(RAMPD)
 182:/usr/lib/avr/include/avr/wdt.h **** 
 183:/usr/lib/avr/include/avr/wdt.h **** /*
 184:/usr/lib/avr/include/avr/wdt.h ****    wdt_enable(timeout) for xmega devices
 185:/usr/lib/avr/include/avr/wdt.h **** ** write signature (CCP_IOREG_gc) that enables change of protected I/O
 186:/usr/lib/avr/include/avr/wdt.h ****    registers to the CCP register
 187:/usr/lib/avr/include/avr/wdt.h **** ** At the same time,
 188:/usr/lib/avr/include/avr/wdt.h ****    1) set WDT change enable (WDT_CEN_bm)
 189:/usr/lib/avr/include/avr/wdt.h ****    2) enable WDT (WDT_ENABLE_bm)
 190:/usr/lib/avr/include/avr/wdt.h ****    3) set timeout (timeout)
 191:/usr/lib/avr/include/avr/wdt.h **** ** Synchronization starts when ENABLE bit of WDT is set. So, wait till it
 192:/usr/lib/avr/include/avr/wdt.h ****    finishes (SYNCBUSY of STATUS register is automatically cleared after the
 193:/usr/lib/avr/include/avr/wdt.h ****    sync is finished).
 194:/usr/lib/avr/include/avr/wdt.h **** */
 195:/usr/lib/avr/include/avr/wdt.h **** #define wdt_enable(timeout) \
 196:/usr/lib/avr/include/avr/wdt.h **** do { \
 197:/usr/lib/avr/include/avr/wdt.h **** uint8_t temp; \
 198:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ (         \
 199:/usr/lib/avr/include/avr/wdt.h ****     "in __tmp_reg__, %[rampd]"              "\n\t" \
 200:/usr/lib/avr/include/avr/wdt.h ****     "out %[rampd], __zero_reg__"            "\n\t" \
 201:/usr/lib/avr/include/avr/wdt.h ****     "out %[ccp_reg], %[ioreg_cen_mask]"     "\n\t" \
 202:/usr/lib/avr/include/avr/wdt.h ****     "sts %[wdt_reg], %[wdt_enable_timeout]" "\n\t" \
 203:/usr/lib/avr/include/avr/wdt.h ****     "1:lds %[tmp], %[wdt_status_reg]"       "\n\t" \
 204:/usr/lib/avr/include/avr/wdt.h ****     "sbrc %[tmp], %[wdt_syncbusy_bit]"      "\n\t" \
 205:/usr/lib/avr/include/avr/wdt.h ****     "rjmp 1b"                               "\n\t" \
 206:/usr/lib/avr/include/avr/wdt.h ****     "out %[rampd], __tmp_reg__"             "\n\t" \
 207:/usr/lib/avr/include/avr/wdt.h ****     : [tmp]                "=r" (temp) \
 208:/usr/lib/avr/include/avr/wdt.h ****     : [rampd]              "I" (_SFR_IO_ADDR(RAMPD)),      \
 209:/usr/lib/avr/include/avr/wdt.h ****       [ccp_reg]            "I" (_SFR_IO_ADDR(CCP)),        \
 210:/usr/lib/avr/include/avr/wdt.h ****       [ioreg_cen_mask]     "r" ((uint8_t)CCP_IOREG_gc),     \
 211:/usr/lib/avr/include/avr/wdt.h ****       [wdt_reg]            "n" (_SFR_MEM_ADDR(WDT_CTRL)),   \
 212:/usr/lib/avr/include/avr/wdt.h ****       [wdt_enable_timeout] "r" ((uint8_t)(WDT_CEN_bm | WDT_ENABLE_bm | timeout)), \
 213:/usr/lib/avr/include/avr/wdt.h ****       [wdt_status_reg]     "n" (_SFR_MEM_ADDR(WDT_STATUS)), \
 214:/usr/lib/avr/include/avr/wdt.h ****       [wdt_syncbusy_bit]   "I" (WDT_SYNCBUSY_bm)            \
 215:/usr/lib/avr/include/avr/wdt.h ****     : "r0" \
 216:/usr/lib/avr/include/avr/wdt.h **** ); \
 217:/usr/lib/avr/include/avr/wdt.h **** } while(0)
 218:/usr/lib/avr/include/avr/wdt.h **** 
 219:/usr/lib/avr/include/avr/wdt.h **** #define wdt_disable() \
 220:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ (  \
 221:/usr/lib/avr/include/avr/wdt.h ****     "in __tmp_reg__, %[rampd]"          "\n\t" \
 222:/usr/lib/avr/include/avr/wdt.h ****     "out %[rampd], __zero_reg__"        "\n\t" \
 223:/usr/lib/avr/include/avr/wdt.h ****     "out %[ccp_reg], %[ioreg_cen_mask]" "\n\t" \
 224:/usr/lib/avr/include/avr/wdt.h ****     "sts %[wdt_reg], %[disable_mask]"   "\n\t" \
 225:/usr/lib/avr/include/avr/wdt.h ****     "out %[rampd], __tmp_reg__"         "\n\t" \
 226:/usr/lib/avr/include/avr/wdt.h ****     : \
 227:/usr/lib/avr/include/avr/wdt.h ****     : [rampd]             "I" (_SFR_IO_ADDR(RAMPD)),    \
 228:/usr/lib/avr/include/avr/wdt.h ****       [ccp_reg]           "I" (_SFR_IO_ADDR(CCP)),      \
 229:/usr/lib/avr/include/avr/wdt.h ****       [ioreg_cen_mask]    "r" ((uint8_t)CCP_IOREG_gc),   \
 230:/usr/lib/avr/include/avr/wdt.h ****       [wdt_reg]           "n" (_SFR_MEM_ADDR(WDT_CTRL)), \
 231:/usr/lib/avr/include/avr/wdt.h ****       [disable_mask]      "r" ((uint8_t)((~WDT_ENABLE_bm) | WDT_CEN_bm)) \
 232:/usr/lib/avr/include/avr/wdt.h ****     : "r0" \
 233:/usr/lib/avr/include/avr/wdt.h **** );
 234:/usr/lib/avr/include/avr/wdt.h **** 
 235:/usr/lib/avr/include/avr/wdt.h **** #endif // defined (WDT_CTRLA) && !defined(RAMPD)
 236:/usr/lib/avr/include/avr/wdt.h **** 
 237:/usr/lib/avr/include/avr/wdt.h **** #elif defined(__AVR_TINY__)
 238:/usr/lib/avr/include/avr/wdt.h **** 
 239:/usr/lib/avr/include/avr/wdt.h **** #define wdt_enable(value) \
 240:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 241:/usr/lib/avr/include/avr/wdt.h ****     "in __tmp_reg__,__SREG__" "\n\t"  \
 242:/usr/lib/avr/include/avr/wdt.h ****     "cli" "\n\t"  \
 243:/usr/lib/avr/include/avr/wdt.h ****     "wdr" "\n\t"  \
 244:/usr/lib/avr/include/avr/wdt.h ****     "out %[CCPADDRESS],%[SIGNATURE]" "\n\t"  \
 245:/usr/lib/avr/include/avr/wdt.h ****     "out %[WDTREG],%[WDVALUE]" "\n\t"  \
 246:/usr/lib/avr/include/avr/wdt.h ****     "out __SREG__,__tmp_reg__" "\n\t"  \
 247:/usr/lib/avr/include/avr/wdt.h ****     : /* no outputs */  \
 248:/usr/lib/avr/include/avr/wdt.h ****     : [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),  \
 249:/usr/lib/avr/include/avr/wdt.h ****       [SIGNATURE] "r" ((uint8_t)0xD8), \
 250:/usr/lib/avr/include/avr/wdt.h ****       [WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)), \
 251:/usr/lib/avr/include/avr/wdt.h ****       [WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00) \
 252:/usr/lib/avr/include/avr/wdt.h ****       | _BV(WDE) | (value & 0x07) )) \
 253:/usr/lib/avr/include/avr/wdt.h ****     : "r16" \
 254:/usr/lib/avr/include/avr/wdt.h **** )
 255:/usr/lib/avr/include/avr/wdt.h **** 
 256:/usr/lib/avr/include/avr/wdt.h **** #define wdt_disable() \
 257:/usr/lib/avr/include/avr/wdt.h **** do { \
 258:/usr/lib/avr/include/avr/wdt.h **** uint8_t temp_wd; \
 259:/usr/lib/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 260:/usr/lib/avr/include/avr/wdt.h ****     "in __tmp_reg__,__SREG__" "\n\t"  \
 261:/usr/lib/avr/include/avr/wdt.h ****     "cli" "\n\t"  \
 262:/usr/lib/avr/include/avr/wdt.h ****     "wdr" "\n\t"  \
 263:/usr/lib/avr/include/avr/wdt.h ****     "out %[CCPADDRESS],%[SIGNATURE]" "\n\t"  \
 264:/usr/lib/avr/include/avr/wdt.h ****     "in  %[TEMP_WD],%[WDTREG]" "\n\t" \
 265:/usr/lib/avr/include/avr/wdt.h ****     "cbr %[TEMP_WD],%[WDVALUE]" "\n\t" \
 266:/usr/lib/avr/include/avr/wdt.h ****     "out %[WDTREG],%[TEMP_WD]" "\n\t" \
 267:/usr/lib/avr/include/avr/wdt.h ****     "out __SREG__,__tmp_reg__" "\n\t" \
 268:/usr/lib/avr/include/avr/wdt.h ****     : /*no output */ \
 269:/usr/lib/avr/include/avr/wdt.h ****     : [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)), \
 270:/usr/lib/avr/include/avr/wdt.h ****       [SIGNATURE] "r" ((uint8_t)0xD8), \
 271:/usr/lib/avr/include/avr/wdt.h ****       [WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)), \
 272:/usr/lib/avr/include/avr/wdt.h ****       [TEMP_WD] "d" (temp_wd), \
 273:/usr/lib/avr/include/avr/wdt.h ****       [WDVALUE] "n" (1 << WDE) \
 274:/usr/lib/avr/include/avr/wdt.h ****     : "r16" \
 275:/usr/lib/avr/include/avr/wdt.h **** ); \
 276:/usr/lib/avr/include/avr/wdt.h **** }while(0)
 277:/usr/lib/avr/include/avr/wdt.h **** 
 278:/usr/lib/avr/include/avr/wdt.h **** #elif defined(CCP)
 279:/usr/lib/avr/include/avr/wdt.h **** 
 280:/usr/lib/avr/include/avr/wdt.h **** static __inline__
 281:/usr/lib/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 282:/usr/lib/avr/include/avr/wdt.h **** void wdt_enable (const uint8_t value)
 283:/usr/lib/avr/include/avr/wdt.h **** {
 284:/usr/lib/avr/include/avr/wdt.h **** 	if (!_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P (_WD_CONTROL_REG))
 285:/usr/lib/avr/include/avr/wdt.h **** 	{
 286:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 287:/usr/lib/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 288:/usr/lib/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 289:/usr/lib/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 290:/usr/lib/avr/include/avr/wdt.h **** 			"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 291:/usr/lib/avr/include/avr/wdt.h **** 			"sts %[WDTREG],%[WDVALUE]" "\n\t"
 292:/usr/lib/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 293:/usr/lib/avr/include/avr/wdt.h **** 			: /* no outputs */
 294:/usr/lib/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 295:/usr/lib/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 296:/usr/lib/avr/include/avr/wdt.h **** 			[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 297:/usr/lib/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 298:/usr/lib/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 299:/usr/lib/avr/include/avr/wdt.h **** 			: "r0"
 300:/usr/lib/avr/include/avr/wdt.h **** 			);
 301:/usr/lib/avr/include/avr/wdt.h **** 	}
 302:/usr/lib/avr/include/avr/wdt.h **** 	else if (!_SFR_IO_REG_P (CCP) && _SFR_IO_REG_P (_WD_CONTROL_REG))
 303:/usr/lib/avr/include/avr/wdt.h **** 	{
 304:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 305:/usr/lib/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 306:/usr/lib/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 307:/usr/lib/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 308:/usr/lib/avr/include/avr/wdt.h **** 			"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 309:/usr/lib/avr/include/avr/wdt.h **** 			"out %[WDTREG],%[WDVALUE]" "\n\t"
 310:/usr/lib/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 311:/usr/lib/avr/include/avr/wdt.h **** 			: /* no outputs */
 312:/usr/lib/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 313:/usr/lib/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 314:/usr/lib/avr/include/avr/wdt.h **** 			[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 315:/usr/lib/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 316:/usr/lib/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 317:/usr/lib/avr/include/avr/wdt.h **** 			: "r0"
 318:/usr/lib/avr/include/avr/wdt.h **** 			);
 319:/usr/lib/avr/include/avr/wdt.h **** 	}
 320:/usr/lib/avr/include/avr/wdt.h **** 	else if (_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P (_WD_CONTROL_REG))
 321:/usr/lib/avr/include/avr/wdt.h **** 	{
 322:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 323:/usr/lib/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 324:/usr/lib/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 325:/usr/lib/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 326:/usr/lib/avr/include/avr/wdt.h **** 			"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 327:/usr/lib/avr/include/avr/wdt.h **** 			"sts %[WDTREG],%[WDVALUE]" "\n\t"
 328:/usr/lib/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 329:/usr/lib/avr/include/avr/wdt.h **** 			: /* no outputs */
 330:/usr/lib/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 331:/usr/lib/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 332:/usr/lib/avr/include/avr/wdt.h **** 			[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 333:/usr/lib/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 334:/usr/lib/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 335:/usr/lib/avr/include/avr/wdt.h **** 			: "r0"
 336:/usr/lib/avr/include/avr/wdt.h **** 			);
 337:/usr/lib/avr/include/avr/wdt.h **** 	}
 338:/usr/lib/avr/include/avr/wdt.h **** 	else
 339:/usr/lib/avr/include/avr/wdt.h ****  	{
 340:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 341:/usr/lib/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 342:/usr/lib/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 343:/usr/lib/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 344:/usr/lib/avr/include/avr/wdt.h **** 			"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 345:/usr/lib/avr/include/avr/wdt.h **** 			"out %[WDTREG],%[WDVALUE]" "\n\t"
 346:/usr/lib/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 347:/usr/lib/avr/include/avr/wdt.h **** 			: /* no outputs */
 348:/usr/lib/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 349:/usr/lib/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 350:/usr/lib/avr/include/avr/wdt.h **** 			[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 351:/usr/lib/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 352:/usr/lib/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 353:/usr/lib/avr/include/avr/wdt.h **** 			: "r0"
 354:/usr/lib/avr/include/avr/wdt.h **** 			);
 355:/usr/lib/avr/include/avr/wdt.h **** 	}
 356:/usr/lib/avr/include/avr/wdt.h **** }
 357:/usr/lib/avr/include/avr/wdt.h **** 
 358:/usr/lib/avr/include/avr/wdt.h **** static __inline__
 359:/usr/lib/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 360:/usr/lib/avr/include/avr/wdt.h **** void wdt_disable (void)
 361:/usr/lib/avr/include/avr/wdt.h **** {
 362:/usr/lib/avr/include/avr/wdt.h **** 	if (!_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P(_WD_CONTROL_REG))
 363:/usr/lib/avr/include/avr/wdt.h **** 	{
 364:/usr/lib/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 365:/usr/lib/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 366:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 367:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 368:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 369:/usr/lib/avr/include/avr/wdt.h **** 				"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 370:/usr/lib/avr/include/avr/wdt.h **** 				"lds %[TEMP_WD],%[WDTREG]" "\n\t"
 371:/usr/lib/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 372:/usr/lib/avr/include/avr/wdt.h **** 				"sts %[WDTREG],%[TEMP_WD]" "\n\t"
 373:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 374:/usr/lib/avr/include/avr/wdt.h **** 				: /*no output */
 375:/usr/lib/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 376:/usr/lib/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 377:/usr/lib/avr/include/avr/wdt.h **** 				[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 378:/usr/lib/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 379:/usr/lib/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 380:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 381:/usr/lib/avr/include/avr/wdt.h **** 				);
 382:/usr/lib/avr/include/avr/wdt.h **** 	}
 383:/usr/lib/avr/include/avr/wdt.h **** 	else if (!_SFR_IO_REG_P (CCP) && _SFR_IO_REG_P(_WD_CONTROL_REG))
 384:/usr/lib/avr/include/avr/wdt.h **** 	{
 385:/usr/lib/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 386:/usr/lib/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 387:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 388:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 389:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 390:/usr/lib/avr/include/avr/wdt.h **** 				"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 391:/usr/lib/avr/include/avr/wdt.h **** 				"in %[TEMP_WD],%[WDTREG]" "\n\t"
 392:/usr/lib/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 393:/usr/lib/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMP_WD]" "\n\t"
 394:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 395:/usr/lib/avr/include/avr/wdt.h **** 				: /*no output */
 396:/usr/lib/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 397:/usr/lib/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 398:/usr/lib/avr/include/avr/wdt.h **** 				[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 399:/usr/lib/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 400:/usr/lib/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 401:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 402:/usr/lib/avr/include/avr/wdt.h **** 				);
 403:/usr/lib/avr/include/avr/wdt.h **** 	}
 404:/usr/lib/avr/include/avr/wdt.h **** 	else if (_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P(_WD_CONTROL_REG))
 405:/usr/lib/avr/include/avr/wdt.h **** 	{
 406:/usr/lib/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 407:/usr/lib/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 408:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 409:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 410:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 411:/usr/lib/avr/include/avr/wdt.h **** 				"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 412:/usr/lib/avr/include/avr/wdt.h **** 				"lds %[TEMP_WD],%[WDTREG]" "\n\t"
 413:/usr/lib/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 414:/usr/lib/avr/include/avr/wdt.h **** 				"sts %[WDTREG],%[TEMP_WD]" "\n\t"
 415:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 416:/usr/lib/avr/include/avr/wdt.h **** 				: /*no output */
 417:/usr/lib/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 418:/usr/lib/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 419:/usr/lib/avr/include/avr/wdt.h **** 				[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 420:/usr/lib/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 421:/usr/lib/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 422:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 423:/usr/lib/avr/include/avr/wdt.h **** 				);
 424:/usr/lib/avr/include/avr/wdt.h **** 	}
 425:/usr/lib/avr/include/avr/wdt.h **** 	else
 426:/usr/lib/avr/include/avr/wdt.h **** 	{
 427:/usr/lib/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 428:/usr/lib/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 429:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 430:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 431:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 432:/usr/lib/avr/include/avr/wdt.h **** 				"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 433:/usr/lib/avr/include/avr/wdt.h **** 				"in %[TEMP_WD],%[WDTREG]" "\n\t"
 434:/usr/lib/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 435:/usr/lib/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMP_WD]" "\n\t"
 436:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 437:/usr/lib/avr/include/avr/wdt.h **** 				: /*no output */
 438:/usr/lib/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 439:/usr/lib/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 440:/usr/lib/avr/include/avr/wdt.h **** 				[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 441:/usr/lib/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 442:/usr/lib/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 443:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 444:/usr/lib/avr/include/avr/wdt.h **** 				);
 445:/usr/lib/avr/include/avr/wdt.h **** 	}
 446:/usr/lib/avr/include/avr/wdt.h **** }
 447:/usr/lib/avr/include/avr/wdt.h **** 
 448:/usr/lib/avr/include/avr/wdt.h **** #else
 449:/usr/lib/avr/include/avr/wdt.h **** 
 450:/usr/lib/avr/include/avr/wdt.h **** static __inline__
 451:/usr/lib/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 452:/usr/lib/avr/include/avr/wdt.h **** void wdt_enable (const uint8_t value)
 453:/usr/lib/avr/include/avr/wdt.h **** {
 454:/usr/lib/avr/include/avr/wdt.h **** 	if (_SFR_IO_REG_P (_WD_CONTROL_REG))
 455:/usr/lib/avr/include/avr/wdt.h **** 	{
 456:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 457:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 458:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 459:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 460:/usr/lib/avr/include/avr/wdt.h **** 				"out %0, %1" "\n\t"
 461:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 462:/usr/lib/avr/include/avr/wdt.h **** 				"out %0, %2" "\n \t"
 463:/usr/lib/avr/include/avr/wdt.h **** 				: /* no outputs */
 464:/usr/lib/avr/include/avr/wdt.h **** 				: "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 465:/usr/lib/avr/include/avr/wdt.h **** 				"r" ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE))),
 466:/usr/lib/avr/include/avr/wdt.h **** 				"r" ((uint8_t) ((value & 0x08 ? _WD_PS3_MASK : 0x00) |
 467:/usr/lib/avr/include/avr/wdt.h **** 						_BV(WDE) | (value & 0x07)) )
 468:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 469:/usr/lib/avr/include/avr/wdt.h **** 		);
 470:/usr/lib/avr/include/avr/wdt.h **** 	}
 471:/usr/lib/avr/include/avr/wdt.h **** 	else
 472:/usr/lib/avr/include/avr/wdt.h **** 	{
 473:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 2115               		.loc 6 473 0
 2116 0a60 99E2      		ldi r25,lo8(41)
 2117 0a62 88E1      		ldi r24,lo8(24)
 2118               	/* #APP */
 2119               	 ;  473 "/usr/lib/avr/include/avr/wdt.h" 1
 2120 0a64 0FB6      		in __tmp_reg__,__SREG__
 2121 0a66 F894      		cli
 2122 0a68 A895      		wdr
 2123 0a6a 8093 6000 		sts 96, r24
 2124 0a6e 0FBE      		out __SREG__,__tmp_reg__
 2125 0a70 9093 6000 		sts 96, r25
 2126               	 	
 2127               	 ;  0 "" 2
 2128               	.LVL93:
 2129               	/* epilogue start */
 2130               	/* #NOAPP */
 2131               	.LBE106:
 2132               	.LBE105:
 728:main.c        **** 	wdt_enable(WDTO_8S);
 729:main.c        **** 
 730:main.c        **** }
 2133               		.loc 4 730 0
 2134 0a74 DF91      		pop r29
 2135 0a76 CF91      		pop r28
 2136 0a78 0895      		ret
 2137               		.cfi_endproc
 2138               	.LFE36:
 2140               	.global	__floatunsisf
 2141               	.global	__mulsf3
 2142               	.global	__fixunssfsi
 2143               		.section	.text.startup,"ax",@progbits
 2144               	.global	main
 2146               	main:
 2147               	.LFB37:
 731:main.c        **** 
 732:main.c        **** 
 733:main.c        **** int main(void)
 734:main.c        **** {
 2148               		.loc 4 734 0
 2149               		.cfi_startproc
 2150               	/* prologue: function */
 2151               	/* frame size = 0 */
 2152               	/* stack size = 0 */
 2153               	.L__stack_usage = 0
 2154               	.LVL94:
 735:main.c        **** 	uint8_t adcselect = 0;
 736:main.c        **** 	setup();
 2155               		.loc 4 736 0
 2156 0000 0E94 0000 		call setup
 2157               	.LVL95:
 735:main.c        **** 	uint8_t adcselect = 0;
 2158               		.loc 4 735 0
 2159 0004 10E0      		ldi r17,0
 737:main.c        **** 
 738:main.c        **** 	while(1)
 739:main.c        **** 	{
 740:main.c        **** 
 741:main.c        **** 		if (jumptobootloader > 0)
 742:main.c        **** 		{
 743:main.c        **** 			TWCR =   (1<<TWSTO)|(1<<TWIE) | (1<<TWINT) | (1<<TWEA) | (0<<TWEN);
 2160               		.loc 4 743 0
 2161 0006 01ED      		ldi r16,lo8(-47)
 744:main.c        **** 			cli();
 745:main.c        **** 			wdt_disable();
 746:main.c        **** 			UDCON = 1;
 2162               		.loc 4 746 0
 2163 0008 EE24      		clr r14
 2164 000a E394      		inc r14
 747:main.c        **** 			USBCON = (1<<FRZCLK);// disable USB
 2165               		.loc 4 747 0
 2166 000c 30E2      		ldi r19,lo8(32)
 2167 000e D32E      		mov r13,r19
 748:main.c        **** 			UCSR1B = 0;
 749:main.c        **** 			_delay_ms(50);
 750:main.c        **** 			EIMSK = 0; PCICR = 0; SPCR = 0; ACSR = 0; EECR = 0; ADCSRA = 0;
 751:main.c        **** 			TIMSK0 = 0; TIMSK1 = 0; TIMSK3 = 0; TIMSK4 = 0; UCSR1B = 0; TWCR = 0;
 752:main.c        **** 			DDRB = 0; DDRC = 0; DDRD = 0; DDRE = 0; DDRF = 0; TWCR = 0;
 753:main.c        **** 			PORTB = 0; PORTC = 0; PORTD = 0; PORTE = 0; PORTF = 0;
 754:main.c        **** 			asm volatile("jmp 0x7000");
 755:main.c        **** 
 756:main.c        **** 		}
 757:main.c        **** 
 758:main.c        **** 		if (watchdog == 0x01)
 759:main.c        **** 		{
 760:main.c        **** 
 761:main.c        **** 			if (SCL_LINE)
 762:main.c        **** 			{
 763:main.c        **** 				watchi2c++;
 764:main.c        **** 			}
 765:main.c        **** 			else
 766:main.c        **** 			{
 767:main.c        **** 				watchi2c = 0;led[0].r=0; led[0].g=0;led[0].b=0; ws2812_setleds(led,1);
 768:main.c        **** 			}
 769:main.c        **** 
 770:main.c        **** 			if (watchi2c > 10000) {led[0].r=255; led[0].g=255;led[0].b=0; ws2812_setleds(led,1);}
 2168               		.loc 4 770 0
 2169 0010 FF24      		clr r15
 2170 0012 FA94      		dec r15
 771:main.c        **** 		}
 772:main.c        **** 
 773:main.c        **** 		if (!SDA_LINE) {i2cerror++;}
 774:main.c        **** 
 775:main.c        **** 		if (i2cerror > 100)
 776:main.c        **** 		{
 777:main.c        **** 			TWCR =   (1<<TWSTO)|(1<<TWIE) | (1<<TWINT) | (1<<TWEA) | (0<<TWEN);
 778:main.c        **** 			I2C_init(I2C_ADDR);
 779:main.c        **** 			i2cerror = 0;
 780:main.c        **** 			sei();
 781:main.c        **** 		}
 782:main.c        **** 
 783:main.c        **** 		wdt_reset();
 784:main.c        **** 		if (isrtimer > 31250)	 // routine for calculate fan speed - timer is 64khz
 785:main.c        **** 		{						 // 2 signals each turn
 786:main.c        **** 			rpm = fanspin * 30;
 2171               		.loc 4 786 0
 2172 0014 4EE1      		ldi r20,lo8(30)
 2173 0016 C42E      		mov r12,r20
 787:main.c        **** 			fanspin = 0;
 788:main.c        **** 			isrtimer = 0;
 789:main.c        **** 			if (fanlevel == 254) //fan minimal auto
 790:main.c        **** 			{
 791:main.c        **** 				if (rpm > 1950) {OCR0A++;}
 792:main.c        **** 				if (rpm < 1800) {OCR0A--;}
 793:main.c        **** 			}
 794:main.c        **** 		}
 795:main.c        **** 		if (displaychange) {init_backlight(); displaychange = 0;}
 796:main.c        **** 
 797:main.c        **** 		if (changeled)
 798:main.c        **** 		{
 799:main.c        **** 			ws2812_setleds(led,led_position+1);
 800:main.c        **** 			changeled = 0;
 801:main.c        **** 		}
 802:main.c        **** 
 803:main.c        **** 		if (newbllevel != bllevel  && 0 <= newbllevel && newbllevel < 32)
 804:main.c        **** 		{
 805:main.c        **** 
 806:main.c        **** 			if (newbllevel < bllevel)
 807:main.c        **** 			{
 808:main.c        **** 				bllevel--;
 809:main.c        **** 			}
 810:main.c        **** 			else
 811:main.c        **** 			{
 812:main.c        **** 				bllevel++;
 813:main.c        **** 			}
 814:main.c        **** 
 815:main.c        **** 			write_backlight(0b01011000);
 816:main.c        **** 			write_backlight(0b00011111 & bllevel);
 817:main.c        **** 		}
 818:main.c        **** 
 819:main.c        **** 		if (adcselect < 10)
 820:main.c        **** 		{
 821:main.c        **** 			adcselect++;
 822:main.c        **** 		}
 823:main.c        **** 		else
 824:main.c        **** 		{
 825:main.c        **** 			adcselect = 0;
 826:main.c        **** 		}
 827:main.c        **** 
 828:main.c        **** 		switch(adcselect)
 829:main.c        **** 		{
 830:main.c        **** 			case 0: a0 = read_analog(7);  break;
 831:main.c        **** 			case 1: a1 = read_analog(6);  break;
 832:main.c        **** 			case 2: a2 = read_analog(5);  break;
 833:main.c        **** 			case 4: a3 = read_analog(4);  break;
 834:main.c        **** 			case 5: a4 = read_analog(1);  break;
 835:main.c        **** 			case 7: a5 = read_analog(0);  break;
 836:main.c        **** 			case 8: vcc = readVcc();  break;
 837:main.c        ****                         case 9: freeram = freeRam(); break;
 838:main.c        **** 			case 10: temp = GetTemp();   break;
 839:main.c        **** 
 840:main.c        **** 			default:			 //read A7 more frequently
 841:main.c        **** 			{
 842:main.c        **** 				a7 = read_analog(10);
 843:main.c        **** 				if (a7 > a7max) a7max = a7;
 844:main.c        **** 				if (a7 < a7min) a7min = a7;
 845:main.c        **** 				a7count++;
 846:main.c        **** 				if (a7count > 60) {a7avg = (a7max - ((a7max +  a7min)/ 2)) * 0.707 ; a7min = 1024; a7max = 0; a
 2174               		.loc 4 846 0
 2175 0018 C0E0      		ldi r28,0
 2176 001a D4E0      		ldi r29,lo8(4)
 2177               	.LVL96:
 2178               	.L251:
 741:main.c        **** 		{
 2179               		.loc 4 741 0
 2180 001c 8091 0000 		lds r24,jumptobootloader
 2181 0020 8823      		tst r24
 2182 0022 01F4      		brne .+2
 2183 0024 00C0      		rjmp .L252
 743:main.c        **** 			cli();
 2184               		.loc 4 743 0
 2185 0026 0093 BC00 		sts 188,r16
 744:main.c        **** 			wdt_disable();
 2186               		.loc 4 744 0
 2187               	/* #APP */
 2188               	 ;  744 "main.c" 1
 2189 002a F894      		cli
 2190               	 ;  0 "" 2
 2191               	/* #NOAPP */
 2192               	.LBB107:
 2193               	.LBB108:
 474:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 475:/usr/lib/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 476:/usr/lib/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 477:/usr/lib/avr/include/avr/wdt.h **** 				"sts %0, %1" "\n\t"
 478:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 479:/usr/lib/avr/include/avr/wdt.h **** 				"sts %0, %2" "\n \t"
 480:/usr/lib/avr/include/avr/wdt.h **** 				: /* no outputs */
 481:/usr/lib/avr/include/avr/wdt.h **** 				: "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 482:/usr/lib/avr/include/avr/wdt.h **** 				"r" ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE))),
 483:/usr/lib/avr/include/avr/wdt.h **** 				"r" ((uint8_t) ((value & 0x08 ? _WD_PS3_MASK : 0x00) |
 484:/usr/lib/avr/include/avr/wdt.h **** 						_BV(WDE) | (value & 0x07)) )
 485:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 486:/usr/lib/avr/include/avr/wdt.h **** 		);
 487:/usr/lib/avr/include/avr/wdt.h **** 	}
 488:/usr/lib/avr/include/avr/wdt.h **** }
 489:/usr/lib/avr/include/avr/wdt.h **** 
 490:/usr/lib/avr/include/avr/wdt.h **** static __inline__
 491:/usr/lib/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 492:/usr/lib/avr/include/avr/wdt.h **** void wdt_disable (void)
 493:/usr/lib/avr/include/avr/wdt.h **** {
 494:/usr/lib/avr/include/avr/wdt.h **** 	if (_SFR_IO_REG_P (_WD_CONTROL_REG))
 495:/usr/lib/avr/include/avr/wdt.h **** 	{
 496:/usr/lib/avr/include/avr/wdt.h ****         uint8_t register temp_reg;
 497:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 498:/usr/lib/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__"    "\n\t"
 499:/usr/lib/avr/include/avr/wdt.h **** 				"cli"                        "\n\t"
 500:/usr/lib/avr/include/avr/wdt.h **** 				"wdr"                        "\n\t"
 501:/usr/lib/avr/include/avr/wdt.h **** 				"in  %[TEMPREG],%[WDTREG]"   "\n\t"
 502:/usr/lib/avr/include/avr/wdt.h **** 				"ori %[TEMPREG],%[WDCE_WDE]" "\n\t"
 503:/usr/lib/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMPREG]"   "\n\t"
 504:/usr/lib/avr/include/avr/wdt.h **** 				"out %[WDTREG],__zero_reg__" "\n\t"
 505:/usr/lib/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__"   "\n\t"
 506:/usr/lib/avr/include/avr/wdt.h **** 				: [TEMPREG] "=d" (temp_reg)
 507:/usr/lib/avr/include/avr/wdt.h **** 				: [WDTREG]  "I"  (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 508:/usr/lib/avr/include/avr/wdt.h **** 				[WDCE_WDE]  "n"  ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE)))
 509:/usr/lib/avr/include/avr/wdt.h **** 				: "r0"
 510:/usr/lib/avr/include/avr/wdt.h **** 		);
 511:/usr/lib/avr/include/avr/wdt.h **** 	}
 512:/usr/lib/avr/include/avr/wdt.h **** 	else
 513:/usr/lib/avr/include/avr/wdt.h **** 	{
 514:/usr/lib/avr/include/avr/wdt.h ****         uint8_t register temp_reg;
 515:/usr/lib/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 2194               		.loc 6 515 0
 2195               	/* #APP */
 2196               	 ;  515 "/usr/lib/avr/include/avr/wdt.h" 1
 2197 002c 0FB6      		in __tmp_reg__,__SREG__
 2198 002e F894      		cli
 2199 0030 A895      		wdr
 2200 0032 8091 6000 		lds r24,96
 2201 0036 8861      		ori r24,24
 2202 0038 8093 6000 		sts 96,r24
 2203 003c 1092 6000 		sts 96,__zero_reg__
 2204 0040 0FBE      		out __SREG__,__tmp_reg__
 2205               		
 2206               	 ;  0 "" 2
 2207               	/* #NOAPP */
 2208               	.LBE108:
 2209               	.LBE107:
 746:main.c        **** 			USBCON = (1<<FRZCLK);// disable USB
 2210               		.loc 4 746 0
 2211 0042 E092 E000 		sts 224,r14
 747:main.c        **** 			UCSR1B = 0;
 2212               		.loc 4 747 0
 2213 0046 D092 D800 		sts 216,r13
 748:main.c        **** 			_delay_ms(50);
 2214               		.loc 4 748 0
 2215 004a 1092 C900 		sts 201,__zero_reg__
 2216               	.LVL97:
 2217               	.LBB109:
 2218               	.LBB110:
 187:/usr/lib/avr/include/util/delay.h **** 
 2219               		.loc 3 187 0
 2220 004e 2FEF      		ldi r18,lo8(159999)
 2221 0050 80E7      		ldi r24,hi8(159999)
 2222 0052 92E0      		ldi r25,hlo8(159999)
 2223 0054 2150      	1:	subi r18,1
 2224 0056 8040      		sbci r24,0
 2225 0058 9040      		sbci r25,0
 2226 005a 01F4      		brne 1b
 2227 005c 00C0      		rjmp .
 2228 005e 0000      		nop
 2229               	.LVL98:
 2230               	.LBE110:
 2231               	.LBE109:
 750:main.c        **** 			TIMSK0 = 0; TIMSK1 = 0; TIMSK3 = 0; TIMSK4 = 0; UCSR1B = 0; TWCR = 0;
 2232               		.loc 4 750 0
 2233 0060 1DBA      		out 0x1d,__zero_reg__
 2234 0062 1092 6800 		sts 104,__zero_reg__
 2235 0066 1CBC      		out 0x2c,__zero_reg__
 2236 0068 10BE      		out 0x30,__zero_reg__
 2237 006a 1FBA      		out 0x1f,__zero_reg__
 2238 006c 1092 7A00 		sts 122,__zero_reg__
 751:main.c        **** 			DDRB = 0; DDRC = 0; DDRD = 0; DDRE = 0; DDRF = 0; TWCR = 0;
 2239               		.loc 4 751 0
 2240 0070 1092 6E00 		sts 110,__zero_reg__
 2241 0074 1092 6F00 		sts 111,__zero_reg__
 2242 0078 1092 7100 		sts 113,__zero_reg__
 2243 007c 1092 7200 		sts 114,__zero_reg__
 2244 0080 1092 C900 		sts 201,__zero_reg__
 2245 0084 1092 BC00 		sts 188,__zero_reg__
 752:main.c        **** 			PORTB = 0; PORTC = 0; PORTD = 0; PORTE = 0; PORTF = 0;
 2246               		.loc 4 752 0
 2247 0088 14B8      		out 0x4,__zero_reg__
 2248 008a 17B8      		out 0x7,__zero_reg__
 2249 008c 1AB8      		out 0xa,__zero_reg__
 2250 008e 1DB8      		out 0xd,__zero_reg__
 2251 0090 10BA      		out 0x10,__zero_reg__
 2252 0092 1092 BC00 		sts 188,__zero_reg__
 753:main.c        **** 			asm volatile("jmp 0x7000");
 2253               		.loc 4 753 0
 2254 0096 15B8      		out 0x5,__zero_reg__
 2255 0098 18B8      		out 0x8,__zero_reg__
 2256 009a 1BB8      		out 0xb,__zero_reg__
 2257 009c 1EB8      		out 0xe,__zero_reg__
 2258 009e 11BA      		out 0x11,__zero_reg__
 754:main.c        **** 
 2259               		.loc 4 754 0
 2260               	/* #APP */
 2261               	 ;  754 "main.c" 1
 2262 00a0 0C94 0038 		jmp 0x7000
 2263               	 ;  0 "" 2
 2264               	/* #NOAPP */
 2265               	.L252:
 758:main.c        **** 		{
 2266               		.loc 4 758 0
 2267 00a4 8091 0000 		lds r24,watchdog
 2268 00a8 8130      		cpi r24,lo8(1)
 2269 00aa 01F4      		brne .L254
 761:main.c        **** 			{
 2270               		.loc 4 761 0
 2271 00ac 489B      		sbis 0x9,0
 2272 00ae 00C0      		rjmp .L255
 763:main.c        **** 			}
 2273               		.loc 4 763 0
 2274 00b0 8091 0000 		lds r24,watchi2c
 2275 00b4 9091 0000 		lds r25,watchi2c+1
 2276 00b8 0196      		adiw r24,1
 2277 00ba 9093 0000 		sts watchi2c+1,r25
 2278 00be 8093 0000 		sts watchi2c,r24
 2279 00c2 00C0      		rjmp .L256
 2280               	.L255:
 767:main.c        **** 			}
 2281               		.loc 4 767 0
 2282 00c4 1092 0000 		sts watchi2c+1,__zero_reg__
 2283 00c8 1092 0000 		sts watchi2c,__zero_reg__
 2284 00cc 1092 0000 		sts led+1,__zero_reg__
 2285 00d0 1092 0000 		sts led,__zero_reg__
 2286 00d4 1092 0000 		sts led+2,__zero_reg__
 2287 00d8 61E0      		ldi r22,lo8(1)
 2288 00da 70E0      		ldi r23,0
 2289 00dc 80E0      		ldi r24,lo8(led)
 2290 00de 90E0      		ldi r25,hi8(led)
 2291 00e0 0E94 0000 		call ws2812_setleds
 2292               	.LVL99:
 2293               	.L256:
 770:main.c        **** 		}
 2294               		.loc 4 770 0
 2295 00e4 8091 0000 		lds r24,watchi2c
 2296 00e8 9091 0000 		lds r25,watchi2c+1
 2297 00ec 8131      		cpi r24,17
 2298 00ee 9742      		sbci r25,39
 2299 00f0 00F0      		brlo .L254
 770:main.c        **** 		}
 2300               		.loc 4 770 0 is_stmt 0 discriminator 1
 2301 00f2 F092 0000 		sts led+1,r15
 2302 00f6 F092 0000 		sts led,r15
 2303 00fa 1092 0000 		sts led+2,__zero_reg__
 2304 00fe 61E0      		ldi r22,lo8(1)
 2305 0100 70E0      		ldi r23,0
 2306 0102 80E0      		ldi r24,lo8(led)
 2307 0104 90E0      		ldi r25,hi8(led)
 2308 0106 0E94 0000 		call ws2812_setleds
 2309               	.LVL100:
 2310               	.L254:
 773:main.c        **** 
 2311               		.loc 4 773 0 is_stmt 1
 2312 010a 4999      		sbic 0x9,1
 2313 010c 00C0      		rjmp .L258
 773:main.c        **** 
 2314               		.loc 4 773 0 is_stmt 0 discriminator 1
 2315 010e 8091 0000 		lds r24,i2cerror
 2316 0112 8F5F      		subi r24,lo8(-(1))
 2317 0114 8093 0000 		sts i2cerror,r24
 2318               	.L258:
 775:main.c        **** 		{
 2319               		.loc 4 775 0 is_stmt 1
 2320 0118 8091 0000 		lds r24,i2cerror
 2321 011c 8536      		cpi r24,lo8(101)
 2322 011e 00F0      		brlo .L259
 777:main.c        **** 			I2C_init(I2C_ADDR);
 2323               		.loc 4 777 0
 2324 0120 0093 BC00 		sts 188,r16
 778:main.c        **** 			i2cerror = 0;
 2325               		.loc 4 778 0
 2326 0124 8AE2      		ldi r24,lo8(42)
 2327 0126 0E94 0000 		call I2C_init
 2328               	.LVL101:
 779:main.c        **** 			sei();
 2329               		.loc 4 779 0
 2330 012a 1092 0000 		sts i2cerror,__zero_reg__
 780:main.c        **** 		}
 2331               		.loc 4 780 0
 2332               	/* #APP */
 2333               	 ;  780 "main.c" 1
 2334 012e 7894      		sei
 2335               	 ;  0 "" 2
 2336               	/* #NOAPP */
 2337               	.L259:
 783:main.c        **** 		if (isrtimer > 31250)	 // routine for calculate fan speed - timer is 64khz
 2338               		.loc 4 783 0
 2339               	/* #APP */
 2340               	 ;  783 "main.c" 1
 2341 0130 A895      		wdr
 2342               	 ;  0 "" 2
 784:main.c        **** 		{						 // 2 signals each turn
 2343               		.loc 4 784 0
 2344               	/* #NOAPP */
 2345 0132 8091 0000 		lds r24,isrtimer
 2346 0136 9091 0000 		lds r25,isrtimer+1
 2347 013a 8331      		cpi r24,19
 2348 013c 9A47      		sbci r25,122
 2349 013e 00F0      		brlo .L261
 786:main.c        **** 			fanspin = 0;
 2350               		.loc 4 786 0
 2351 0140 2091 0000 		lds r18,fanspin
 2352 0144 3091 0000 		lds r19,fanspin+1
 2353 0148 C29E      		mul r12,r18
 2354 014a C001      		movw r24,r0
 2355 014c C39E      		mul r12,r19
 2356 014e 900D      		add r25,r0
 2357 0150 1124      		clr __zero_reg__
 2358 0152 9093 0000 		sts rpm+1,r25
 2359 0156 8093 0000 		sts rpm,r24
 787:main.c        **** 			isrtimer = 0;
 2360               		.loc 4 787 0
 2361 015a 1092 0000 		sts fanspin+1,__zero_reg__
 2362 015e 1092 0000 		sts fanspin,__zero_reg__
 788:main.c        **** 			if (fanlevel == 254) //fan minimal auto
 2363               		.loc 4 788 0
 2364 0162 1092 0000 		sts isrtimer+1,__zero_reg__
 2365 0166 1092 0000 		sts isrtimer,__zero_reg__
 789:main.c        **** 			{
 2366               		.loc 4 789 0
 2367 016a 2091 0000 		lds r18,fanlevel
 2368 016e 2E3F      		cpi r18,lo8(-2)
 2369 0170 01F4      		brne .L261
 791:main.c        **** 				if (rpm < 1800) {OCR0A--;}
 2370               		.loc 4 791 0
 2371 0172 8F39      		cpi r24,-97
 2372 0174 9740      		sbci r25,7
 2373 0176 00F0      		brlo .L263
 791:main.c        **** 				if (rpm < 1800) {OCR0A--;}
 2374               		.loc 4 791 0 is_stmt 0 discriminator 1
 2375 0178 87B5      		in r24,0x27
 2376 017a 8F5F      		subi r24,lo8(-(1))
 2377 017c 87BD      		out 0x27,r24
 2378               	.L263:
 792:main.c        **** 			}
 2379               		.loc 4 792 0 is_stmt 1
 2380 017e 8091 0000 		lds r24,rpm
 2381 0182 9091 0000 		lds r25,rpm+1
 2382 0186 8830      		cpi r24,8
 2383 0188 9740      		sbci r25,7
 2384 018a 00F4      		brsh .L261
 792:main.c        **** 			}
 2385               		.loc 4 792 0 is_stmt 0 discriminator 1
 2386 018c 87B5      		in r24,0x27
 2387 018e 8150      		subi r24,lo8(-(-1))
 2388 0190 87BD      		out 0x27,r24
 2389               	.L261:
 795:main.c        **** 
 2390               		.loc 4 795 0 is_stmt 1
 2391 0192 8091 0000 		lds r24,displaychange
 2392 0196 8823      		tst r24
 2393 0198 01F0      		breq .L264
 795:main.c        **** 
 2394               		.loc 4 795 0 is_stmt 0 discriminator 1
 2395 019a 0E94 0000 		call init_backlight
 2396               	.LVL102:
 2397 019e 1092 0000 		sts displaychange,__zero_reg__
 2398               	.L264:
 797:main.c        **** 		{
 2399               		.loc 4 797 0 is_stmt 1
 2400 01a2 8091 0000 		lds r24,changeled
 2401 01a6 8823      		tst r24
 2402 01a8 01F0      		breq .L265
 799:main.c        **** 			changeled = 0;
 2403               		.loc 4 799 0
 2404 01aa 6091 0000 		lds r22,led_position
 2405 01ae 70E0      		ldi r23,0
 2406 01b0 6F5F      		subi r22,-1
 2407 01b2 7F4F      		sbci r23,-1
 2408 01b4 80E0      		ldi r24,lo8(led)
 2409 01b6 90E0      		ldi r25,hi8(led)
 2410 01b8 0E94 0000 		call ws2812_setleds
 2411               	.LVL103:
 800:main.c        **** 		}
 2412               		.loc 4 800 0
 2413 01bc 1092 0000 		sts changeled,__zero_reg__
 2414               	.L265:
 803:main.c        **** 		{
 2415               		.loc 4 803 0
 2416 01c0 9091 0000 		lds r25,newbllevel
 2417 01c4 8091 0000 		lds r24,bllevel
 2418 01c8 9817      		cp r25,r24
 2419 01ca 01F0      		breq .L266
 803:main.c        **** 		{
 2420               		.loc 4 803 0 is_stmt 0 discriminator 1
 2421 01cc 9032      		cpi r25,lo8(32)
 2422 01ce 00F4      		brsh .L266
 806:main.c        **** 			{
 2423               		.loc 4 806 0 is_stmt 1
 2424 01d0 9817      		cp r25,r24
 2425 01d2 00F4      		brsh .L267
 808:main.c        **** 			}
 2426               		.loc 4 808 0
 2427 01d4 8150      		subi r24,lo8(-(-1))
 2428 01d6 00C0      		rjmp .L292
 2429               	.L267:
 812:main.c        **** 			}
 2430               		.loc 4 812 0
 2431 01d8 8F5F      		subi r24,lo8(-(1))
 2432               	.L292:
 2433 01da 8093 0000 		sts bllevel,r24
 815:main.c        **** 			write_backlight(0b00011111 & bllevel);
 2434               		.loc 4 815 0
 2435 01de 88E5      		ldi r24,lo8(88)
 2436 01e0 0E94 0000 		call write_backlight
 2437               	.LVL104:
 816:main.c        **** 		}
 2438               		.loc 4 816 0
 2439 01e4 8091 0000 		lds r24,bllevel
 2440 01e8 8F71      		andi r24,lo8(31)
 2441 01ea 0E94 0000 		call write_backlight
 2442               	.LVL105:
 2443               	.L266:
 819:main.c        **** 		{
 2444               		.loc 4 819 0
 2445 01ee 1A30      		cpi r17,lo8(10)
 2446 01f0 00F4      		brsh .L269
 821:main.c        **** 		}
 2447               		.loc 4 821 0
 2448 01f2 1F5F      		subi r17,lo8(-(1))
 2449               	.LVL106:
 828:main.c        **** 		{
 2450               		.loc 4 828 0
 2451 01f4 812F      		mov r24,r17
 2452 01f6 90E0      		ldi r25,0
 2453 01f8 FC01      		movw r30,r24
 2454 01fa 3197      		sbiw r30,1
 2455 01fc EA30      		cpi r30,10
 2456 01fe F105      		cpc r31,__zero_reg__
 2457 0200 00F0      		brlo .+2
 2458 0202 00C0      		rjmp .L270
 2459 0204 E050      		subi r30,lo8(-(gs(.L272)))
 2460 0206 F040      		sbci r31,hi8(-(gs(.L272)))
 2461 0208 0C94 0000 		jmp __tablejump2__
 2462               		.section	.progmem.gcc_sw_table,"a",@progbits
 2463               		.p2align	1
 2464               	.L272:
 2465 0030 0000      		.word gs(.L271)
 2466 0032 0000      		.word gs(.L273)
 2467 0034 0000      		.word gs(.L270)
 2468 0036 0000      		.word gs(.L274)
 2469 0038 0000      		.word gs(.L275)
 2470 003a 0000      		.word gs(.L270)
 2471 003c 0000      		.word gs(.L276)
 2472 003e 0000      		.word gs(.L277)
 2473 0040 0000      		.word gs(.L278)
 2474 0042 0000      		.word gs(.L279)
 2475               		.section	.text.startup
 2476               	.L269:
 2477               	.LVL107:
 830:main.c        **** 			case 1: a1 = read_analog(6);  break;
 2478               		.loc 4 830 0
 2479 020c 87E0      		ldi r24,lo8(7)
 2480 020e 0E94 0000 		call read_analog
 2481               	.LVL108:
 2482 0212 9093 0000 		sts a0+1,r25
 2483 0216 8093 0000 		sts a0,r24
 2484 021a 10E0      		ldi r17,0
 2485 021c 00C0      		rjmp .L251
 2486               	.LVL109:
 2487               	.L271:
 831:main.c        **** 			case 2: a2 = read_analog(5);  break;
 2488               		.loc 4 831 0
 2489 021e 86E0      		ldi r24,lo8(6)
 2490 0220 0E94 0000 		call read_analog
 2491               	.LVL110:
 2492 0224 9093 0000 		sts a1+1,r25
 2493 0228 8093 0000 		sts a1,r24
 2494 022c 00C0      		rjmp .L251
 2495               	.L273:
 832:main.c        **** 			case 4: a3 = read_analog(4);  break;
 2496               		.loc 4 832 0
 2497 022e 85E0      		ldi r24,lo8(5)
 2498 0230 0E94 0000 		call read_analog
 2499               	.LVL111:
 2500 0234 9093 0000 		sts a2+1,r25
 2501 0238 8093 0000 		sts a2,r24
 2502 023c 00C0      		rjmp .L251
 2503               	.L274:
 833:main.c        **** 			case 5: a4 = read_analog(1);  break;
 2504               		.loc 4 833 0
 2505 023e 84E0      		ldi r24,lo8(4)
 2506 0240 0E94 0000 		call read_analog
 2507               	.LVL112:
 2508 0244 9093 0000 		sts a3+1,r25
 2509 0248 8093 0000 		sts a3,r24
 2510 024c 00C0      		rjmp .L251
 2511               	.L275:
 834:main.c        **** 			case 7: a5 = read_analog(0);  break;
 2512               		.loc 4 834 0
 2513 024e 81E0      		ldi r24,lo8(1)
 2514 0250 0E94 0000 		call read_analog
 2515               	.LVL113:
 2516 0254 9093 0000 		sts a4+1,r25
 2517 0258 8093 0000 		sts a4,r24
 2518 025c 00C0      		rjmp .L251
 2519               	.L276:
 835:main.c        **** 			case 8: vcc = readVcc();  break;
 2520               		.loc 4 835 0
 2521 025e 80E0      		ldi r24,0
 2522 0260 0E94 0000 		call read_analog
 2523               	.LVL114:
 2524 0264 9093 0000 		sts a5+1,r25
 2525 0268 8093 0000 		sts a5,r24
 2526 026c 00C0      		rjmp .L251
 2527               	.L277:
 836:main.c        ****                         case 9: freeram = freeRam(); break;
 2528               		.loc 4 836 0
 2529 026e 0E94 0000 		call readVcc
 2530               	.LVL115:
 2531 0272 9093 0000 		sts vcc+1,r25
 2532 0276 8093 0000 		sts vcc,r24
 2533 027a 00C0      		rjmp .L251
 2534               	.L278:
 837:main.c        **** 			case 10: temp = GetTemp();   break;
 2535               		.loc 4 837 0
 2536 027c 0E94 0000 		call freeRam
 2537               	.LVL116:
 2538 0280 9093 0000 		sts freeram+1,r25
 2539 0284 8093 0000 		sts freeram,r24
 2540 0288 00C0      		rjmp .L251
 2541               	.L279:
 838:main.c        **** 
 2542               		.loc 4 838 0
 2543 028a 0E94 0000 		call GetTemp
 2544               	.LVL117:
 2545 028e 9093 0000 		sts temp+1,r25
 2546 0292 8093 0000 		sts temp,r24
 2547 0296 00C0      		rjmp .L251
 2548               	.L270:
 842:main.c        **** 				if (a7 > a7max) a7max = a7;
 2549               		.loc 4 842 0
 2550 0298 8AE0      		ldi r24,lo8(10)
 2551 029a 0E94 0000 		call read_analog
 2552               	.LVL118:
 2553 029e 9093 0000 		sts a7+1,r25
 2554 02a2 8093 0000 		sts a7,r24
 843:main.c        **** 				if (a7 < a7min) a7min = a7;
 2555               		.loc 4 843 0
 2556 02a6 2091 0000 		lds r18,a7max
 2557 02aa 3091 0000 		lds r19,a7max+1
 2558 02ae 2817      		cp r18,r24
 2559 02b0 3907      		cpc r19,r25
 2560 02b2 00F4      		brsh .L281
 843:main.c        **** 				if (a7 < a7min) a7min = a7;
 2561               		.loc 4 843 0 is_stmt 0 discriminator 1
 2562 02b4 9093 0000 		sts a7max+1,r25
 2563 02b8 8093 0000 		sts a7max,r24
 2564               	.L281:
 844:main.c        **** 				a7count++;
 2565               		.loc 4 844 0 is_stmt 1
 2566 02bc 2091 0000 		lds r18,a7min
 2567 02c0 3091 0000 		lds r19,a7min+1
 2568 02c4 8217      		cp r24,r18
 2569 02c6 9307      		cpc r25,r19
 2570 02c8 00F4      		brsh .L282
 844:main.c        **** 				a7count++;
 2571               		.loc 4 844 0 is_stmt 0 discriminator 1
 2572 02ca 9093 0000 		sts a7min+1,r25
 2573 02ce 8093 0000 		sts a7min,r24
 2574               	.L282:
 845:main.c        **** 				if (a7count > 60) {a7avg = (a7max - ((a7max +  a7min)/ 2)) * 0.707 ; a7min = 1024; a7max = 0; a
 2575               		.loc 4 845 0 is_stmt 1
 2576 02d2 8091 0000 		lds r24,a7count
 2577 02d6 8F5F      		subi r24,lo8(-(1))
 2578 02d8 8093 0000 		sts a7count,r24
 2579               		.loc 4 846 0
 2580 02dc 8D33      		cpi r24,lo8(61)
 2581 02de 00F4      		brsh .+2
 2582 02e0 00C0      		rjmp .L251
 2583               		.loc 4 846 0 is_stmt 0 discriminator 1
 2584 02e2 6091 0000 		lds r22,a7max
 2585 02e6 7091 0000 		lds r23,a7max+1
 2586 02ea 8091 0000 		lds r24,a7min
 2587 02ee 9091 0000 		lds r25,a7min+1
 2588 02f2 860F      		add r24,r22
 2589 02f4 971F      		adc r25,r23
 2590 02f6 9695      		lsr r25
 2591 02f8 8795      		ror r24
 2592 02fa 681B      		sub r22,r24
 2593 02fc 790B      		sbc r23,r25
 2594 02fe 80E0      		ldi r24,0
 2595 0300 90E0      		ldi r25,0
 2596 0302 0E94 0000 		call __floatunsisf
 2597               	.LVL119:
 2598 0306 24EF      		ldi r18,lo8(-12)
 2599 0308 3DEF      		ldi r19,lo8(-3)
 2600 030a 44E3      		ldi r20,lo8(52)
 2601 030c 5FE3      		ldi r21,lo8(63)
 2602 030e 0E94 0000 		call __mulsf3
 2603               	.LVL120:
 2604 0312 0E94 0000 		call __fixunssfsi
 2605               	.LVL121:
 2606 0316 7093 0000 		sts a7avg+1,r23
 2607 031a 6093 0000 		sts a7avg,r22
 2608 031e D093 0000 		sts a7min+1,r29
 2609 0322 C093 0000 		sts a7min,r28
 2610 0326 1092 0000 		sts a7max+1,__zero_reg__
 2611 032a 1092 0000 		sts a7max,__zero_reg__
 2612 032e 1092 0000 		sts a7count,__zero_reg__
 2613 0332 00C0      		rjmp .L251
 2614               		.cfi_endproc
 2615               	.LFE37:
 2617               	.global	commands2
 2618               		.data
 2621               	commands2:
 2622 0000 1100      		.word	17
 2623 0002 0000      		.word	0
 2624 0004 0100      		.word	1
 2625 0006 0000      		.word	0
 2626 0008 C100      		.word	193
 2627 000a A801      		.word	424
 2628 000c B101      		.word	433
 2629 000e 4501      		.word	325
 2630 0010 0401      		.word	260
 2631 0012 C500      		.word	197
 2632 0014 8001      		.word	384
 2633 0016 6C01      		.word	364
 2634 0018 C600      		.word	198
 2635 001a BD01      		.word	445
 2636 001c 8401      		.word	388
 2637 001e C700      		.word	199
 2638 0020 BD01      		.word	445
 2639 0022 8401      		.word	388
 2640 0024 BD00      		.word	189
 2641 0026 0201      		.word	258
 2642 0028 1100      		.word	17
 2643 002a 0000      		.word	0
 2644 002c F200      		.word	242
 2645 002e 0001      		.word	256
 2646 0030 0001      		.word	256
 2647 0032 8201      		.word	386
 2648 0034 2600      		.word	38
 2649 0036 0801      		.word	264
 2650 0038 E000      		.word	224
 2651 003a 0001      		.word	256
 2652 003c 0401      		.word	260
 2653 003e 0801      		.word	264
 2654 0040 0B01      		.word	267
 2655 0042 0C01      		.word	268
 2656 0044 1101      		.word	273
 2657 0046 0D01      		.word	269
 2658 0048 0E01      		.word	270
 2659 004a 0001      		.word	256
 2660 004c 0401      		.word	260
 2661 004e 0801      		.word	264
 2662 0050 1301      		.word	275
 2663 0052 1401      		.word	276
 2664 0054 2F01      		.word	303
 2665 0056 2901      		.word	297
 2666 0058 2401      		.word	292
 2667 005a E100      		.word	225
 2668 005c 0001      		.word	256
 2669 005e 0401      		.word	260
 2670 0060 0801      		.word	264
 2671 0062 0B01      		.word	267
 2672 0064 0C01      		.word	268
 2673 0066 1101      		.word	273
 2674 0068 0D01      		.word	269
 2675 006a 0E01      		.word	270
 2676 006c 0001      		.word	256
 2677 006e 0401      		.word	260
 2678 0070 0801      		.word	264
 2679 0072 1301      		.word	275
 2680 0074 1401      		.word	276
 2681 0076 2F01      		.word	303
 2682 0078 2901      		.word	297
 2683 007a 2401      		.word	292
 2684 007c 2600      		.word	38
 2685 007e 0801      		.word	264
 2686 0080 FD00      		.word	253
 2687 0082 0001      		.word	256
 2688 0084 0801      		.word	264
 2689 0086 2900      		.word	41
 2690               	.global	commands
 2693               	commands:
 2694 0088 8000      		.word	128
 2695 008a F801      		.word	504
 2696 008c 4602      		.word	582
 2697 008e 0503      		.word	773
 2698 0090 4004      		.word	1088
 2699 0092 4005      		.word	1344
 2700 0094 4006      		.word	1600
 2701 0096 4007      		.word	1856
 2702 0098 4008      		.word	2112
 2703 009a 4009      		.word	2368
 2704 009c 030A      		.word	2563
 2705               	.global	watchi2c
 2706               		.section .bss
 2709               	watchi2c:
 2710 0000 0000      		.zero	2
 2711               	.global	i2cbuffer
 2714               	i2cbuffer:
 2715 0002 0000      		.zero	2
 2716               		.comm	isrtimer,2,1
 2717               		.comm	fanspin,2,1
 2718               		.comm	rpm,2,1
 2719               		.comm	temp,2,1
 2720               		.comm	vcc,2,1
 2721               		.comm	a7min,2,1
 2722               		.comm	a7max,2,1
 2723               		.comm	a7avg,2,1
 2724               		.comm	a7,2,1
 2725               		.comm	a5,2,1
 2726               		.comm	a4,2,1
 2727               		.comm	a3,2,1
 2728               		.comm	a2,2,1
 2729               		.comm	a1,2,1
 2730               		.comm	a0,2,1
 2731               		.comm	freeram,2,1
 2732               	.global	fanlevel
 2733               		.data
 2736               	fanlevel:
 2737 009e FE        		.byte	-2
 2738               	.global	i2cerror
 2739               		.section .bss
 2742               	i2cerror:
 2743 0004 00        		.zero	1
 2744               		.comm	crc,1,1
 2745               		.comm	changeled,1,1
 2746               	.global	newbllevel
 2747               		.data
 2750               	newbllevel:
 2751 009f 1F        		.byte	31
 2752               	.global	bllevel
 2755               	bllevel:
 2756 00a0 1F        		.byte	31
 2757               		.comm	count,1,1
 2758               	.global	a7count
 2759               		.section .bss
 2762               	a7count:
 2763 0005 00        		.zero	1
 2764               		.comm	buffer_address,1,1
 2765               		.comm	twdrbuffer,1,1
 2766               	.global	commandbyte
 2767               		.data
 2770               	commandbyte:
 2771 00a1 FF        		.byte	-1
 2772               	.global	crc_active
 2775               	crc_active:
 2776 00a2 FF        		.byte	-1
 2777               	.global	led_position
 2778               		.section .bss
 2781               	led_position:
 2782 0006 00        		.zero	1
 2783               	.global	display
 2784               		.data
 2787               	display:
 2788 00a3 FF        		.byte	-1
 2789               	.global	watchdog
 2790               		.section .bss
 2793               	watchdog:
 2794 0007 00        		.zero	1
 2795               	.global	jumptobootloader
 2798               	jumptobootloader:
 2799 0008 00        		.zero	1
 2800               	.global	displaychange
 2803               	displaychange:
 2804 0009 00        		.zero	1
 2805               		.comm	led,3,1
 2806               		.text
 2807               	.Letext0:
 2808               		.file 7 "/usr/lib/avr/include/stdint.h"
 2809               		.file 8 "light_ws2812.h"
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
     /tmp/ccK22PbU.s:2      *ABS*:0000003e __SP_H__
     /tmp/ccK22PbU.s:3      *ABS*:0000003d __SP_L__
     /tmp/ccK22PbU.s:4      *ABS*:0000003f __SREG__
     /tmp/ccK22PbU.s:5      *ABS*:00000000 __tmp_reg__
     /tmp/ccK22PbU.s:6      *ABS*:00000001 __zero_reg__
     /tmp/ccK22PbU.s:11     .text:00000000 _crc8_ccitt_update
     /tmp/ccK22PbU.s:43     .text:00000012 ws2812_sendarray_mask
     /tmp/ccK22PbU.s:93     .text:00000038 loop59
     /tmp/ccK22PbU.s:130    .text:00000068 ws2812_setleds_pin
     /tmp/ccK22PbU.s:167    .text:00000084 ws2812_setleds
     /tmp/ccK22PbU.s:185    .text:0000008a ws2812_sendarray
     /tmp/ccK22PbU.s:203    .text:00000090 write_backlight
     /tmp/ccK22PbU.s:337    .text:0000010a init_backlight
     /tmp/ccK22PbU.s:2755   .data:000000a0 bllevel
     /tmp/ccK22PbU.s:2750   .data:0000009f newbllevel
     /tmp/ccK22PbU.s:414    .text:0000014a write_lcd
     /tmp/ccK22PbU.s:509    .text:0000019e setup_lcd
     /tmp/ccK22PbU.s:2693   .data:00000088 commands
     /tmp/ccK22PbU.s:2621   .data:00000000 commands2
     /tmp/ccK22PbU.s:605    .text:000001f8 read_analog
     /tmp/ccK22PbU.s:689    .text:00000266 readVcc
     /tmp/ccK22PbU.s:761    .text:000002d4 GetTemp
     /tmp/ccK22PbU.s:826    .text:00000332 freeRam
     /tmp/ccK22PbU.s:874    .text:00000360 I2C_init
                            *COM*:00000001 buffer_address
     /tmp/ccK22PbU.s:905    .text:00000376 __vector_9
                            *COM*:00000002 fanspin
     /tmp/ccK22PbU.s:956    .text:000003a8 __vector_23
                            *COM*:00000002 isrtimer
     /tmp/ccK22PbU.s:1003   .text:000003d6 __vector_36
     /tmp/ccK22PbU.s:2770   .data:000000a1 commandbyte
                            *COM*:00000001 crc
     /tmp/ccK22PbU.s:2742   .bss:00000004 i2cerror
                            *COM*:00000002 a0
                            *COM*:00000002 a1
                            *COM*:00000002 a2
                            *COM*:00000002 a3
                            *COM*:00000002 a4
                            *COM*:00000002 a5
                            *COM*:00000002 a7
                            *COM*:00000002 rpm
                            *COM*:00000002 vcc
                            *COM*:00000002 temp
                            *COM*:00000002 freeram
                            *COM*:00000002 a7avg
     /tmp/ccK22PbU.s:2714   .bss:00000002 i2cbuffer
                            *COM*:00000001 twdrbuffer
     /tmp/ccK22PbU.s:2775   .data:000000a2 crc_active
     /tmp/ccK22PbU.s:2781   .bss:00000006 led_position
                            *COM*:00000003 led
     /tmp/ccK22PbU.s:2803   .bss:00000009 displaychange
     /tmp/ccK22PbU.s:2787   .data:000000a3 display
     /tmp/ccK22PbU.s:2736   .data:0000009e fanlevel
                            *COM*:00000001 changeled
     /tmp/ccK22PbU.s:2798   .bss:00000008 jumptobootloader
     /tmp/ccK22PbU.s:2793   .bss:00000007 watchdog
     /tmp/ccK22PbU.s:1974   .text:000009c4 setup
     /tmp/ccK22PbU.s:2146   .text.startup:00000000 main
     /tmp/ccK22PbU.s:2709   .bss:00000000 watchi2c
                            *COM*:00000002 a7max
                            *COM*:00000002 a7min
     /tmp/ccK22PbU.s:2762   .bss:00000005 a7count
                            *COM*:00000001 count

UNDEFINED SYMBOLS
__divmodsi4
__brkval
__heap_start
__tablejump2__
__floatunsisf
__mulsf3
__fixunssfsi
__do_copy_data
__do_clear_bss
